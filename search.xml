<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[三栏布局的解决方案]]></title>
    <url>%2Fblob%2F2019-01-09-solution-of-three-column-layout%2F</url>
    <content type="text"><![CDATA[假设高度已知，请写出三栏布局，左栏、右栏宽度300px，中间宽度自适应。 这道题本身的难度并不大，我们在布局页面的时候，写个三栏布局还是挺简单的。但是如果在面试的时候遇到这道题，就没有那么简单了。看似简单的一道题，想把它答好是不简单的。往往越简单的题越不好答。如果看到这题只想到了浮动和绝对定位，那这题你连及格都及格不了。 几种三栏布局的方法。 在写布局代码之前，先写两段公共的样式，此段写在头部。 样式 123456789 &lt;style media="screen"&gt; html *&#123; padding: 0; margin: 0; &#125; .layout article div&#123; min-height: 100px; &#125;&lt;/style&gt; 浮动布局 12345678910111213141516171819202122232425262728 &lt;!--浮动布局 --&gt;&lt;section class="layout float"&gt; &lt;style media="screen"&gt; .layout.float .left&#123; float:left; width:300px; background: red; &#125; .layout.float .center&#123; background: yellow; &#125; .layout.float .right&#123; float:right; width:300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h2&gt;浮动解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 浮动布局是有局限性的，浮动元素是脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如高度塌陷等。 浮动布局的优点就是比较简单，兼容性也比较好。只要清除浮动做的好，是没有什么问题的。 延伸：你知道哪些清除浮动的方案？每种方案的有什么优缺点? 绝对定位布局 123456789101112131415161718192021222324252627282930313233 &lt;!-- 绝对布局 --&gt;&lt;section class="layout absolute"&gt; &lt;style&gt; .layout.absolute .left-center-right&gt;div&#123; position: absolute; &#125; .layout.absolute .left&#123; left:0; width: 300px; background: red; &#125; .layout.absolute .center&#123; left: 300px; right: 300px; background: yellow; &#125; .layout.absolute .right&#123; right:0; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class="left-center-right"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h2&gt;绝对定位解决方案&lt;/h2&gt; 1.这是三栏布局的绝对定位解决方案； 2.这是三栏布局的绝对定位解决方案; &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 绝对定位布局优点，很快捷，设置很方便，而且也不容易出问题，你可以很快的就能想出这种布局方式。 缺点就是，绝对定位是脱离文档流的，意味着下面的所有子元素也会脱离文档流，这就导致了这种方法的有效性和可使用性是比较差的。 flex布局 123456789101112131415161718192021222324252627282930313233 &lt;!-- flexbox布局 --&gt;&lt;section class="layout flexbox"&gt; &lt;style&gt; .layout.flexbox&#123; margin-top: 110px; &#125; .layout.flexbox .left-center-right&#123; display: flex; &#125; .layout.flexbox .left&#123; width: 300px; background: red; &#125; .layout.flexbox .center&#123; flex:1; background: yellow; &#125; .layout.flexbox .right&#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class="left-center-right"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h2&gt;flexbox解决方案&lt;/h2&gt; 1.这是三栏布局的felx解决方案； 2.这是三栏布局的flex解决方案； &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; felxbox布局是css3里新出的一个，它就是为了解决上述两种方式的不足出现的，是比较完美的一个。目前移动端的布局也都是用flexbox。 felxbox的缺点就是不能兼容IE8及以下浏览器。 表格布局 12345678910111213141516171819202122232425262728293031323334 &lt;!-- 表格布局 --&gt;&lt;section class="layout table"&gt; &lt;style&gt; .layout.table .left-center-right&#123; width:100%; height: 100px; display: table; &#125; .layout.table .left-center-right&gt;div&#123; display: table-cell; &#125; .layout.table .left&#123; width: 300px; background: red; &#125; .layout.table .center&#123; background: yellow; &#125; .layout.table .right&#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class="left-center-right"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h2&gt;表格布局解决方案&lt;/h2&gt; 1.这是三栏布局的表格解决方案； 2.这是三栏布局的表格解决方案; &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 表格布局在历史上遭到很多人的摒弃，说表格布局麻烦，操作比较繁琐，其实这是一种误解，在很多场景中，表格布局还是很适用的，比如这个三栏布局，用表格布局就轻易写出来了。还有表格布局的兼容性很好，在flex布局不兼容的时候，可以尝试表格布局。 表格布局也是有缺陷的，当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，而有时候这种效果不是我们想要的。 网格布局 1234567891011121314151617181920212223242526272829303132333435 &lt;!-- 网格布局 --&gt;&lt;section class="layout grid"&gt; &lt;style&gt; .layout.grid .left-center-right&#123; width:100%; display: grid; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; .layout.grid .left-center-right&gt;div&#123; &#125; .layout.grid .left&#123; width: 300px; background: red; &#125; .layout.grid .center&#123; background: yellow; &#125; .layout.grid .right&#123; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class="left-center-right"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h2&gt;网格布局解决方案&lt;/h2&gt; 1.这是三栏布局的网格布局解决方案； 2.这是三栏布局的网格布局解决方案; &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 网格布局也是新出的一种布局方式，如果你答出这种方式，也就证明了你的实力，证明你对技术热点是有追求的，也说明你有很强的学习能力。 cale()计算宽度 1234567891011121314151617181920212223242526272829 &lt;section class="layout cale"&gt; &lt;style media="screen"&gt; .layout article div&#123; display: inline-block; min-height: 100px; vertical-align: top; &#125; .layout.cale .left&#123; width:300px; background: red; &#125; .layout.cale .center&#123; background: yellow; width: calc(100% - 600px); &#125; .layout.cale .right&#123; width:300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt;&lt;div class="center"&gt; &lt;h2&gt;cale解决方案&lt;/h2&gt; 1.这是三栏布局的cale解决方案； 2.这是三栏布局的cale解决方案； &lt;/div&gt;&lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 这里面有两个问题解决，一个是inline-block元素之间的空隙的消除，一个是inline-block元素上浮无法对齐。 calc的兼容性 效果图 这几种解决方案应该是最常见的三栏布局，如果你还有其他的方案，欢迎补充！ 延伸 最后这个问题还有很多延伸问题的，比如， 高度已知换为高度未知呢？块内内容超出会是怎样的效果？如果是上下高度已知，中间自适应呢？如果是两栏布局呢？如果是上下左右混合布局呢？以上几个延伸你能否轻松应对，如果绝对还有欠缺，尽早查缺补漏吧！ 欢迎补充！ 参考 https://www.cnblogs.com/chengzp/p/layout.htmlhttps://www.css88.com/book/css/values/functional/calc().htm]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>三栏布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解BFC]]></title>
    <url>%2Fblob%2F2019-01-08-understanding-bfc%2F</url>
    <content type="text"><![CDATA[定义 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。 A block formatting context is a part of a visual CSS rendering of a Web page. It is the region in which the layout of block boxes occurs and in which floats interact with other elements. 创建块格式化上下文方式 根元素或包含根元素的元素 浮动元素（元素的 float 不是 `none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table） overflow 值不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content或 strict 的元素 弹性元素（display为 flex 或 inline-flex元素的直接子元素） 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1） column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug） 参考 https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_contexthttps://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context https://www.w3.org/TR/CSS21/visuren.html#block-formatting https://drafts.csswg.org/css-display/#block-formatting-context]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>BFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取网页屏幕可见区域高度]]></title>
    <url>%2Fblob%2F2019-01-08-get-the-height-of-the-visible-area-on-the-page-screen%2F</url>
    <content type="text"><![CDATA[document.body.clientWidth ==&gt; BODY对象宽度document.body.clientHeight ==&gt; BODY对象高度document.documentElement.clientWidth ==&gt; 可见区域宽度document.documentElement.clientHeight ==&gt; 可见区域高度 网页可见区域宽： document.body.clientWidth网页可见区域高： document.body.clientHeight网页可见区域宽： document.body.offsetWidth (包括边线的宽)网页可见区域高： document.body.offsetHeight (包括边线的高)网页正文全文宽： document.body.scrollWidth网页正文全文高： document.body.scrollHeight网页被卷去的高： document.body.scrollTop网页被卷去的左： document.body.scrollLeft网页正文部分上： window.screenTop网页正文部分左： window.screenLeft屏幕分辨率的高： window.screen.height屏幕分辨率的宽： window.screen.width屏幕可用工作区高度： window.screen.availHeight屏幕可用工作区宽度： window.screen.availWidth // 部分jQuery函数$(window).height() //浏览器时下窗口可视区域高度$(document).height() //浏览器时下窗口文档的高度$(document.body).height() //浏览器时下窗口文档body的高度$(document.body).outerHeight(true) //浏览器时下窗口文档body的总高度 包括border padding margin$(window).width() //浏览器时下窗口可视区域宽度$(document).width()//浏览器时下窗口文档对于象宽度$(document.body).width() //浏览器时下窗口文档body的高度$(document.body).outerWidth(true) //浏览器时下窗口文档body的总宽度 包括border padding HTML精确定位:scrollLeft,scrollWidth,clientWidth,offsetWidthscrollHeight: 获取对象的滚动高度。scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离scrollWidth:获取对象的滚动宽度offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置event.clientX 相对文档的水平座标event.clientY 相对文档的垂直座标event.offsetX 相对容器的水平坐标event.offsetY 相对容器的垂直坐标document.documentElement.scrollTop 垂直方向滚动的值event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>高度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS盒模型]]></title>
    <url>%2Fblob%2F2019-01-08-css-box-model%2F</url>
    <content type="text"><![CDATA[本文章将会从以下几个方面谈谈盒模型。 基本概念：标准模型 和IE模型 CSS如何设置这两种模型 JS如何设置获取盒模型对应的宽和高 实例题（根据盒模型解释边距重叠） BFC（边距重叠解决方案） 基本概念 盒模型（又称框模型、Box Model）的组成大家肯定都懂，由里向外content,padding,border,margin. 盒模型是有两种标准的，一个是标准盒模型，一个是IE盒模型。 从上面两图不难看出 在标准模型中，盒模型的宽高只是内容（content）的宽高，这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距。当我们实现响应式布局时，这个特点尤其烦人。 而在IE模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高。大多数情况下这使得我们更容易的去设定一个元素的宽高。 css如何设置两种模型 这里用到了CSS3 的属性 box-sizing 1234567891011121314151617181920212223 /* 标准模型 */box-sizing:content-box;/*IE模型*/box-sizing:border-box;/*从父元素继承 box-sizing 属性*/box-sizing:inherit;/*默认值*/box-sizing:initial;/* 支持 Firefox, Chrome, Safari, Opera, IE8+ 和老的Android浏览器 */.example &#123; /* Chrome 9-, Safari 5-, iOS 4.2-, Android 3-, Blackberry 7- */ -webkit-box-sizing: border-box; /* Firefox (desktop or Android) 28- */ -moz-box-sizing: border-box; /* Firefox 29+, IE 8+, Chrome 10+, Safari 5.1+, Opera 9.5+, iOS 5+, Opera Mini Anything, Blackberry 10+, Android 4+ */ box-sizing: border-box;&#125; 一些专家甚至建议所有的Web开发者们将所有的元素的box-sizing都设为border-box。 123456 html &#123; box-sizing: border-box;&#125;*, *:before, *:after &#123; box-sizing: inherit;&#125; JS获取宽高 通过JS获取盒模型对应的宽和高，有以下几种方法： 为了方便书写，以下用dom来表示获取的HTML的节点。 dom.style.width/height 这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的。 dom.currentStyle.width/height 这种方式获取的是在页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。 但这种方式只有IE浏览器支持。 window.getComputedStyle(dom).width/height 这种方式的原理和2是一样的，这个可以兼容更多的浏览器，通用性好一些。 dom.getBoundingClientRect().width/height 这种方式是根据元素在视窗中的绝对位置来获取宽高的 dom.offsetWidth/offsetHeight 这个就没什么好说的了，最常用的，也是兼容最好的。 边距重叠 什么是边距重叠 如下图，父元素没有设置margin-top，而子元素设置了margin-top：20px;可以看出，父元素也一起有了边距。 上图的代码 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; .demo&#123; height:100px; background: #eee; &#125; .parent&#123; height:200px; background: #88f; &#125; .child&#123; height:100px; margin-top:20px; background: #0ff; width:200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class="demo"&gt; &lt;h2&gt;此部分是能更容易看出让下面的块的margin-top。&lt;/h2&gt; &lt;/section&gt; &lt;section class = "parent"&gt; &lt;article class="child"&gt; &lt;h2&gt;子元素&lt;/h2&gt; margin-top:20px; &lt;/article&gt; &lt;h2&gt;父元素&lt;/h2&gt; 没有设置margin-top &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 边距重叠解决方案(BFC) 首先要明确BFC是什么意思，其全英文拼写为 Block Formatting Context 直译为“块级格式化上下文” BFC的原理 内部的box会在垂直方向，一个接一个的放置 每个元素的margin box的左边，与包含块border box的左边相接触（对于从做往右的格式化，否则相反） box垂直方向的距离由margin决定，属于同一个bfc的两个相邻box的margin会发生重叠 bfc的区域不会与浮动区域的box重叠 bfc是一个页面上的独立的容器，外面的元素不会影响bfc里的元素，反过来，里面的也不会影响外面的 计算bfc高度的时候，浮动元素也会参与计算 怎么去创建bfc float属性不为none（脱离文档流） position为absolute或fixed浮动之后不指定top`bottomleftright可实现bfc，但是会脱离文档流，后续内容要使用margin-top`撑开，等其他方法。 display为inline-block,table-cell,table-caption,flex,inline-flex inline-block 转化为行内块元素后需要指定宽度，如果两个inline-block在同一行，会有元素之间有空隙、元素上浮无法对齐的问题 table-cell table-caption 作为一个表格标题显示后需要指定宽度 flex 在父元素使用，可能需要flex-direction: column配合来使用 inlin-flex 转化为行内伸缩容器后需要指定宽度 overflow不为visible需要在父元素指定 根元素 应用场景 自适应两栏布局 清除内部浮动 防止垂直margin重叠 防止文字环绕（overflow:hidden） 看一个垂直margin重叠例子 1234567891011121314151617181920212223242526272829303132333435 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; .top&#123; background: #0ff; height:100px; margin-bottom:30px; &#125; .bottom&#123; height:100px; margin-top:50px; background: #ddd; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class="top"&gt; &lt;h1&gt;上&lt;/h1&gt; margin-bottom:30px; &lt;/section&gt; &lt;section class="bottom"&gt; &lt;h1&gt;下&lt;/h1&gt; margin-top:50px; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果图 用bfc可以解决垂直margin重叠的问题 关键代码 123456789101112 &lt;section class="top"&gt; &lt;h1&gt;上&lt;/h1&gt; margin-bottom:30px;&lt;/section&gt;&lt;!-- 给下面这个块添加一个父元素，在父元素上创建bfc --&gt;&lt;div style="overflow:hidden"&gt; &lt;section class="bottom"&gt; &lt;h1&gt;下&lt;/h1&gt; margin-top:50px; &lt;/section&gt;&lt;/div&gt; 效果图 边距重叠解决方案(父元素) 给父元素加边框border （副作用） 给父元素设置padding值 （副作用） 父元素添加 overflow: hidden （副作用） 父元素添加 display: flex（推荐） 父元素加前置内容生成。（推荐） 12345678910111213141516 .parent &#123; width : 500px; height : 500px; background-color : red; &#125;.parent::before, .parent::after &#123; content : " "; display : table;&#125;.child &#123; width : 200px; height : 200px; background-color : green; margin-top : 50px;&#125; 123 &lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;/div&gt; 参考地址 https://www.cnblogs.com/chengzp/p/cssbox.htmlhttps://www.cnblogs.com/clearsky/p/5696286.html]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>盒模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo文章目录样式调整]]></title>
    <url>%2Fblob%2F2019-01-08-hexo-article-catalog-style-adjustment%2F</url>
    <content type="text"><![CDATA[修改自定义样式文件 样式文件文件位于 1 themes/hexo/source/css/_common/components/sidebar/sidebar-toc.styl 文章目录默认展开 12 // 文章目录默认展开.post-toc .nav .nav-child &#123; display: block; &#125; 修改主题配置文件 主题配置文件位于 1 themes/hexo/_config.yml 每行目录超长自动换行 123 toc: enable: true wrap: true]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[写好 JS 条件语句的几条守则]]></title>
    <url>%2Fblob%2F2019-01-07-several-rules-for-writing-js-conditional-statements%2F</url>
    <content type="text"><![CDATA[英文：ecelyn Yeen 译文：眠云(杨涛)github.com/dawn-plex/translate/blob/master/articles/5-Tips-to-Write-Better-Conditionals-in-JavaScript.md在用 JavaScript 工作时，我们经常和条件语句打交道，这里有5条让你写出更好/干净的条件语句的建议。转载地址：https://mp.weixin.qq.com/s/0Dsvp-n8lTco930tvW4-1w 多重判断时使用 Array.includes 让我们看一下下面这个例子: 123456 // conditionfunction test(fruit) &#123; if (fruit == 'apple' || fruit == 'strawberry') &#123; console.log('red'); &#125;&#125; 第一眼，上面这个例子看起来没问题。如果我们有更多名字叫 cherry 和 cranberries 的红色水果呢？我们准备用更多的 || 来拓展条件语句吗？ 我们可以用 Array.includes (Array.includes)重写条件语句。 1234567 function test(fruit) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (redFruits.includes(fruit)) &#123; console.log('red'); &#125;&#125; 我们把红色的水果(red fruits)这一判断条件提取到一个数组。这样一来，代码看起来更整洁。 更少的嵌套，尽早 Return 让我们拓展上一个例子让它包含两个条件。 如果没有传入参数 fruit，抛出错误 接受 quantity 参数，并且在 quantity 大于 10 时打印出来 1234567891011121314151617181920212223 function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1: fruit 必须有值 if (fruit) &#123; // 条件 2: 必须是red的 if (redFruits.includes(fruit)) &#123; console.log('red'); // 条件 3: quantity大于10 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125; &#125; &#125; else &#123; throw new Error('No fruit!'); &#125;&#125;// 测试结果test(null); // error: No fruitstest('apple'); // print: redtest('apple', 20); // print: red, big quantity 在上面的代码, 我们有: 1个 if/else 语句筛选出无效的语句 3层if嵌套语句 (条件 1, 2 &amp; 3) 我个人遵循的规则一般是在发现无效条件时，尽早Return。 123456789101112131415161718 /_ 当发现无效语句时，尽早Return _/function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1: 尽早抛出错误 if (!fruit) throw new Error('No fruit!'); // 条件 2: 必须是红色的 if (redFruits.includes(fruit)) &#123; console.log('red'); // 条件 3: 必须是大质量的 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125; &#125;&#125; 这样一来，我们少了一层嵌套语句。这种编码风格非常好，尤其是当你有很长的if语句的时候(想象你需要滚动到最底层才知道还有else语句，这并不酷) 我们可以通过 倒置判断条件 &amp; 尽早return 进一步减少if嵌套。看下面我们是怎么处理判断 条件2 的: 1234567891011121314151617 /_ 当发现无效语句时，尽早Return _/function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1: 尽早抛出错误 if (!fruit) throw new Error('No fruit!'); // 条件 2: 当水果不是红色时停止继续执行 if (!redFruits.includes(fruit)) return; console.log('red'); // 条件 3: 必须是大质量的 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125;&#125; 通过倒置判断条件2，我们的代码避免了嵌套语句。这个技巧在我们需要进行很长的逻辑判断时是非常有用的，特别是我们希望能够在条件不满足时能够停止下来进行处理。 而且这么做并不困难。问问自己，这个版本(没有嵌套)是不是比之前的(两层条件嵌套)更好，可读性更高？ 但对于我，我会保留先前的版本(包含两层嵌套)。这是因为: 代码比较短且直接，包含if嵌套的更清晰 倒置判断条件可能加重思考的负担(增加认知载荷) 因此，应当尽力减少嵌套和尽早return，但不要过度。如果你感兴趣的话，可以看一下关于这个话题的一篇文章和 StackOverflow 上的讨论。 Avoid Else, Return Early by Tim Oxley StackOverflow discussion on if/else coding style 使用默认参数和解构 我猜下面的代码你可能会熟悉，在JavaScript中我们总是需要检查 null / undefined的值和指定默认值: 1234567891011 function test(fruit, quantity) &#123; if (!fruit) return; // 如果 quantity 参数没有传入，设置默认值为 1 const q = quantity || 1; console.log(`We have $&#123;q&#125; $&#123;fruit&#125;!`);&#125;//test resultstest('banana'); // We have 1 banana!test('apple', 2); // We have 2 apple! 实际上，我们可以通过声明 默认函数参数 来消除变量 q。 123456789 function test(fruit, quantity = 1) &#123; // 如果 quantity 参数没有传入，设置默认值为 1 if (!fruit) return; console.log(`We have $&#123;quantity&#125; $&#123;fruit&#125;!`);&#125;//test resultstest('banana'); // We have 1 banana!test('apple', 2); // We have 2 apple! 这更加直观，不是吗？注意，每个声明都有自己的默认参数. 例如，我们也能给fruit分配默认值:function test(fruit = &#39;unknown&#39;, quantity = 1)。 如果fruit是一个object会怎么样？我们能分配一个默认参数吗？ 12345678910111213 function test(fruit) &#123; // 当值存在时打印 fruit 的值 if (fruit &amp;&amp; fruit.name) &#123; console.log (fruit.name); &#125; else &#123; console.log('unknown'); &#125;&#125;//test resultstest(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple 看上面这个例子，我们想打印 fruit 对象中可能存在的 name 属性。否则我们将打印unknown。我们可以通过默认参数以及解构从而避免判断条件 fruit &amp;&amp; fruit.name 12345678910 // 解构 - 仅仅获取 name 属性// 为其赋默认值为空对象function test(&#123;name&#125; = &#123;&#125;) &#123; console.log (name || 'unknown');&#125;// test resultstest(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple 由于我们只需要 name 属性，我们可以用 {name} 解构出参数，然后我们就能使用变量 name 代替 fruit.name。 我们也需要声明空对象 {} 作为默认值。如果我们不这么做，当执行 test(undefined) 时，你将得到一个无法对 undefined 或 null 解构的的错误。因为在 undefined 中没有 name 属性。 使用第三方库减少null的检查 如果你不介意使用第三方库，这有一些方式减少null的检查: 使用 Lodash get函数 使用Facebook开源的idx库(with Babeljs) 这是一个使用Lodash的例子: 123456789 function test(fruit) &#123; // 获取属性名，如果属性名不可用，赋默认值为 unknown console.log(__.get(fruit, 'name', 'unknown'); &#125;// test resultstest(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple 你可以在jsbin运行demo代码。除此之外，如果你是函数式编程的粉丝，你可能选择使用 Lodash fp，Lodash的函数式版本(方法变更为get或者getOr)。 倾向于对象遍历而不是Switch语句 让我们看下面这个例子，我们想根据 color 打印出水果: 1234567891011121314151617 function test(color) &#123; // 使用条件语句来寻找对应颜色的水果 switch (color) &#123; case 'red': return ['apple', 'strawberry']; case 'yellow': return ['banana', 'pineapple']; case 'purple': return ['grape', 'plum']; default: return []; &#125;&#125;// test resultstest(null); // []test('yellow'); // ['banana', 'pineapple'] 上面的代码看起来没有错误，但是我找到了一些累赘。用对象遍历实现相同的结果，语法看起来更简洁: 123456789 const fruitColor = &#123; red: ['apple', 'strawberry'], yellow: ['banana', 'pineapple'], purple: ['grape', 'plum']&#125;;function test(color) &#123; return fruitColor[color] || [];&#125; 或者你也可以使用 Map实现相同的结果: 12345678 const fruitColor = new Map() .set('red', ['apple', 'strawberry']) .set('yellow', ['banana', 'pineapple']) .set('purple', ['grape', 'plum']);function test(color) &#123; return fruitColor.get(color) || [];&#125; Map是一种在 ES2015 规范之后实现的对象类型，允许你存储 key 和 value 的值。 但我们是否应当禁止switch语句的使用呢？答案是不要限制你自己。从个人来说，我会尽可能的使用对象遍历，但我并不严格遵守它，而是使用对当前的场景更有意义的方式。 Todd Motto有一篇关于 switch 语句对比对象遍历的更深入的文章，你可以在这个地方阅读 重构语法 在上面的例子，我们能够用Array.filter 重构我们的代码，实现相同的效果。 123456789101112 const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'strawberry', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'pineapple', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;, &#123; name: 'plum', color: 'purple' &#125;];function test(color) &#123; return fruits.filter(f =&gt; f.color == color);&#125; 有着不止一种方法能够实现相同的结果，我们以上展示了 4 种。 对 所有/部分 判断使用Array.every &amp; Array.some 这最后一个建议更多是关于利用 JavaScript Array 的内置方法来减少代码行数。看下面的代码，我们想要检查是否所有水果都是红色: 1234567891011121314151617 const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125; ];function test() &#123; let isAllRed = true; // 条件：所有水果都是红色 for (let f of fruits) &#123; if (!isAllRed) break; isAllRed = (f.color == 'red'); &#125; console.log(isAllRed); // false&#125; 代码那么长！我们可以通过 Array.every减少代码行数: 1234567891011 const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125; ];function test() &#123; const isAllRed = fruits.every(f =&gt; f.color == 'red'); console.log(isAllRed); // false&#125; 现在更简洁了，不是吗？相同的方式，如果我们想测试是否存在红色的水果，我们可以使用 Array.some 一行代码实现。 123456789101112 const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;];function test() &#123; // 条件：任何一个水果是红色 const isAnyRed = fruits.some(f =&gt; f.color == 'red'); console.log(isAnyRed); // true&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>条件语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动]]></title>
    <url>%2Fblob%2F2019-01-04-clear-floating%2F</url>
    <content type="text"><![CDATA[父级元素使用高度 因为浮动导致父元素高度塌陷，所以给父元素添加高度。 优点：简单、代码少、容易掌握 缺点：高度固定，如果两则皆不是固定高度，该方法不可用 建议：可以再少数固定高度的情况使用 css 12 .float-wraper&#123;height: 100px;&#125;.float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125; html 123 &lt;div class="float-wraper"&gt; &lt;div class="float-inner"&gt;&lt;/div&gt;&lt;/div&gt; 父级元素使用overflow:hidden 使用时浏览器会自动检测浮动区域的高度，如果父元素本身有高度，且子元素高度超出父元素高度，则超出部分被隐藏。同时使用使用width或者zoom:1 来兼容IE6 IE7。 优点：简单、代码少、浏览器支持好 缺点：和子元素使用position、父元素使用height配合时，小心子元素超出部分被隐藏 建议：子元素不要使用position，父元素不要使用height css 12 .float-wraper&#123;overflow: hidden; zoom: 1;&#125;.float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125; html 1 &lt;!-- 同上 --&gt; 父级元素使用 overflow:auto 使用方法同上。 css 12 .float-wraper&#123;overflow: auto; zoom: 1;&#125;.float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125; html 1 &lt;!-- 同上 --&gt; Tips：这两种方法统计为：使用overflow属性，把它设置为非默认值visible的值。 overflow之所以能够有效是因为当它的值是非visible时会创建一个BFC，而BFC的一个特性就是包裹浮动元素。 父级元素使用 display:table 将div 的display变成table，使父元素高度不会塌陷。 css 12 .float-wraper&#123;display: table;&#125;.float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125; html 1 &lt;!-- 同上 --&gt; 建议：不建议使用 父级元素使用 display:inlin-block 将div 的display变成inlin-block，变成行内块元素后父元素高度不会塌陷。 *display 和*zoom为了兼容IE6 IE7 css 12 .float-wraper&#123;display: inline-block; *display: inline; *zoom: 1;&#125;.float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125; html 1 &lt;!-- 同上 --&gt; 缺点：无法使用margin: 0 auto;居中 父级元素也使用浮动 css 12 .float-wraper&#123;float: left;&#125;.float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125; html 1 &lt;!-- 同上 --&gt; 缺点：会产生新的浮动，要一直浮动到body 建议：只作为了解 结尾处添加空元素clear: both 在结尾处清除浮动 css 12 .float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125;.float-clear&#123;clear: both;&#125; html 1234 &lt;div class="float-wraper"&gt; &lt;div class="float-inner"&gt;&lt;/div&gt; &lt;div class="float-clear"&gt;&lt;/div&gt;&lt;/div&gt; 缺点：此方法需要在结尾添加一个节点，不够友好 结尾处添加br元素 clear=”both” br标签自带clear属性，原理和上一个方法一样，在结尾处清除浮动 css 1 .float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125; html 1234 &lt;div class="float-wraper"&gt; &lt;div class="float-inner"&gt;&lt;/div&gt; &lt;br clear="both"&gt;&lt;/div&gt; 缺点：此方法需要在结尾添加一个节点，不够友好 父级元素添加after和zoom-(主流) 添加一个有内容的伪元素，设置成块级元素，清除尾部的浮动，同时设置成不可见，保证不占用位置。 为了兼容IE6 IE7使用zoom，IE8以上和非IE浏览器才支持::after css 123 .float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125;.clearfix::after&#123;content:" "; display:block; clear:both; visibility:hidden; height:0&#125; .clearfix&#123;zoom:1&#125; html 123 &lt;div class="float-wraper clearfix"&gt; &lt;div class="float-inner"&gt;&lt;/div&gt;&lt;/div&gt; 优点：浏览器支持好、不容易出现怪问题]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>清除浮动</tag>
        <tag>both</tag>
        <tag>clearfix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符优先级]]></title>
    <url>%2Fblob%2F2019-01-04-operator-priority%2F</url>
    <content type="text"><![CDATA[首先是从一道 面试题 引发的思考 123456 var a = &#123;n: 1&#125;var b = a;a.x = a = &#123;n: 2&#125;console.log(a.x); // undefinedconsole.log(b.x); // &#123;n: 2&#125; 各种解释 MDN 知乎 试着去读如下代码 a&gt;b?a--:--a+b&gt;b+c?a==b&lt;c||a==c:(a+b)*a c=3 执行前a 执行前b 执行结果 执行后a 执行后b 2 6 7 1 6 6 2 6 5 2 0 6 -5 -1 6 优先级大小依次降低：()、–、*、+、&lt;、==、||、? : 运算符AST分析 分析地址1 分析地址2 分析这段代码a || b &amp;&amp; c || d Created with Raphaël 2.1.0ProgramExpressionStatementLogicalExpressionoperator: ||LogicalExpressionoperator: ||Identifiername: aLogicalExpressionoperator: &amp;&amp;Identifiername: bIdentifiername: cIdentifiername: d || 与 &amp;&amp; 的短路求值语义，如果左操作数已经足以求出结果则不会对右操作数求值。 常用操作符优先级 逗号、赋值、条件、逻辑或、逻辑与、相等、比较、算术、前置递减、后置递减、成员访问、小括号]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>运算符</tag>
        <tag>优先级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件的兼容写法]]></title>
    <url>%2Fblob%2F2019-01-04-compatible-writing-of-events%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324 const on = (function() &#123; if (document.addEventListener) &#123; return function(element, event, handler) &#123; element &amp;&amp; event &amp;&amp; handler &amp;&amp; element.addEventListener(event, handler, false); &#125;; &#125; else &#123; return function(element, event, handler) &#123; element &amp;&amp; event &amp;&amp; handler &amp;&amp; element.attachEvent('on' + event, handler); &#125;; &#125;&#125;)();const off = (function() &#123; if (document.removeEventListener) &#123; return function(element, event, handler) &#123; element &amp;&amp; event &amp;&amp; element.removeEventListener(event, handler, false); &#125;; &#125; else &#123; return function(element, event, handler) &#123; element &amp;&amp; event &amp;&amp; element.detachEvent('on' + event, handler); &#125;; &#125;&#125;)();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数作用域（示例）]]></title>
    <url>%2Fblob%2F2019-01-04-function-scopes-(examples)%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829 function EE()&#123;console.log(this)&#125;EE(); // 全局作用域new EE(); // 局部作用域function FF()&#123;return function()&#123;console.log(this)&#125;&#125;FF()(); // 全局作用域new FF()(); // 全局作用域function GG()&#123;return &#123;a: function()&#123;console.log(this)&#125;&#125;&#125;GG().a(); // 局部作用域new GG().a(); // 局部作用域var hh = &#123; a: function()&#123;console.log(this);&#125;, ee0: function()&#123;EE();&#125;, ee: function()&#123;new EE();&#125;, ff0: function()&#123;FF()();&#125;, ff: function()&#123;new FF()();&#125;, ff1: FF(), gg: function()&#123;new GG().a()&#125;&#125;;hh.a(); // hh的局部作用域hh.ee0(); // 全局作用域hh.ee(); // ee的局部作用域hh.ff0(); // 全局作用域hh.ff(); // 全局作用域hh.ff1(); // hh的局部作用域 --- 从此解开谜底hh.gg(); // GG的局部作用域]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建一个长度为10的数组]]></title>
    <url>%2Fblob%2F2019-01-04-create-an-array-of-10-lengths%2F</url>
    <content type="text"><![CDATA[创建一个长度为10的数组，并且每一个元素是该元素的下标 最简单方法 for循环 123456789 function arrayCreate(length)&#123; let arr = []; for(let i = 0 ; i &lt; length ; i++)&#123; arr[i] = i; &#125; return arr;&#125;let a1 = arrayCreate(10); Array.prototype.from() 方法从一个类数组或可迭代对象中创建一个新的数组示例。 Array(10) 创建一个只有长度的数组，这时候不能使用map方法，可以使用fill方法。 new Array(10) 同 Array(10)。 {length: 10} 类数组对象，且这是一个无值的对象。 Array.apply 实际使用的是Function.prototype.apply；第二个参数正常是一个数组，如果是类数组对象，就作为一个数组去处理。 Array.prototype.fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。 Array.prototype.keys() 方法返回一个新的Array迭代器，包含数组中每个索引的键。 ... 扩展运算符 Object.keys() 方法返回由一个给定对象的自身可枚举属性组成的数组 1234567891011121314151617181920212223242526 Array.from(&#123;length: 10&#125;, (v, k) =&gt; k);Array.from(Array(10).keys());Array.from(new Array(10).keys());Array.from(Array.apply(null, Array(10)).keys());Array.from(Array.apply(null, &#123;length: 10&#125;).keys());Array.from(Array(10).fill(1).keys());Array.from(Array.from(&#123;length: 10&#125;).keys());[...Array(10).keys()];[...new Array(10).keys()];[...Array.apply(null, Array(10)).keys()];[...Array.apply(null, &#123;length: 10&#125;).keys()];[...Array(10).fill(1).keys()];[...Array.from(&#123;length: 10&#125;).keys()];Object.keys(Array.apply(null, &#123;length:10&#125;)).map(key =&gt; +key);Object.keys(Array.from(&#123;length:10&#125;)).map(key =&gt; +key);Object.keys(String(Array(11))).map(key =&gt; +key);new Array(10).toString().split(",").map((v, i) =&gt; i);"".padStart(9, "-").split("-").map((v,k)=&gt;k);"".padEnd(9, "-").split("-").map((v,k)=&gt;k);"-".repeat("9").split("-").map((v,k)=&gt;k);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>创建数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取url参数并保存为对象]]></title>
    <url>%2Fblob%2F2019-01-04-get-url-parameters-and-save-them-as-objects%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920 /** * 循环匹配一个?或者&amp; * 接着至少匹配一个非?或者非&amp; * 接着一个等号 * 接着至少匹配一个非?或者非&amp; * * 循环匹配后将key和value保存到一个对象中并返回，也可以保存在Map中 */function getQueryString(url)&#123; let params = &#123;&#125;; url.replace(/[\?\&amp;]([^\?\&amp;]+)=([^\?\&amp;]+)/g, function($0, $1, $2, $3)&#123; console.log($0, $1, $2) params[$1] = $2; &#125;); return params;&#125;// rungetQueryString("http://www.rongyi.com?a=1&amp;b=2&amp;c"); out 1 &#123;a: "1", b: "2"&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>url</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多选与二进制数的互转]]></title>
    <url>%2Fblob%2F2019-01-04-mutual-selection-and-binary-number-conversion%2F</url>
    <content type="text"><![CDATA[[TOC] 任意一个正整数转换成几个正整数 转换后所有正整数相加的和等于这个正整数 123456789101112131415161718192021222324252627282930 /** * 转换为数组 * 如下： * 0 =&gt; [0] * 1 =&gt; [1] * 2 =&gt; [0, 2] * 3 =&gt; [1, 2] * 4 =&gt; [0, 0, 4] * 5 =&gt; [1, 0, 4] * 6 =&gt; [0, 2, 4] * * @param &#123;Integer&#125; num 数字 * @param &#123;Integer&#125; length 最小长度 * @param &#123;Integer&#125; defaultValue 默认值 * @return &#123;Array&#125; */function toArray(data, length = 0, defaultValue = 0)&#123; if(!data) return; const arr = Array.from(Array(length)).map(item =&gt; defaultValue); let temp = data.toString(2); cosnt l = temp.length; for (let i = 0; i &lt; l; i++) &#123; arr[l - i -1] = (temp.charAt(i) == "1") ? Math.pow(2, l - i - 1) : 0 &#125; return arr;&#125; 几个数相加产生一个不会重复的数 这几个数是2的n次方和0，n为自然数，任意几个数相加的和不在数列内 1234567891011121314151617181920 /** * 转化为数字 * 如下： * [0] =&gt; 0 * [1] =&gt; 1 * [0, 2] =&gt; 2 * [1, 2] =&gt; 3 * [0, 0, 4] =&gt; 4 * * @param &#123;Array&#125; arr * @return &#123;Integer&#125; 和 */function toNum(arr)&#123; if(!arr || arr.length &lt; 1) return 0; var temp = 0; for(var i in arr)&#123; temp += parseInt(arr[i]); &#125; return temp;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>对选</tag>
        <tag>二进制表示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象常用操作]]></title>
    <url>%2Fblob%2F2019-01-03-common-object-operations%2F</url>
    <content type="text"><![CDATA[删除对象属性 123 function deleteProperty(obj, key)&#123; obj.propertyIsEnumerable(key) &amp;&amp; (delete obj[key])&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现水平居中、垂直居中的几种方式]]></title>
    <url>%2Fblob%2F2018-12-26-several-ways-of-realizing-horizontal-and-vertical-centralization-in-css%2F</url>
    <content type="text"><![CDATA[划重点，这是一道面试必考题，很多面试官都喜欢问这个问题，我就被问过好几次了 要实现上图的效果看似很简单，实则暗藏玄机，本文总结了一下CSS实现水平垂直居中的方式大概有下面这些，本文将逐一介绍一下，原作者将本文整理成了一个github仓库，欢迎大家star 仅居中元素定宽高适用 absolute + 负margin absolute + margin auto absolute + calc 居中元素不定宽高 absolute + transform lineheight writing-mode table css-table flex grid absolute + 负margin 为了实现上面的效果先来做些准备工作，假设HTML代码如下，总共两个元素，父元素和子元素 123 &lt;div class="wp"&gt; &lt;div class="box size"&gt;123123&lt;/div&gt;&lt;/div&gt; wp是父元素的类名，box是子元素的类名，因为有定宽和不定宽的区别，size用来表示指定宽度，下面是所有效果都要用到的公共代码，主要是设置颜色和宽高 注意：后面不在重复这段公共代码，只会给出相应提示 12345678910111213141516 /* 公共代码 */.wp &#123; border: 1px solid red; width: 300px; height: 300px;&#125;.box &#123; background: green; &#125;.box.size&#123; width: 100px; height: 100px;&#125;/* 公共代码 */ 绝对定位的百分比是相对于父元素的宽高，通过这个特性可以让子元素的居中显示，但绝对定位是基于子元素的左上角，期望的效果是子元素的中心居中显示 为了修正这个问题，可以借助外边距的负值，负的外边距可以让元素向相反方向定位，通过指定子元素的外边距为子元素宽度一半的负值，就可以让子元素居中了，css代码如下 1234567891011121314 /* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; position: relative;&#125;.box &#123; position: absolute;; top: 50%; left: 50%; margin-left: -50px; margin-top: -50px;&#125; 这是我比较常用的方式，这种方式比较好理解，兼容性也很好，缺点是需要知道子元素的宽高 点击查看完整DEMO absolute + margin auto 这种方式也要求居中元素的宽高必须固定，HTML代码如下 123 &lt;div class="wp"&gt; &lt;div class="box size"&gt;123123&lt;/div&gt;&lt;/div&gt; 这种方式通过设置各个方向的距离都是0，此时再讲margin设为auto，就可以在各个方向上居中了 123456789101112131415 /* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; position: relative;&#125;.box &#123; position: absolute;; top: 0; left: 0; right: 0; bottom: 0; margin: auto;&#125; 这种方法兼容性也很好，缺点是需要知道子元素的宽高 点击查看完整DEMO 网友补充原理： 绝对定位元素可以在其包含块内上下左右移动，指定其距离包含块上下左右的距离都为零时，子元素将填充其包含块所有的可用空间，所以 margin 在水平和垂直方向上都有了可分配的空间，此时使用自动外边距就可使子元素居中 absolute + calc 这种方式也要求居中元素的宽高必须固定，所以我们为box增加size类，HTML代码如下 123 &lt;div class="wp"&gt; &lt;div class="box size"&gt;123123&lt;/div&gt;&lt;/div&gt; 感谢css3带来了计算属性，既然top的百分比是基于元素的左上角，那么在减去宽度的一半就好了，代码如下 123456789101112 /* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; position: relative;&#125;.box &#123; position: absolute;; top: calc(50% - 50px); left: calc(50% - 50px);&#125; 这种方法兼容性依赖calc的兼容性，缺点是需要知道子元素的宽高 点击查看完整DEMO absolute + transform 还是绝对定位，但这个方法不需要子元素固定宽高，所以不再需要size类了，HTML代码如下 123 &lt;div class="wp"&gt; &lt;div class="box"&gt;123123&lt;/div&gt;&lt;/div&gt; 修复绝对定位的问题，还可以使用css3新增的transform，transform的translate属性也可以设置百分比，其是相对于自身的宽和高，所以可以将translate设置为-50%，就可以做到居中了，代码如下 12345678910111213 /* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; position: relative;&#125;.box &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 这种方法兼容性依赖translate2d的兼容性 点击查看完整DEMO lineheight 利用行内元素居中属性也可以做到水平垂直居中，HTML代码如下 123 &lt;div class="wp"&gt; &lt;div class="box"&gt;123123&lt;/div&gt;&lt;/div&gt; 把box设置为行内元素，通过text-align就可以做到水平居中，但很多同学可能不知道通过通过vertical-align也可以在垂直方向做到居中，代码如下 12345678910111213141516 /* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; line-height: 300px; text-align: center; font-size: 0px;&#125;.box &#123; font-size: 16px; display: inline-block; vertical-align: middle; line-height: initial; text-align: left; /* 修正文字 */&#125; 这种方法需要在子元素中将文字显示重置为想要的效果，同时需要父元素的高度 点击查看完整DEMO writing-mode 很多同学一定和我一样不知道writing-mode属性，感谢@张鑫旭老师的反馈，简单来说writing-mode可以改变文字的显示方向，比如可以通过writing-mode让文字的显示变为垂直方向 12 &lt;div class="div1"&gt;水平方向&lt;/div&gt;&lt;div class="div2"&gt;垂直方向&lt;/div&gt; 123 .div2 &#123; writing-mode: vertical-lr;&#125; 显示效果如下： 12345 水平方向垂直方向 更神奇的是所有水平方向上的css属性，都会变为垂直方向上的属性，比如text-align，通过writing-mode和text-align就可以做到水平和垂直方向的居中了，只不过要稍微麻烦一点 12345 &lt;div class="wp"&gt; &lt;div class="wp-inner"&gt; &lt;div class="box"&gt;123123&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819 /* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; writing-mode: vertical-lr; text-align: center;&#125;.wp-inner &#123; writing-mode: horizontal-tb; display: inline-block; text-align: center; width: 100%;&#125;.box &#123; display: inline-block; margin: auto; text-align: left;&#125; 这种方法实现起来和理解起来都稍微有些复杂 点击查看完整DEMO table 曾经table被用来做页面布局，现在没人这么做了，但table也能够实现水平垂直居中，但是会增加很多冗余代码 123456789 &lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class="wp"&gt; &lt;div class="box"&gt;123123&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; tabel单元格中的内容天然就是垂直居中的，只要添加一个水平居中属性就好了 123456 .wp &#123; text-align: center;&#125;.box &#123; display: inline-block;&#125; 这种方法就是代码太冗余，而且也不是table的正确用法 点击查看完整DEMO css-table css新增的table属性，可以让我们把普通元素，变为table元素的现实效果，通过这个特性也可以实现水平垂直居中 123 &lt;div class="wp"&gt; &lt;div class="box"&gt;123123&lt;/div&gt;&lt;/div&gt; 下面通过css属性，可以让div显示的和table一样 12345678 .wp &#123; display: table-cell; text-align: center; vertical-align: middle;&#125;.box &#123; display: inline-block;&#125; 这种方法和table一样的原理，但却没有那么多冗余代码，兼容性也还不错 点击查看完整DEMO flex flex作为现代的布局方案，颠覆了过去的经验，只需几行代码就可以优雅的做到水平垂直居中 123 &lt;div class="wp"&gt; &lt;div class="box"&gt;123123&lt;/div&gt;&lt;/div&gt; 12345 .wp &#123; display: flex; justify-content: center; align-items: center;&#125; 目前在移动端已经完全可以使用flex了，PC端需要看自己业务的兼容性情况 点击查看完整DEMO grid 感谢@一丝姐 反馈的这个方案，css新出的网格布局，由于兼容性不太好，一直没太关注，通过grid也可以实现水平垂直居中 123 &lt;div class="wp"&gt; &lt;div class="box"&gt;123123&lt;/div&gt;&lt;/div&gt; 1234567 .wp &#123; display: grid;&#125;.box &#123; align-self: center; justify-self: center;&#125; 代码量也很少，但兼容性不如flex，不推荐使用 点击查看完整DEMO 总结 下面对比下各个方式的优缺点，肯定又双叒叕该有同学说回字的写法了，简单总结下 PC端有兼容性要求，宽高固定，推荐absolute + 负margin PC端有兼容要求，宽高不固定，推荐css-table PC端无兼容性要求，推荐flex 移动端推荐使用flex 小贴士 ：关于flex的兼容性决方案，请看这里《移动端flex布局实战》 Tables Are Cool col 3 is right-aligned $1600 方法 居中元素定宽高固定 PC兼容性 移动端兼容性 absolute + 负margin 是 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ absolute + margin auto 是 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ absolute + calc 是 ie9+, chrome19+, firefox4+ 安卓4.4+, iOS6+ absolute + transform 否 ie9+, chrome4+, firefox3.5+ 安卓3+, iOS6+ writing-mode 否 ie6+, chrome4+, firefox3.5+ 安卓2.3+, iOS5.1+ lineheight 否 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ table 否 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ css-table 否 ie8+, chrome4+, firefox2+ 安卓2.3+, iOS6+ flex 否 ie10+, chrome4+, firefox2+ 安卓2.3+, iOS6+ grid 否 ie10+, chrome57+, firefox52+ 安卓6+, iOS10.3+ 最近发现很多同学都对css不够重视，这其实是不正确的，比如下面的这么简单的问题都有那么多同学不会，我也是很无语 12 &lt;div class="red blue"&gt;123&lt;/div&gt;&lt;div class="blue red"&gt;123&lt;/div&gt; 1234567 .red &#123; color: red&#125;.blue &#123; color: blue&#125; 问两个div的颜色分别是什么，竟然只有40%的同学能够答对，这40%中还有很多同学不知道为什么，希望这些同学好好补习下CSS基础，下面给大家推荐几本CSS的书籍 CSS设计指南（最好的入门书）图解CSS3（最好的CSS3入门） CSS世界（CSS进阶）CSS揭秘（CSS高手）喜欢看网络资料同学，可以看看MDN的这个 CSS入门教程，强烈推荐，英语好的同学建议看英文版 原文网址：https://yanhaijing.com/css/2018/01/17/horizontal-vertical-center/]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序跳转其他小程序]]></title>
    <url>%2Fblob%2F2018-12-25-wechat-applet-jumps-to-other-applets%2F</url>
    <content type="text"><![CDATA[老年模式 https://developers.weixin.qq.com/miniprogram/dev/api/open-api/miniprogram-navigate/wx.navigateToMiniProgram.html 1234567891011 wx.navigateToMiniProgram(&#123; appId: '', path: 'page/index/index?id=123', extraData: &#123; foo: 'bar' &#125;, envVersion: 'develop', success(res) &#123; // 打开成功 &#125;&#125;) 新模式 https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html采用miniProgram模式 12345678 &lt;navigator target="miniProgram" app-id="wx9a52d3a2384642f6" path="page/index/index?id=123" extra-data="&#123;&#123;extraData&#125;&#125;" version="develop" &gt; 打开小程序&lt;/navigator&gt; 123 extraData: &#123; name: 123&#125; 同时要添加跳转声明https://developers.weixin.qq.com/miniprogram/dev/framework/config.html 123 "navigateToMiniProgramAppIdList": [ "wx9a52d3a2384642f6"] 跳转后参数目标小程序可在 App.onLaunch()，App.onShow() 中获取到这份数据。详情 12345678910111213 &#123; path: "page/index/index", query: &#123; id: "123" &#125;, referrerInfo: &#123; appId: "wxac75bf66ed9c6321", // 来源小程序的appid extraData: &#123; name: 123 &#125; &#125;, scene: 1037&#125; 1037 小程序打开小程序1038 从另一个小程序返回 什么条件可以跳转 小程序是不是同一主体，有没有绑定同一微信公众号，都可以跳转]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>跳转其他小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 实用站点]]></title>
    <url>%2Fblob%2F2018-12-24-git-utility-site%2F</url>
    <content type="text"><![CDATA[官方文档：https://git-scm.com/docs/git 官方文档中文版：https://git-scm.com/book/zh/v2 progit2-gitbook：https://github.com/bingohuang/progit2-gitbook 脚本 GitHub：https://git-scm.com/book/zh/v2/GitHub-%E8%84%9A%E6%9C%AC-GitHub 脚本 GitHub 服务与钩子配置区域：https://developer.github.com/webhooks/ 高质量的Git中文教程：https://github.com/geeeeeeeeek/git-recipes]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>progit</tag>
        <tag>webhooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[button 点击后失去获得的焦点]]></title>
    <url>%2Fblob%2F2018-12-20-lost-focus-after-button-click%2F</url>
    <content type="text"><![CDATA[浏览器默认元素button在鼠标点击后会获得焦点，这时点击键盘就会响应按钮的点击事件。 某些情况下希望禁止响应点击事件的 可以通过点击后主动失去焦点来达到效果 123456789101112 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt; function clickHandler(e)&#123; // 获取当前绑定元素并取消焦点 e.currentTarget.blur(); &#125;&lt;/script&gt;&lt;button onclick="clickHandler(event)"&gt;不会留下痕迹&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>JavaScript</tag>
        <tag>button</tag>
        <tag>焦点</tag>
        <tag>失去焦点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[host 在实际项目中的使用]]></title>
    <url>%2Fblob%2F2018-12-17-the-use-of-host-in-practical-projects%2F</url>
    <content type="text"><![CDATA[今天体会到了实践出真知，回过头来看发现已经有了成熟的案例，大家都在使用，在这里记录我自己下体验。 不对等环境的联调过程 引子 对接外部系统微信、支付宝的支付通道，因为对方只能在线上环境测试且对方不将我方测试域名加入对方线上白名单中，导致我方在测试环境中使用对方线上数据环境测试不能完美进行下去。 因为微信支付宝的实现方式不同，故先解决微信支付的问题。 服务器端配置修改 首先考虑对方只能使用线上域名，故寻求运维，只要进入我方网络该域名转发到测试环境，失败。 因为项目使用的smarty3，且转发的域名使用的配置，在开始修改之前修改代码配置为线上域名。 然后整合我手上掌握的资源，前端服务器（代码+nginx），因完全使用线上域名，故肯定不能请求到测试服务器，失败。 只能考虑使用本机配置host，遂行之，然败矣；验证使用ip直接访问，仍失败，然后在nginx server name 中添加 该ip，访问成功。喜。 接下来使用域名访问还是失败，继续在nginx server name 中添加该域名，访问成功；到此服务器端的配置完成 本机修改 本机除了上面配置的host，还需要如下调整。 因为最终还是需要在手机上配置，所以要想办法把手机的请求转发给服务器，只能使用电脑拦截然后转发到服务器。 拦截使用fiddler代理，拦截手机上的请求。且测试环境smarty日志有输出，成功。 到此使用的工具都调试好了。但是微信还是不能访问成功，因为手机挂代理的时候微信网页授权不能访问（具体原因不明）；这时只能通过先去掉代理，然后手动取得想要的数据，拼接一个线上域名的url；在手机挂代理的情况下访问该地址，有效。 后面就是微信支付成功了。 但是原本功能完好的微信初始化功能、微信扫二维码加备注功能，都因为不能正确执行到wx.ready方法导致页面不能正确显示，故把对应代码注销掉才可以执行。回归测试使用恢复的代码分支原有功能又没有问题，故归结为代理导致的问题。 支付宝的支付 因为有了微信的案例，所以支付宝使用同样的方法进行测试。 百般使用后发现，支付宝里面打开的页面根本不被拦截到，使用了iphone和android都不会被拦截到； 怀疑是自己电脑问题，又换了一台电脑使用fiddler拦截，还是不可以； 咨询了在阿里的同学，也是啥都不知道；建议我配置手机host，找了一块android设备，修改之后不生效，放弃； 最终还是使用查找参数，手动拼接url的方式，而且是测试环境地址，就不需要挂代理。 一直想让程序自动跑不需要人工干预的方式，由于缺少相关经验，浪费不少时间。 不对等环境联调总结 因为开发环境的需要，需要对本机进行管理，如果是手机联调还需要配置代理。。。。 如果测试环境有nginx且有server name，需要在此将生产域名添加进来 修改代码中授权回调地址为生产地址 修改本机host，添加线上域名到测试环境ip的host转发 配置fiddler拦截器 修改手机代理地址 如果出现像微信网页授权在手机配置代理后不能访问的情况，需要手动拼接后续url。 记得要还原手机代理、本机host、修改的代码、nginx配置。 使用工具管理host 推荐使用 SwitchHosts 管理工具 这是一个用于快速切换 hosts 文件的小程序，基于 Electron 开发，同时使用了 React、Ant Design 以及 CodeMirror 等框架/库。 功能特性 快速切换 hosts hosts 文件语法高亮 在线 hosts 方案：适用于多人协作，将host文件放置在网络上供他人使用 系统托盘图标快速切换 macOS: 支持 Alfred workflow 快速切换 工具管理host注意事项 1、运行时要以管理员方式运行，不然会提示无修改权限。在SwitchHosts.exe右键—以管理员身份运行2、如果是绿色单文件版，最好是放在一个文件夹里面再运行，因为会exe所在的目录下生成配置文件和其他文件夹。3、如果双击运行后不能显示SwitchHost界面，但是任务管理器里面能看到SwitchHost的进程，一般是由于hosts文件字符集不统一，导致hosts文件出现乱码，不能被SwitchHost打开，这时候只要删除C:\windows\system32\drivers\etc\hosts 即可。4、如果使用了代理，修改 Hosts 也不会生效。因为浏览器会优先考虑代理工具的代理，建议调试的时候先关闭代理。5、修改了hosts不生效，一般需要重启浏览器，如果是google浏览器可以不用重启，可以借助chrome://net-internals/#dns chrome://net-internals/#sockets 清掉keep-alive 和清浏览器 DNS 缓存。 调试中使用的工具 代理工具 Fiddler4 以及 Charles，其中Fiddler4 可以安装在 Windows上，Charles安装在Mac上。 Android 调试工具 Android 使用adb远程控制，但是需要root权限]]></content>
      <categories>
        <category>Host</category>
      </categories>
      <tags>
        <tag>Host</tag>
        <tag>Hosts</tag>
        <tag>代理</tag>
        <tag>转发</tag>
        <tag>SwitchHosts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[host 文件修改与刷新]]></title>
    <url>%2Fblob%2F2018-12-17-modification-and-refresh-of-host-file%2F</url>
    <content type="text"><![CDATA[window环境： hosts文件位置：C:\windows\system32\drivers\etc\hosts 刷新方式： ctrl+r，输入CMD，回车 在命令行执行:ipconfig /flushdns #清除DNS缓存内容。ps:ipconfig /displaydns //显示DNS缓存内容 在window下修改需要管理员权限才可以修改 linux环境 文件位置：/etc/hosts 刷新命令：systemctl restart nscd 作者：jiahao1186来源：CSDN原文：https://blog.csdn.net/jiahao1186/article/details/83011458版权声明：本文为博主原创文章，转载请附上博文链接！ Mac 修改权限 Mac OSX 系统hosts文件的路径。 在Finder中同时按“Shift”“Command”“G”三个键，输入“/etc/hosts”。 更改权限。 右击hosts文件，选择“显示简介”，在“共享与权限”中勾选“读与写权限”。 打开hosts文件。 获取读写权限的hosts已经可以保存修改了。 未获取读写权限的hosts文件无法保存任何修改 使用注意事项： 运行时要以管理员方式运行，不然会提示无修改权限。 如果使用了代理，修改 Hosts 也不会生效。因为浏览器会优先考虑代理工具的代理，建议调试的时候先关闭代理。 修改了hosts不生效，一般需要重启浏览器，如果是google浏览器可以不用重启，可以借助chrome://net-internals/#dns chrome://net-internals/#sockets 清掉keep-alive 和清浏览器 DNS 缓存。 划重点了 在使用完host之后一定要关闭，否则后果自负，切记切记!!! 浏览器Host缓存 和前端相关的前端工程师，后端工程师，产品，测试都有被浏览器的Host缓存折磨疯的经历吧，不停的刷新页面，重启浏览器，开无痕模式，是不是都被我戳中了。这里先提供一些小技巧，然后再推荐一个 Chrome插件，来完美的解决浏览器 Host缓存问题。 小技巧一 按照下图操作即可在控制台查看IP。 小技巧二 又一个简单的查看IP的方法： 小技巧三 这个很装逼，也很强大。分两步不仅可以查看IP还可以清理缓存。Chrome 访问地址：chrome://net-internals/#dns，点击图片上的 clear Host cache 按钮即可清空Host缓存。但是不要着急，还有第二步，只点击这个还是会有问题。 第二步：点击图片左侧篮框的链接，然后点击右侧上方的Flush socket pools按钮。 为什么需要两步呢，应该是第一步是清理Host缓存，第二步是清理掉使用之前缓存创建的 socket 链接，然后再刷新页面就会利用新的 Host 来创建 socket 达到了我们的目的。 小技巧四 为了使页面更快的呈现给用户，也有很多服务器端的，成本的考量，静态资源会缓存在浏览器本地，就是说有一些前端资源压根不向后端发送请求，对于这类资源有一个特征，如下图： 对于这种切Host也没用，但是还是有简单的办法的。打开开发者工具后，然后在刷新按钮上右键就会出现三个选项，这个时候选择第二个或者第三个都可以清理掉这些静态资源的缓存。 小技巧五 本人之前一直使用小技巧三来提升效率并且装逼，但是每次都要打开地址，然后还得切换个页面再点一次还是很麻烦。所以在再推荐一个 Chrome 插件。 重要 重要 重要！安装插件后需要对浏览器做一个配置才可以正常使用，访问网址：chrome://flags/#extensions-on-chrome-urls 然后点击启用，具体如下图： 点击右上角的插件Logo即可完成技巧三的操作，清理Host缓存： 如下图右键即可显示当前页面的IP：]]></content>
      <categories>
        <category>Host</category>
      </categories>
      <tags>
        <tag>Host</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler 痛点]]></title>
    <url>%2Fblob%2F2018-12-14-fiddler-pain-spot%2F</url>
    <content type="text"><![CDATA[电脑可以上网浏览器不能上网 今天遇到可以ping通百度，但是所有的浏览器都不能上网的情况； 联想到看到过的说明如果电脑异常关机时fiddler没有关闭，代理在重新开机之后没有从系统中移除，这时只需要重新启动fiddler就完美解决；]]></content>
      <categories>
        <category>Fiddler</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Fiddler</tag>
        <tag>痛点</tag>
        <tag>浏览器不能上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT reflog 恢复已删除分支]]></title>
    <url>%2Fblob%2F2018-12-13-git-reflog-restores-deleted-branches%2F</url>
    <content type="text"><![CDATA[语法： git reflog –date=[iso | local | relative] | grep [-w 全词匹配] iso:格式化后的时间时间 local:实际时间 relative：相对时间， 多少天之前 本案例以恢复remove_branch为例 对remove_branch分支操作。 合并develop分支到remove_branch， 在remove_branch分支做了两次commit， 离开remove_branch分支最终删除该分支。 其活动历时 如图： git reflog 会记录所有的HEAD变动记录， 如commit， 分支切换信息。 通过查询最后一次进入分支remove_branch，最后一次离开remove_branch分支这段时间内head的变化来恢复分支。 由图可知remove_branch分支最后一次进入，离开的时间段为2018-07-20 10:06:39 到2018-07-20 10:09:14 搜索这个时间段内的所有记录， 找到最近一次commit的记录 复制第一列的commit id 还原删除分支 从最近一次commit 中检出分支，可重命名，本例chon重命名为：reback_remove_branch git checkout -b reback_remove_branch ddd94a4 作者：changerzhuo来源：CSDN原文：https://blog.csdn.net/changerzhuo_319/article/details/81133533版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>恢复删除分支</tag>
        <tag>删除分支</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序]]></title>
    <url>%2Fblob%2F2018-11-16-wechat-applet%2F</url>
    <content type="text"><![CDATA[导读 微信小程序接入指南小程序开发版本分布]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程插件开发合集]]></title>
    <url>%2Fblob%2F2018-11-16-development-collection-of-wechat-small-procedure-plug-ins%2F</url>
    <content type="text"><![CDATA[版本支持 插件从小程序基础库版本 2.1.0 开始支持页面。 自基础库版本 2.2.2 开始，在插件自身的页面中，插件还可以调用 wx.navigateTo 来进行页面跳转， url 格式与使用 navigator 组件时相仿。 从小程序基础库版本 2.4.0 开始，支持插件所有者小程序跳转到自己的功能页。 导读 首先看几个学习地址，用于方便理解小程序插件的能力。 查找小程序插件 ：官方插件查找地址，截止2018-11-16还不到两页的插件。 小程序插件功能介绍 ：主要用于理解小程序插件的定位和功能。个人类型小程序不能申请，其他类型都可以申请插件功能，一个小程序只能提供一个插件，其他小程序可以申请使用小程序， 小程序插件开发：开发教程。 开始开发 开发插件 创建项目要在代码片段中的新建，选择插件。 开发注意事项 插件请求签名 插件在使用 wx.request 等 API 发送网络请求时，将会额外携带一个签名 HostSign ，用于验证请求来源于小程序插件。这个签名位于请求头中，形如： 1 X-WECHAT-HOSTSIGN: &#123;&quot;noncestr&quot;:&quot;NONCESTR&quot;, &quot;timestamp&quot;:&quot;TIMESTAMP&quot;, &quot;signature&quot;:&quot;SIGNATURE&quot;&#125; 其中， NONCESTR 是一个随机字符串， TIMESTAMP 是生成这个随机字符串和 SIGNATURE 的 UNIX 时间戳。它们是用于计算签名 SIGNATRUE 的参数，签名算法为： 1 SIGNATURE = sha1([APPID, NONCESTR, TIMESTAMP, TOKEN].sort().join(&apos;&apos;)) 插件内跳转 - 在插件页面内如果是导航组件，可以使用相对路径 - 插件执行页面跳转的时候，可以使用 navigator 组件。当插件跳转到自身页面时， url 应设置为这样的形式：plugin-private://PLUGIN_APPID/PATH/TO/PAGE 。需要跳转到其他插件时，也可以这样设置 url 。 - 自基础库版本 2.2.2 开始，在插件自身的页面中，插件还可以调用 wx.navigateTo 来进行页面跳转， url 格式与使用 navigator 组件时相仿。 插件开放配置 &gt; 向第三方小程序开放的所有自定义组件、页面和 js 接口都必须在插件配置文件 plugin.json 列出，格式如下： 123456789 &#123; &quot;publicComponents&quot;: &#123; &quot;hello-component&quot;: &quot;components/hello-component&quot; &#125;, &quot;pages&quot;: &#123; &quot;hello-page&quot;: &quot;pages/hello-page&quot; &#125;, &quot;main&quot;: &quot;index.js&quot;&#125; 插件的限制 插件调用 API 的限制 wx.login 和 wx.requestPayment 在插件中不能使用，但可以通过插件功能页来 获得用户信息 和 进行支付 插件使用组件的限制 在插件开发中，以下组件不能在插件页面中使用： 开放能力（open-type）为以下之一的 button： contact（打开客服会话） getPhoneNumber（获取用户手机号） getUserInfo（获取用户信息） open-data web-view 以下组件的使用对基础库版本有要求： navigator 需要基础库版本 2.1.0 live-player 和 live-pusher 需要基础库版本 2.3.0 插件的功能页 插件功能页 引用：要使用插件功能页，需要先激活功能页特性，配置对应的功能页函数，再使用 &lt;functional-page-navigator&gt; 组件跳转到插件功能页，从而实现对应的功能。 从小程序基础库版本 2.4.0 开始，支持插件所有者小程序跳转到自己的功能页。 注意使用 &lt;functional-page-navigator> 组件跳转到插件功能页的方式，仅在插件的自定义组件中有效，如果在插件页面跳转会在小程序控制台提示下图的错误 真机开发步骤 先预览打开插件所有者小程序 插件项目将插件中 &lt;functional-page-navigator&gt; 中的 version 属性设置为 develop 预览并打开插件 注意：上线前将插件中 &lt;functional-page-navigator&gt; 中的 version 属性设置为 release 用户信息功能页 自基础库版本 2.3.1 起，用户在这个功能页中授权之后，插件就可以直接调用 wx.login 和 wx.getUserInfo 。无需再次进入功能页获取用户信息。name=”loginAndGetUserInfo” 支付功能页 支付功能页插件使用支付功能，需要进行额外的权限申请，申请位置位于管理后台的“小程序插件 -&gt; 基本设置 -&gt; 支付能力”设置项中。name=”requestPayment” 收货地址功能页 自基础库版本 2.4.0 开始支持。name=”chooseAddress”]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>小程序自定义插件</tag>
        <tag>Npm支持</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程组件开发合集]]></title>
    <url>%2Fblob%2F2018-11-16-wechat-component-development-collection%2F</url>
    <content type="text"><![CDATA[版本支持 从小程序基础库版本 1.6.3 开始支持简洁的组件化编程 开发者工具 1.02.1810190 及以上版本支持全局组件 自基础库版本 2.0.9 开始，还可以在组件绑定数据中包含函数 :host 选择器需要包含基础库 1.7.2 或更高版本的开发者工具支持 外部样式类这个特性从小程序基础库版本 1.9.90 开始支持 全局样式类这个特性从小程序基础库版本 2.2.3 开始支持 从基础库 2.0.9 开始，对象类型的属性和 data 字段中可以包含函数类型的子字段 自小程序基础库版本 2.2.3 起，组件的的生命周期也可以在 lifetimes 字段内进行声明 resize(组件所在的页面尺寸变化，2.4.0开始支持) 抽象节点自小程序基础库版本 1.9.6 开始支持 自定义组件扩展从小程序基础库版本 2.2.3 开始支持。 小程序从基础库版本 2.2.1 、开发者工具从 1.02.1808300 开始支持使用 npm 安装第三方包 导读 首先看几个学习地址，用于方便理解小程序组件的能力。 自定义组件组件模板和样式Component构造器 组件npm开发 开发第三方自定义组件命令行工具小程序自定义组件脚手架 npm支持 自定义组件功能 组件模板 写法与页面模板相同 模板数据绑定 向子组件的属性传递动态数据 1234567 &lt;!-- 引用组件的页面模板 --&gt;&lt;view&gt; &lt;component-tag-name prop-a="&#123;&#123;dataFieldA&#125;&#125;" prop-b="&#123;&#123;dataFieldB&#125;&#125;"&gt; &lt;!-- 这部分内容将被放置在组件 &lt;slot&gt; 的位置上 --&gt; &lt;view&gt;这里是插入到组件slot中的内容&lt;/view&gt; &lt;/component-tag-name&gt;&lt;/view&gt; 注意 自基础库版本 2.0.9 开始，还可以在数据中包含函数 组件的slot 在组件模板中可以提供一个 &lt;slot&gt; 节点，用于承载组件引用时提供的子节点。 支持默认slot和具名slot 注意 slot是view组件的话，查看文档结构，slot的代码和组件代码是同级的 组件样式 不支持的写法 1234 #a &#123; &#125; /* ID选择器在组件中不能使用 */[a] &#123; &#125; /* 属性选择器在组件中不能使用 */button &#123; &#125; /* 标签名选择器在组件中不能使用 */.a &gt; .b &#123; &#125; /* 除非 .a 是 view 组件节点，否则不一定会生效 */ 外部样式类 在 Component 中用 externalClasses 定义段定义若干个外部样式类。这个特性从小程序基础库版本 1.9.90 开始支持 注意：在同一个节点上使用普通样式类和外部样式类时，两个类的优先级是未定义的，因此最好避免这种情况。 1234 /* 组件 custom-component.js */Component(&#123; externalClasses: ['my-class']&#125;) 12 &lt;!-- 组件 custom-component.wxml --&gt;&lt;custom-component class="my-class"&gt;这段文本的颜色由组件外的 class 决定&lt;/custom-component&gt; 全局样式类 如果希望组件外样式类能够完全影响组件内部，可以将组件构造器中的options.addGlobalClass字段置为true。这个特性从小程序基础库版本 2.2.3 开始支持. 组件构造器 在自定义组件的 js 文件中，需要使用 Component() 来注册组件，并提供组件的属性定义、内部数据和自定义方法。 使用 this.data 可以获取内部数据和属性值，但不要直接修改它们，应使用 setData 修改。 从基础库 2.0.9 开始，对象类型的属性和 data 字段中可以包含函数类型的子字段 组件事件 组件间的基本通信方式有以下几种。 WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）。具体在 组件模板和样式 章节中介绍。 事件：用于子组件向父组件传递数据，可以传递任意数据。 如果以上两种方式不足以满足需要，父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。 12345 &lt;!-- 监听事件 --&gt;&lt;!-- 当自定义组件触发“myevent”事件时，调用“onMyEvent”方法 --&gt;&lt;component-tag-name bindmyevent="onMyEvent" /&gt;&lt;!-- 或者可以写成 --&gt;&lt;component-tag-name bind:myevent="onMyEvent" /&gt; 123456 // 触发事件onTap: function()&#123; var myEventDetail = &#123;&#125; // detail对象，提供给事件监听函数 var myEventOption = &#123;&#125; // 触发事件的选项 this.triggerEvent('myevent', myEventDetail, myEventOption)&#125; 在写自定义form组件事件时，发送事件的数据detail对象使用{value: &#39;&#39;}格式，便于同监听原生form input事件时使用同一个input监听事件 12345 // 事件监听方法inputHandler(e) &#123; this.setData(&#123; [e.currentTarget.dataset.key]: e.detail.value, &#125;); 1234 // 自定义input组件发送事件inputHandler: function (event) &#123; this.triggerEvent('myinput', &#123; value: 123&#125;); &#125;, 1234 &lt;!-- 自定义组件绑定监听事件 --&gt;&lt;yii-input value="&#123;&#123;value&#125;&#125;" data-key="code" bind:myinput="inputHandler"/&gt;&lt;!-- 原生组件绑定监听事件 --&gt;&lt;input value="&#123;&#123;value&#125;&#125;" data-key="code" bindinput="inputHandler"&gt;&lt;/input&gt; 组件生命周期 最重要的生命周期是 created(组件实例刚刚被创建好时) attached(组件完全初始化完毕、进入页面节点树后) detached(在组件离开页面节点树后) ，包含一个组件实例生命流程的最主要时间点。 生命周期方法可以直接定义在 Component 构造器的第一级参数中。 自小程序基础库版本 2.2.3 起，组件的的生命周期也可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高）。如：attached、detached 在 behaviors 中也可以编写生命周期方法 组件所在页面的生命周期在 pageLifetimes 定义段中定义show(组件所在的页面被展示) hide(组件所在的页面被隐藏) resize(组件所在的页面尺寸变化，2.4.0开始支持) behaviors 用于组件间代码共享的特性，类似于一些编程语言中的“mixins”或“traits”。 每个组件可以引用多个 behavior 。 behavior 也可以引用其他 behavior 。 组件本身的属性或方法会覆盖 behavior 中的属性或方法，如果引用了多个 behavior ，在定义段中靠后 behavior 中的属性或方法会覆盖靠前的属性或方法； 如果有同名的数据字段，如果数据是对象类型，会进行对象合并，如果是非对象类型则会进行相互覆盖； 生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用。 内置 behaviors：wx://form-field wx://component-export 组件间关系 略 抽象节点 这个特性自小程序基础库版本 1.9.6 开始支持。 自定义组件模板中的一些节点，其对应的自定义组件不是由自定义组件本身确定的，而是自定义组件的调用者确定的。这时可以把这个节点声明为“抽象节点”。 节点的 generic 引用 generic:xxx=”yyy” 中，值 yyy 只能是静态值，不能包含数据绑定。不能动态决定。 自定义组件扩展 从小程序基础库版本 2.2.3 开始支持。 使用自定义组件 声明局部组件 在index.json中对自定义组进行引用声明 12345 &#123; "usingComponents": &#123; "component-tag-name": "path/to/the/custom/component" &#125;&#125; 在index.wxml中使用 1234 &lt;view&gt; &lt;!-- 以下是对一个自定义组件的引用 --&gt; &lt;component-tag-name inner-text="Some text"&gt;&lt;/component-tag-name&gt;&lt;/view&gt; 声明全局组件 在 app.json 中声明 usingComponents 字段，在此处声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。 注意 自定义组件也是可以引用自定义组件的 开发者工具 1.02.1810190 及以上版本支持声明全局组件 这里不多说了，只记录关键信息，详细情况查看官方文档自定义组件 开发第三方自定义组件 小程序从基础库版本 2.2.1 开始支持使用 npm 安装第三方包。 开发 初始化 可使用下载模板和命令行工具进行开发，推荐使用命令行开发，如果是已有项目则不需要。 初始化之后需要安装依赖，安装依赖的时候可能会安装失败，在登录npm账号之后会正常安装npm包。如果不行试试verdaccio。 12345678 # 安装命令行工具npm install -g @wechat-miniprogram/miniprogram-cli# 在指定目录初始化miniprogram init --type custom-component# npm 登录。可先跳过执行下面语句，不成功在回来执行npm login# 安装依赖npm install 命令行工具用法 项目模板用法 开发注意事项 为了方便开发执行命令npm run watch，默认会在包根目录下生成miniprogram_dev目录，src中的源代码会被构建并生成到miniprogram_dev/components目录下。/tools/demo下的内容也会复制到该目录下 内置支持多入口构建，如若需要可自行调整 tools/config.js 配置文件的 entry 字段。无论是js模块还是自定义组件都要配置 执行测试npm run test、检测覆盖率npm run coverage 发布使用命令npm run dist 测试工具文档 以下为推荐使用的目录结构，如果有必要开发者也可以自行做一些调整: 12345678910111213141516171819 |--miniprogram_dev // 开发环境构建目录|--miniprogram_dist // 生产环境构建目录|--src // 源码| |--common // 通用 js 模块| |--components // 通用自定义组件| |--images // 图片资源| |--wxml // 通用 wxml 模版资源| |--wxs // 通用 wxs 资源| |--wxss // 通用 wxss 资源| || |--xxx.js/xxx.wxml/xxx.json/xxx.wxss // 暴露的 js 模块/自定义组件入口文件||--test // 测试用例|--tools // 构建相关代码| |--demo // demo 小程序目录，开发环境下会被拷贝生成到 miniprogram_dev 目录中| |--test // 测试工具相关目录| |--config.js // 构建相关配置文件||--gulpfile.js 新加图片之后要重启服务 编写文档 包括但不限于版本说明、使用效果、使用方法、详细说明 发布 发布小程序 npm 包的约束 这里要发布的 npm 包是特指专为小程序定制的 npm 包（简称小程序 npm 包）。 在 package.json 文件中新增一个 miniprogram 字段来指定构建文件生成目录（默认为 miniprogram_dist 目录）。 小程序 npm 包里只有构建文件生成目录会被算入小程序包的占用空间。 等 发布其他 npm 包的约束 只支持纯 js 包，不支持自定义组件。 必须有入口文件，即需要保证 package.json 中的 main 字段是指向一个正确的入口，如果 package.json 中没有 main 字段，则以 npm 包根目录下的 index.js 作为入口文件。 测试、构建相关的依赖请放入 devDependencies 字段中避免被一起打包到小程序包中，这一点和小程序 npm 包的要求相同。 不支持依赖 c++ addon，不支持依赖 nodejs 的内置库： 小程序环境比较特殊，一些全局变量（如 window 对象）和构造器（如 Function 构造器）是无法使用的。 发布流程 如果还没有 npm 帐号，可以到 npm 官网注册一个 npm 帐号。 在本地登录 npm 帐号，在本地执行：npm adduser或者npm login 在已完成编写的 npm 包根目录下执行npm publish 使用 npm支持 在小程序中执行命令安装 npm 包： 1 npm install --save packageName 点击开发者工具中的菜单栏：工具 –&gt; 构建 npm 勾选“使用 npm 模块”选项： 构建完成后即可使用 npm 包。 js 中引入 npm 包： 12 const package = require(&apos;packageName&apos;)const packageOther = require(&apos;packageName/other&apos;) 使用 npm 包中的自定义组件： 123456 &#123; &quot;usingComponents&quot;: &#123; &quot;package&quot;: &quot;packageName&quot;, &quot;package-other&quot;: &quot;packageName/other&quot; &#125;&#125; 思考：这里有一个/other，为什么是这样的，难道因为默认找index组件？如果使用其他组件就要这样使用？ 官方自定义组件 slide-viewnavigation-barrecycle-view 官方扩展 computedsm-crypto]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>小程序自定义组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-代码合并Merge与Rebase的选择]]></title>
    <url>%2Fblob%2F2018-05-29-git-code-merge-and-rebase-selection%2F</url>
    <content type="text"><![CDATA[官方讲述merge 官方讲述rebase Git分支变基 社区翻译 概述 你要知道的第一件事是，git rebase 和git merge 做的事其实是一样的。它们都被设计来将一个分支的更改并入另一个分支，只不过方式有些不同。 想象一下，你刚创建了一个专门的分支开发新功能，然后团队中另一个成员在 master 分支上添加了新的提交。这就会造成提交历史被 fork 一份，用 Git 来协作的开发者应该都很清楚。 现在，如果 master 中新的提交和你的工作是相关的。为了将新的提交并入你的分支，你有两个选择：merge 或 rebase。 Merge 将 master 分支合并到 feature 分支最简单的办法就是用下面这些命令： 12 git checkout featuregit merge master 或者，你也可以把它们压缩在一行里。 1 git merge master feature feature 分支中新的合并提交（merge commit）将两个分支的历史连在了一起。你会得到下面这样的分支结构： Merge 好在它是一个安全的操作。现有的分支不会被更改，避免了 rebase 潜在的缺点（后面会说）。 另一方面，这同样意味着每次合并上游更改时 feature 分支都会引入一个外来的合并提交。如果 master 非常活跃的话，这或多或少会污染你的分支历史。虽然高级的 git log 选项可以减轻这个问题，但对于开发者来说，还是会增加理解项目历史的难度。 merge 前 merge 后 Rebase 作为 merge 的替代选择，你可以像下面这样将 feature 分支并入 master 分支： 12 git checkout featuregit rebase master 它会把整个 feature 分支移动到 master 分支的后面，有效地把所有 master 分支上新的提交并入过来。但是，rebase 为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。 rebase最大的好处是你的项目历史会非常整洁。首先，它不像 git merge 那样引入不必要的合并提交。其次，如上图所示，rebase 导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的 fork。这让你更容易使用 git log、git bisect 和 gitk 来查看项目历史。 不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了 rebase 黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase 不会有合并提交中附带的信息——你看不到 feature 分支中并入了上游的哪些更改。 Rebase 前 Rebase 后 Rebase 的黄金法则（有点懵懂） 当你理解 rebase 是什么的时候，最重要的就是什么时候 不能 用 rebase。git rebase 的黄金法则便是，绝不要在公共的分支上使用它。 比如说，如果你把 master 分支 rebase 到你的 feature 分支上会发生什么： 这次 rebase 将 master 分支上的所有提交都移到了 feature 分支后面。问题是它只发生在你的代码仓库中，其他所有的开发者还在原来的 master 上工作。因为 rebase 引起了新的提交，Git 会认为你的 master 分支和其他人的 master 已经分叉了。 同步两个 master 分支的唯一办法是把它们 merge 到一起，导致一个额外的合并提交和两堆包含同样更改的提交。不用说，这会让人非常困惑。 所以，在你运行 git rebase 之前，一定要问问你自己「有没有别人正在这个分支上工作？」。如果答案是肯定的，那么把你的爪子放回去，重新找到一个无害的方式（如 git revert）来提交你的更改。不然的话，你可以随心所欲地重写历史。 结合自己情况使用 在工作中使用git-flow工作流，开发中如果遇到代码合并使用rebase保持线性的提交历史， git-flow部分通过sourcetree带的git-flow插件自动完成 rebase 部分通常经过如下步骤 12345 git fetch origin # 更新你的远程仓库引用git pull --rebase orgin serverBranch # 衍合远程分支#处理冲突git add * # 添加修改后的文件git rebase --continue # 继续衍合 rebase 部分体现在sourcetree上经过如下步骤 获取 拉取（勾选用衍合代替合并） 处理冲突 暂存所有文件 再次点击拉取选择继续变基]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Merge</tag>
        <tag>Rebase</tag>
        <tag>代码合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-AoneFlow]]></title>
    <url>%2Fblob%2F2018-05-29-git-aoneflow%2F</url>
    <content type="text"><![CDATA[说到分支管理模式，我们最耳熟能详的莫过于 TrunkBased 和 GitFlow。 TrunkBased 模式 是持续集成思想所崇尚的工作方式，它由单个主干分支和许多发布分支组成，每个发布分支在特定版本的提交点上从主干创建出来，用来进行上线部署和 Hotfix。在 TrunkBased 模式中，没有显性的特性分支。当然实际上 Git 的分布式特征天生允许每个人有本地分支，TrunkBased 也并非排斥短期的特性分支存在，只不过在说这种模式的时候，大家通常都不会明确强调它罢了。 虽然近年来有许多不错的案例，但 TrunkBased 模式并没有一统天下。它的缺点比较明显，太多的团队同时工作在主干上，到发布的时候就可能出现灾难（尤其是多版本并行开发的情况）。弥补的措施是 FeatureToggle 以及频繁的集成和足够的测试覆盖，这对开发团队的能力提出了比较高的要求。目前 TrunkBased 模式主要用在不需要同时维护多个历史版本的 SaaS 型项目，特别是经过微服务改造的各种小型服务上。 TrunkBased 模式有两种常见演进版本。OneFlow 模式 参考了 TrunkBased 的许多思想，对操作流程做了更严格的定义，增加了 Hotfix 分支等内容。多主干模式（通常是双主干，固定的开发分支和固定的发布分支），算是 TrunkBased 采用固定发布分支的特例，在 提升团队的微服务落地能力 这篇文章里介绍过，不再赘述。 GitFlow 模式 是若干模式的集大成者，包含一个主干分支、一个开发分支、许多的特性分支、许多的发布分支和 Hotfix 分支，以及许多繁琐的合并规则。它有一个 Git 插件，不过早就没人维护了。由于对每个阶段的每项操作定义十分明确，它曾经是很多重视流程的企业眼里的香馍馍。但它使用起来并不是很容易，大量的合并冲突和对集成测试不友好也是它被诟病最多的地方。 对，还有 GithubFlow 模式，不过这种策略无非是在 TrunkBased 的基础上，增加了个人仓库和 Pull Request 合并代码的操作，与在同一个仓库里增加个人分支的做法类似，从实用的意义来说，它更合适分布式团队。GithubFlow 也有演进版本，例如强调了多环境部署和将仓库或分支与环境关联的 GitlabFlow 模式。 要么简单粗暴如 TrunkBased，要么繁琐复杂如 GitFlow。难到真没有其他选择了吗？ 另辟蹊径的 AoneFlow 在 AoneFlow 上你能看到许多其他分支模式的影子。它基本上兼顾了 TrunkBased 的“易于持续集成”和 GitFlow 的“易于管理需求”特点，同时规避掉 GitFlow 的那些繁文缛节。 看一下具体套路。AoneFlow 只使用三种分支类型：主干分支、特性分支、发布分支，以及三条基本规则。 规则一，开始工作前，从主干创建特性分支。 AoneFlow 的特性分支基本借鉴 GitFlow，没有什么特别之处。每当开始一件新的工作项（比如新的功能或是待解决的问题）的时候，从代表最新已发布版本的主干上创建一个通常以feature/前缀命名的特性分支，然后在这个分支上提交代码修改。也就是说，每个工作项（可以是一个人完成，或是多个人协作完成）对应一个特性分支，所有的修改都不允许直接提交到主干。 规则二，通过合并特性分支，形成发布分支。 AoneFlow 的发布分支设计十分巧妙，可谓整个体系的精髓。GitFlow 先将已经完成的特性分支合并回公共主线（即开发分支），然后从公共主线拉出发布分支。TrunkBased 同样是等所有需要的特性都在主干分支上开发完成，然后从主干分支的特定位置拉出发布分支。而 AoneFlow 的思路是，从主干上拉出一条新分支，将所有本次要集成或发布的特性分支依次合并过去，从而得到发布分支。发布分支通常以release/前缀命名。 这条规则很简单，不过实际的玩法就相当丰富了。 首先，发布分支的用途可以很灵活。基础玩法是将每条发布分支与具体的环境相对应，比如release/test分支对应部署测试环境，release/prod分支对应线上正式环境等等，并与流水线工具相结合，串联各个环境上的代码质量扫描和自动化测试关卡，将产出的部署包直接发布到相应环境上。进阶点的玩法是将一个发布分支对应多个环境，比如把灰度发布和正式发布串在一起，中间加上人工验收的步骤。高级的玩法呢，要是按迭代计划来关联特性分支，创建出以迭代演进的固定发布分支，再把一系列环境都串在这个发布分支的流水线上，就有点经典持续集成流水线的味道了。再或者做一个将所有特性分支都关联在一起的发布分支，专门用于对所有提交做集成测试，就玩出了 TrunkBased 的效果。当然，这些花哨的高级玩法是我臆想的，阿里的发布分支一般都还是比较中规中矩。 其次，发布分支的特性组成是动态的，调整起来特别容易。在一些市场瞬息万变的互联网企业，以及采用“敏捷运作”的乙方企业经常会遇到这种情况，已经完成就等待上线的需求，随时可能由于市场策略调整或者甲方的一个临时决定，其中某个功能忽然要求延迟发布或者干脆不要了。再或者是某个特性在上线前发现存在严重的开发问题，需要排除。按往常的做法，这时候就要来手工“剔代码”了，将已经合并到开发分支或者主干分支的相关提交一个个剔除出去，做过的同学都知道很麻烦。在 AoneFlow 的模式下，重建发布分支只是分分钟的事，将原本的发布分支删掉，从主干拉出新的同名发布分支，再把需要保留的各特性分支合并过来就搞定。这一系列动作能够在很大程度上实现自动化，而且不会在仓库留下一堆剔除代码的记录，干净无污染。 此外，发布分支之间是松耦合的，这样就可以有多个集成环境分别进行不同的特性组合的集成测试，也能方便的管理各个特性进入到不同环境上部署的时机。松耦合并不代表没有相关性，由于测试环境、集成环境、预发布环境、灰度环境和线上正式环境等发布流程通常是顺序进行的，在流程上可以要求只有通过前一环境验证的特性，才能传递到下一个环境做部署，形成漏斗形的特性发布流。阿里有统一平台来自动化完成特性组合在发布分支间的迁移，在下面讲工具的部分里会再介绍。 规则三，发布到线上正式环境后，合并相应的发布分支到主干，在主干添加标签，同时删除该发布分支关联的特性分支。 当一条发布分支上的流水线完成了一次线上正式环境的部署，就意味着相应的功能真正的发布了，此时应该将这条发布分支合并到主干。为了避免在代码仓库里堆积大量历史上的特性分支，还应该清理掉已经上线部分特性分支。与 GitFlow 相似，主干分支上的最新版本始终与线上版本一致，如果要回溯历史版本，只需在主干分支上找到相应的版本标签即可。 除了基本规则，还有一些实际操作中不成文的技巧。比如上线后的 Hotfix，正常的处理方法应该是，创建一条新的发布分支，对应线上环境（相当于 Hotfix 分支），同时为这个分支创建临时流水线，以保障必要的发布前检查和冒烟测试能够自动执行。但其实还有一种简便方法是，将线上正式环境对应的发布分支上关联的特性分支全部清退掉，在这个发布分支上直接进行修改，改完利用现成的流水线自动发布。如果非得修一个历史版本的 Bug 怎么办呢？那就老老实实的在主干分支找到版本标签位置，然后从那个位置创建 Hotfix 分支吧，不过由于阿里的产品大多是线上 SaaS 业务，这样的场景并不多见。正是这些简单的规则，组成了 AoneFlow 独树一帜的核心套路。 AoneFlow 中每一个看似简单的步骤都并非凭空臆造，而是经历大量产品团队反复磨砺后积累下来的经验。接下来，我会说说 AoneFlow 的技术门槛以及阿里内部的应对之道。 AoneFlow 的体验优化 谙熟武侠之道的人都懂得，掌握一个门派的看家武艺，除了要会招式，还得有深厚的内功和趁手的兵器。否则拿了辟邪剑谱，也只能望谱兴叹。 阿里团队的内功和兵器，实际上是良好的代码习惯和齐全的配套工具。 这里说的习惯，除了开发流程和代码分支的管理方式以外，还包括日常开发中的一些约定俗成的规约。阿里的许多开发规约是有“文献”记载的，主要收录在 《阿里巴巴 Java 开发手册》 里面。它的内容现在已经公开了，所以早就不算是秘密。 举一个具体的例子。在 AoneFlow 的流程中，每次重建发布分支的时候都会重新合并然后编译代码，产生新的部署包。然而，即使代码的内容是一样的，如果工程中依赖了一些会改变的第三方软件包，依然可能导致打包出的产品行为不完全一致。因此，在阿里的代码规约中就明确地指出了，用于线上发布的代码，不可以使用包含“SNAPSHOT 版本”（即未正式发布版本）的依赖包，从而确保每次构建出的产物都是一致的。类似这样的细节还有很多，好的开发习惯是确保软件质量的必要前提。 工具可以使得团队协作更加平滑。虽然只要弄懂原理，AoneFlow 中每个分支创建、合并、更改步骤使用单纯的 Git 命令就能玩转。但其中的一些操作（比如为每个发布分支选出恰当的特性分支组合进行合并）手工执行极易出错，而且让团队的个人重复这些日常琐事的命令操作，并不是令人愉悦的事情。 在阿里内部，使用 AoneFlow 流程的团队基本上不用自己运行 Git 来处理分支的事情，而是由阿里巴巴集团内部名叫 Aone 的协同研发平台（以下简称平台）接管。这个承担集团 80% 产品从需求和用户故事提出到部署上线完整研发流程的平台，内置了许多以服务组件的形式嵌入的研发提效工具，其中的发布组件为 AoneFlow 的用户体验添色不少。比较显著的辅助“功效”包括以下几个方面。 首先是整体流程的自动化。 由于是内部工具，平台的功能高度内聚。对于项目而言，从提出原始需求，将需求拆分为任务，然后根据任务在线创建特性分支，再聚合生成发布分支，同时根据模板自动创建测试环境，直到后期的运维保障都可以一站式的搞定。 这个流程已经远远超出了代码分支管理的范畴。但正是因为如此，平台对于 AoneFlow，向前做到了将特性分支和需求项关联起来，确保了特性分支的命名规范性；向后做到了将发布分支与部署行为关联起来，确保了各环境版本来源的可靠性。打通了端到端交付的任督二脉。 其次是发布分支的流水线。 作为一种流程自动化的手段，CI/CD 流水线是许多现代交付团队中常见的标配实践。在 AoneFlow 的代码生命周期里涉及许多分支，当这些分支被创建或更新时，往往需要伴随其他的一系列行为。流水线能够将这些日常开发过程中的代码分支与其所表达的深层意图（比如提交代码即进行集成测试）联系起来。特别是发布分支，AoneFlow 的每个发布分支通常关联具体的部署环境，当有新代码合并进分支时，就应该及时对代码进行检查和部署。 理想情况下，每条不同的分支都应该有与其作用相匹配的一条流水线来为它服务。AoneFlow 的发布分支是相对固定的，因此相比 GitFlow 更易于进行持续集成。理论上任何流水线工具都能够配合 AoneFlow 使用，不过，阿里的统一平台提供流水线对代码评审、安全检查、在线部署等功能的整合，还是为 AoneFlow 在内部团队的使用优化增色不少。 还有一项很有用的辅助是分支关联的管理。 特性分支与发布分支的关联关系维护是一个 AoneFlow 特有的问题。记住每个发布分支分别来自哪些特性分支对于需要基于现有特性组合进行改变的时候十分有意义。比如当需要将某个特性从特定发布分支退出时，通常会将除了该特性以外的其他特性所在分支进行一次合并，以替换原有的发布分支。人为的记录这些信息并不轻松，要是通过平台进行展示和辅助就会方便许多。 当某些功能组合在一个低级别的发布环境（如集成测试环境）验证完成后，我们希望将它的内容直接迁移到高级别的环境（如预发布环境）对应的发布分支上。这样可以确保线上的版本一定是经过预发验证的，预发的版本一定是经过集成验证的，以此类推，使得各个发布分支形成串联。同样的，使用普通的 Git 命令就能实现这个操作，只不过用可视化工具会让流程更加直观。 作者：一杯甜酒来源：CSDN原文：https://blog.csdn.net/u012562943/article/details/79754587]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>AoneFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯 CSS 实现多行文字截断]]></title>
    <url>%2Fblob%2F2017-12-11-pure-css-for-multi-line-text-truncation%2F</url>
    <content type="text"><![CDATA[单行文本截断 text-overflow 文本溢出我们经常用到的应该就是 text-overflow:ellipsis 了，相信大家也很熟悉，只需轻松几行代码就可以实现单行文本截断。 12345 .nowrap &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; 实现效果： 优点： 属性浏览器原生支持，各大浏览器兼容性好 缺点： 就是只支持单行文本截断，并不支持多行文本截取。 适用场景： 单行文字截断最简单实现，效果最好，放心使用。 多行文本截断 -webkit-line-clamp 123456 .nowrap2 &#123; display: -webkit-box; overflow: hidden; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125; 它需要和 display、 -webkit-box-orient 和 overflow 结合使用： display:-webkit-box; 必须结合的属性，将对象作为弹性伸缩盒子模型显示。 -webkit-box-orient; 必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式。 text-overflow:ellipsis; 可选属性，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本。 实现效果： 优点： 响应式截断，根据不同宽度做出调整。 文本超出范围才显示省略号，否则不显示省略号。 浏览器原生实现，所以省略号位置显示刚好。 缺点： 因为 -webkit-line-clamp 是一个不规范的属性，它没有出现在 CSS 规范草案中。也就是说只有 webkit 内核的浏览器才支持这个属性，像 Firefox, IE 浏览器统统都不支持这个属性，浏览器兼容性不好。 使用场景： 多用于移动端页面，因为移动设备浏览器更多是基于 webkit 内核，除了兼容性不好，实现截断的效果不错。 定位元素实现多行文本截断 另外还有一种靠谱简单的做法就是设置相对定位的容器高度，用包含省略号(…)的伪元素模拟实现，通过伪元素绝对定位到行尾并遮住文字，再通过 overflow:hidden隐藏多余文字，实现方式如下： 123456789101112131415161718192021 p &#123; position: relative; line-height: 18px; height: 36px; overflow: hidden; word-break:break-all; &#125;p::after &#123; content:"..."; font-weight:bold; position:absolute; bottom:0; right:0; padding:0 20px 1px 45px; /* 为了展示效果更好 */ background: -webkit-gradient(linear, left top, right top, from(rgba(255, 255, 255, 0)), to(white), color-stop(50%, white)); background: -moz-linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white); background: -o-linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white); background: -ms-linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white); background: linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white);&#125; 实现效果： 优点： 兼容性好，对各大主流浏览器有好的支持 响应式截断，根据不同宽度做出调整 缺点： 省略号一直显示，无法做到自适应显示 适合场景： 文字内容较多，确定文字内容一定会超过容器的，那么选择这种方式不错。 float 特性实现多行文本截断 有个三个盒子 div，粉色盒子左浮动，浅蓝色盒子和黄色盒子右浮动： 当浅蓝色盒子的高度低于粉色盒子，黄色盒子仍会处于浅蓝色盒子右下方。 如果浅蓝色盒子文本过多，高度超过了粉色盒子，则黄色盒子不会停留在右下方，而是掉到了粉色盒子下。 那么我们可以将黄色盒子进行相对定位，将内容溢出的黄色盒子移动到文本内容右下角，而未溢出的则会被移到外太空去了，只要我们使用 overflow:hidden就可以隐藏掉。 基本原理就是这样，我们可以将浅蓝色区域想象成标题，黄色区域想象为省略号效果。那么你可能会觉得粉色盒子占了空间，那岂不是标题会整体延后了吗，这里可以通过 margin 的负值来出来，设置浅蓝色盒子的 margin-left 的负值与粉色盒子的宽度相同，标题也能正常显示。 123 &lt;div class="wrap"&gt; &lt;div class="text"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dignissimos labore sit vel itaque delectus atque quos magnam assumenda quod architecto perspiciatis animi.&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738 .wrap &#123; height: 40px; line-height: 20px; overflow: hidden;&#125;.wrap .text &#123; float: right; margin-left: -5px; width: 100%; word-break: break-all;&#125;.wrap::before &#123; float: left; width: 5px; content: ''; height: 40px;&#125;.wrap::after &#123; float: right; content: "..."; height: 20px; line-height: 20px; /* 为三个省略号的宽度 */ width: 3em; /* 使盒子不占位置 */ margin-left: -3em; /* 移动省略号位置 */ position: relative; left: 100%; top: -20px; padding-right: 5px; text-align: right; background: -webkit-gradient(linear, left top, right top, from(rgba(255, 255, 255, 0)), to(white), color-stop(50%, white)); background: -moz-linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white); background: -o-linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white); background: -ms-linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white); background: linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white);&#125; 实现效果： 优点： 兼容性好，对各大主流浏览器有好的支持。 响应式截断，根据不同宽度做出调整。 文本超出范围才显示省略号，否则不显示省略号。 缺点： 因为我们是模拟省略号，所以显示位置有时候没办法刚刚好 以上为从 https://segmentfault.com/a/1190000016879657 获取 结合第一种方式实现 显示几行就创建几行内容，每一行的宽度为相应的倍数，同时从第二行开始比上一行位移一份的宽度。 1234567891011121314151617181920212223242526272829303132 &lt;style&gt; *&#123; margin: 0; padding: 0; border: 0; &#125; .nowrap &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; &#125; .wrap&#123; width: 100%; overflow: hidden; position: relative; &#125; .line&#123; /* 两行的宽度为200%，三行的宽度为300% */ width: 200%; &#125; .line2&#123; /* 两行向左位移50%，三行向左位移33.3333% */ transform: translateX(-50%); &#125;&lt;/style&gt;&lt;div class="wrap"&gt; &lt;div class="line nowrap"&gt;文本溢出我们经常用到的应该就是 text-overflow:ellipsis 了，相信大家也很熟悉，只需轻松几行代码就可以实现单行文本截断。&lt;/div&gt; &lt;div class="line nowrap line2"&gt;文本溢出我们经常用到的应该就是 text-overflow:ellipsis 了，相信大家也很熟悉，只需轻松几行代码就可以实现单行文本截断。&lt;/div&gt;&lt;/div&gt; 优点： 响应式截断，根据不同宽度做出调整。 文本超出范围才显示省略号，否则不显示省略号。 浏览器原生实现，所以省略号位置显示刚好。 缺点： 在换行处会出现一半文字的情况 这一段为自己思考所得 float与-webkit-line-clamp的实现 -webkit-line-clamp是webkit内核的私有css属性，用于进行多行省略，在安卓和ios上全支持。但它固定使用省略号，无法直接扩展。而且自带了溢出截断逻辑，作用于容器高度。仔细考察可发现它使用的省略号是单字符…，可以用文字css属性如font-size,letter-spacing,color等控制。 利用右浮动原理——右浮动元素从右到左依次排列，不够空间则换行。 原理展示： 123456789101112131415 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;style&gt;@-webkit-keyframes width-change &#123;0%,100%&#123;width: 320px&#125; 50%&#123;width:260px&#125;&#125;/*测试*/&lt;/style&gt;&lt;div style="position: relative;line-height:18px;-webkit-animation: width-change 8s ease infinite;max-height: 108px;"&gt; &lt;div style="font-size: 36px;letter-spacing: 28px;display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 6;color: transparent;line-height: 18px;position: relative;"&gt; &lt;div style="font-size:12px;color: #000;display: inline;vertical-align: top;letter-spacing: 0;"&gt; 腾讯成立于1998年11月，是目前中国领先的互联网增值服务提供商之一。成立10多年来，腾讯一直秉承“一切以用户价值为依归”的经营理念，为亿级海量用户提供稳定优质的各类服务，始终处于稳健发展状态。2004年6月16日，腾讯控股有限公司在香港联交所主板公开上市(股票代号700)。 &lt;/div&gt; &lt;div style="position:absolute;top: 0;left: 50%;width: 100%;height: 100%;letter-spacing: 0;color: #000;font-size: 12px;background: rgba(173, 216, 230, 0.5);"&gt; &lt;div style="float: right;width: 50%;height: 100%;background: rgba(255, 192, 203, 0.5);"&gt;&lt;/div&gt; &lt;div style="float: right;width: 50%;height: 108px;background: hsla(223, 100%, 50%, 0.19);"&gt;&lt;/div&gt; &lt;div style="float: right;width: 50px;height: 18px;position: relative;background: rgba(255, 165, 0, 0.5);" class=""&gt;... 更多&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 将-webkit-line-clamp实现的文字溢出截断代码为主体，叠加绝对定位同步的按需显示...更多结构。因为绝对定位，这里使用百分比简化代码。最外包一层结构限制最大高度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;style&gt;/* * 行高 h * 最大行数 n * ...更多容器的宽 w * 字号 f */@-webkit-keyframes width-change &#123;0%,100%&#123;width: 320px&#125; 50%&#123;width:260px&#125;&#125;.ellipsis &#123; position: relative; background: rgb(230, 230, 230); width: 260px; max-height: 108px; /* h*n */ line-height: 18px; /* h */ overflow: hidden; -webkit-animation: width-change 8s ease infinite;&#125;.ellipsis-container &#123; position: relative; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 6; /* n */ font-size: 50px; /* w */ color: transparent;&#125;.ellipsis-content &#123; color: #000; display: inline; vertical-align: top; font-size: 12px; /* f */&#125;.ellipsis-ghost &#123; position:absolute; z-index: 1; top: 0; left: 50%; width: 100%; height: 100%; color: #000;&#125;.ellipsis-ghost:before &#123; content: ""; display: block; float: right; width: 50%; height: 100%;&#125;.ellipsis-placeholder &#123; content: ""; display: block; float: right; width: 50%; height: 108px; /* h*n */&#125;.ellipsis-more &#123; float: right; font-size: 12px; /* f */ width: 50px; /* w */ height: 18px; /* h */ margin-top: -18px; /* -h */&#125;&lt;/style&gt;&lt;div class="ellipsis"&gt; &lt;div class="ellipsis-container"&gt; &lt;div class="ellipsis-content"&gt;腾讯成立于1998年11月，是目前中国领先的互联网增值服务提供商之一。成立10多年来，腾讯一直秉承“一切以用户价值为依归”的经营理念，为亿级海量用户提供稳定优质的各类服务，始终处于稳健发展状态。2004年6月16日，腾讯控股有限公司在香港联交所主板公开上市(股票代号700)。&lt;/div&gt; &lt;div class="ellipsis-ghost"&gt; &lt;div class="ellipsis-placeholder"&gt;&lt;/div&gt; &lt;div class="ellipsis-more"&gt;...更多&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 优点： 响应式截断，根据不同宽度做出调整。 文本超出范围才显示省略号，否则不显示省略号。 可以在尾部添加更多的操作 缺点： 因为 -webkit-line-clamp 是一个不规范的属性，它没有出现在 CSS 规范草案中。也就是说只有 webkit 内核的浏览器才支持这个属性，像 Firefox, IE 浏览器统统都不支持这个属性，浏览器兼容性不好。 省略号位置不好控制 使用场景： 多用于移动端页面，因为移动设备浏览器更多是基于 webkit 内核，除了兼容性不好，实现截断的效果不错。 适配不同机型 不同浏览器的默认字体可能不同，建议设置这个字体，这个字体将…显示为空白正方形，font-size的值就是字符的宽 1234 @font-face &#123;font-family: "more";src: url(data:application/x-font-ttf;charset=utf-8;base64,AAEAAAAKAIAAAwAgT1MvMi85nScAAACsAAAAYGNtYXAAECHwAAABDAAAAVJnbHlmHJQQ0QAAAmAAAAAcaGVhZAzV4GIAAAJ8AAAANmhoZWEHwgPCAAACtAAAACRobXR4BAAAAAAAAtgAAAAGbG9jYQAOAAAAAALgAAAABm1heHAABAAGAAAC6AAAACBuYW1lGDPoTwAAAwgAAAGGcG9zdACvAAIAAASQAAAAJgAEBAABkAAFAAACmQLMAAAAjwKZAswAAAHrADMBCQAAAAAAAAAAAAAAAIAAAAEQAAAAAAAAAAAAAAAAAAAAAEAgJv/9A8D/wABAA8AAQAAAAAEAAAAAAAAAAAAAACAAAAAAAAMAAAADAAAAHAABAAAAAABMAAMAAQAAABwABAAwAAAACAAIAAIAACAm//3/////AAAgJv/9/////9/bAAMAAQABAAAAAAAAAAAAAAEGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA/8EEAAO/AAMAAAERIREEAPwAA7/8AgP+AAEAAAABAACqw1blXw889QALBAAAAAAA1QO70wAAAADUsuASAAD/wQQAA78AAAAIAAIAAAAAAAAAAQAAA8D/wAAABAAAAAAABAAAAQAAAAAAAAAAAAAAAAAAAAEEAAAAAAAAAAAAAAAADgAAAAEAAAACAAQAAQAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAOAK4AAQAAAAAAAQAHAAAAAQAAAAAAAgAHAAcAAQAAAAAAAwAHAA4AAQAAAAAABAAHABUAAQAAAAAABQALABwAAQAAAAAABgAHACcAAQAAAAAACgAaAC4AAwABBAkAAQAOAEgAAwABBAkAAgAOAFYAAwABBAkAAwAOAGQAAwABBAkABAAOAHIAAwABBAkABQAWAIAAAwABBAkABgAOAJYAAwABBAkACgA0AKRpY29tb29uUmVndWxhcmljb21vb25pY29tb29uVmVyc2lvbiAxLjBpY29tb29uRm9udCBnZW5lcmF0ZWQgYnkgSWNvTW9vbi4AaQBjAG8AbQBvAG8AbgBSAGUAZwB1AGwAYQByAGkAYwBvAG0AbwBvAG4AaQBjAG8AbQBvAG8AbgBWAGUAcgBzAGkAbwBuACAAMQAuADAAaQBjAG8AbQBvAG8AbgBGAG8AbgB0ACAAZwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABJAGMAbwBNAG8AbwBuAC4AAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAIAAACrAAA=) format("truetype");&#125; line-clamp有3宗罪 text-align:justify一起用会使省略号和文字相叠 超出截断后会截掉部分行高 省略号出现在单词中间 题主自己玩的显示溢出字数，不明所以 js实现 来源于 http://hai.li/2016/03/05/multiline-overflow-ellipsis.html ，借助 getClientRects 实现 1234567891011121314151617181920212223242526272829303132333435 function getRowRects(element) &#123; var rects = [], clientRects = element.getClientRects(), len = clientRects.length, clientRect, top, rectsLen, rect, i; for(i=0; i&lt;len; i++) &#123; has = false; rectsLen = rects.length; clientRect = clientRects[i]; top = clientRect.top; while(rectsLen--) &#123; rect = rects[rectsLen]; if (rect.top == top) &#123; has = true; break; &#125; &#125; if(has) &#123; rect.right = rect.right &gt; clientRect.right ? rect.right : clientRect.right; rect.width = rect.right - rect.left; &#125; else &#123; rects.push(&#123; top: clientRect.top, right: clientRect.right, bottom: clientRect.bottom, left: clientRect.left, width: clientRect.width, height: clientRect.height &#125;); &#125; &#125; return rects;&#125; 在线示例：https://codepen.io/defims/pen/jqWMJG 某些公司的做法 Google Plus用透明到白色的渐变遮罩，渐变遮罩在文字超出的时候才显示，但无法挤出文字，且背景只能纯色，不理想。 豌豆荚则更简单粗暴换行显示，换行显示则文字未超出时依然显示 …xxx，更不理想！ 出处地址 https://segmentfault.com/a/1190000008649988 https://segmentfault.com/a/1190000016879657 http://hai.li/2016/03/05/multiline-overflow-ellipsis.html]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>文字截断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机端去除阴影]]></title>
    <url>%2Fblob%2F2017-11-27-shadow-removal-on-mobile-phone%2F</url>
    <content type="text"><![CDATA[手机端去除阴影 1 -webkit-tap-highlight-color: rgba(0,0,0,0); 还有如下未验证解决方案 12345 a &#123; -webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; -webkit-user-select: none;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE Atom 安装]]></title>
    <url>%2Fblob%2F2017-09-14-ide-atom-installation%2F</url>
    <content type="text"><![CDATA[安装C/C++运行环境需要安装 python（https://www.python.org/）或者visual studio， 安装Atom下载 https://atom.io/ 设置系统环境变量管理员打开cmd 12345678 Windows temporary:set ATOM_NODE_URL=http://gh-contractor-zcbenz.s3.amazonaws.com/atom-shell/distWindows permanently:setx ATOM_NODE_URL http://gh-contractor-zcbenz.s3.amazonaws.com/atom-shell/dist /MLinuxexport ATOM_NODE_URL=http://gh-contractor-zcbenz.s3.amazonaws.com/atom-shell/dist 开始使用]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>工具</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cnpm安装与启动]]></title>
    <url>%2Fblob%2F2017-09-12-cnpm-installation-and-start-up%2F</url>
    <content type="text"><![CDATA[Node安装 安装目录：/usr/local/node安装命令：copy启动命令：环境变量指向此位置，无需 Python3安装 安装目录：/usr/local/python3环境变量执行此位置 export PATH=/usr/local/python3/bin:/usr/local/node/bin:$PATH Nginx安装 安装目录：/usr/local/nginx安装命令： 123 ./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_ssl_module --with-http_sub_module --with-http_gzip_static_module --with-http_stub_status_module --with-http_realip_modulemakemake install 启动命令： 1234 #cp /usr/local/nginx/sbin #./nginx#ps -ef | grep nginx #kill -9 23325 Mysql安装 安装目录： 12345678910 [root@rhel5 ~]# find / -name mysql -print/etc/logrotate.d/mysql/etc/rc.d/init.d/mysql/var/lib/mysql/var/lib/mysql/mysql/var/lock/subsys/mysql/usr/lib/mysql/usr/include/mysql/usr/share/mysql/usr/bin/mysql 而 data默认放在：/var/lib/mysqlmysql默认安装在了：/usr/share/mysql中安装命令：rpm安装启动命令：service mysql start Cnpmjs.org安装 安装目录：/root/cnpmjs.org-2.6.2安装命令：copy启动命令：#cp /root/cnpmjs.org-2.6.2 #node dispatch.js 访问： 12 http://192.168.33.21:7001http://192.168.33.21:7002 使用npm的时候也可以加上 –verbose参数来查看更详细的日志]]></content>
      <categories>
        <category>Npm</category>
      </categories>
      <tags>
        <tag>杂项</tag>
        <tag>cnpm</tag>
        <tag>自定义npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm模块管理器]]></title>
    <url>%2Fblob%2F2017-09-11-npm-module-manager%2F</url>
    <content type="text"><![CDATA[简介 npm有两层含义。一层含义是Node的开放式模块登记和管理系统，网址为npmjs.org。另一层含义是Node默认的模块管理器，是一个命令行下的软件，用来安装和管理Node模块。 npm不需要单独安装。在安装Node的时候，会连带一起安装npm。但是，Node附带的npm可能不是最新版本，最好用下面的命令，更新到最新版本。 1 $ npm install npm@latest -g 上面的命令中，@latest表示最新版本，-g表示全局安装。所以，命令的主干是npm install npm，也就是使用npm安装自己。之所以可以这样，是因为npm本身与Node的其他模块没有区别。 然后，运行下面的命令，查看各种信息。 1234567891011 # 查看 npm 命令列表$ npm help# 查看各个命令的简单用法$ npm -l# 查看 npm 的版本$ npm -v# 查看 npm 的配置$ npm config list -l npm init npm init用来初始化生成一个新的package.json文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。 如果使用了-f（代表force）、-y（代表yes），则跳过提问阶段，直接生成一个新的package.json文件。 1 $ npm init -y npm set npm set用来设置环境变量。 1234 $ npm set init-author-name 'Your name'$ npm set init-author-email 'Your email'$ npm set init-author-url 'http://yourdomain.com'$ npm set init-license 'MIT' 上面命令等于为npm init设置了默认值，以后执行npm init的时候，package.json的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 ~/.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行npm config。 1 $ npm set save-exact true 上面命令设置加入模块时，package.json将记录模块的确切版本，而不是一个可选的版本范围。 npm config 1 $ npm config set prefix $dir 上面的命令将指定的$dir目录，设为模块的全局安装目录。如果当前有这个目录的写权限，那么运行npm install的时候，就不再需要sudo命令授权了。 1 $ npm config set save-prefix ~ 上面的命令使得npm install --save和npm install --save-dev安装新模块时，允许的版本范围从克拉符号（^）改成波浪号（~），即从允许小版本升级，变成只允许补丁包的升级。 12 $ npm config set init.author.name $name$ npm config set init.author.email $email 上面命令指定使用npm init时，生成的package.json文件的字段默认值。 npm info npm info命令可以查看每个模块的具体信息。比如，查看underscore模块的信息。 12345678910111213141516171819 $ npm info underscore&#123; name: 'underscore', description: 'JavaScript\'s functional programming helper library.', 'dist-tags': &#123; latest: '1.5.2', stable: '1.5.2' &#125;, repository: &#123; type: 'git', url: 'git://github.com/jashkenas/underscore.git' &#125;, homepage: 'http://underscorejs.org', main: 'underscore.js', version: '1.5.2', devDependencies: &#123; phantomjs: '1.9.0-1' &#125;, licenses: &#123; type: 'MIT', url: 'https://raw.github.com/jashkenas/underscore/master/LICENSE' &#125;, files: [ 'underscore.js', 'underscore-min.js', 'LICENSE' ], readmeFilename: 'README.md'&#125; 上面命令返回一个JavaScript对象，包含了underscore模块的详细信息。这个对象的每个成员，都可以直接从info命令查询。 12345678 $ npm info underscore descriptionJavaScript's functional programming helper library.$ npm info underscore homepagehttp://underscorejs.org$ npm info underscore version1.5.2 npm search npm search命令用于搜索npm仓库，它后面可以跟字符串，也可以跟正则表达式。 1 $ npm search &lt;搜索词&gt; 下面是一个例子。 123456 $ npm search node-gyp// NAME DESCRIPTION// autogypi Autogypi handles dependencies for node-gyp projects.// grunt-node-gyp Run node-gyp commands from Grunt.// gyp-io Temporary solution to let node-gyp run `rebuild` under…// ... npm list npm list命令以树型结构列出当前项目安装的所有模块，以及它们依赖的模块。 1 $ npm list 加上global参数，会列出全局安装的模块。 1 $ npm list -global npm list命令也可以列出单个模块。 1 $ npm list underscore npm install 基本用法 Node模块采用npm install命令安装。 每个模块可以“全局安装”，也可以“本地安装”。“全局安装”指的是将一个模块安装到系统目录中，各个项目都可以调用。一般来说，全局安装只适用于工具模块，比如eslint和gulp。“本地安装”指的是将一个模块下载到当前项目的node_modules子目录，然后只有在项目目录之中，才能调用这个模块。 123456 # 本地安装$ npm install &lt;package name&gt;# 全局安装$ sudo npm install -global &lt;package name&gt;$ sudo npm install -g &lt;package name&gt; npm install也支持直接输入Github代码库地址。 12 $ npm install git://github.com/package/path.git$ npm install git://github.com/package/path.git#0.1.0 安装之前，npm install会先检查，node_modules目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。 如果你希望，一个模块不管是否安装过，npm 都要强制重新安装，可以使用-f或--force参数。 1 $ npm install &lt;packageName&gt; --force 如果你希望，所有模块都要强制重新安装，那就删除node_modules目录，重新执行npm install。 12 $ rm -rf node_modules$ npm install 安装不同版本 install命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上@和版本号。 123 $ npm install sax@latest$ npm install sax@0.1.1$ npm install sax@"&gt;=0.1.0 &lt;0.2.0" 如果使用--save-exact参数，会在package.json文件指定安装模块的确切版本。 1 $ npm install readable-stream --save --save-exact install命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在packages.json文件的哪一项中。 –save：模块名将被添加到dependencies，可以简化为参数-S。–save-dev: 模块名将被添加到devDependencies，可以简化为参数-D。 12345 $ npm install sax --save$ npm install node-tap --save-dev# 或者$ npm install sax -S$ npm install node-tap -D 如果要安装beta版本的模块，需要使用下面的命令。 12345 # 安装最新的beta版$ npm install &lt;module-name&gt;@beta (latest beta)# 安装指定的beta版$ npm install &lt;module-name&gt;@1.3.1-beta.3 npm install默认会安装dependencies字段和devDependencies字段中的所有模块，如果使用--production参数，可以只安装dependencies字段的模块。 123 $ npm install --production# 或者$ NODE_ENV=production npm install 一旦安装了某个模块，就可以在代码中用require命令加载这个模块。 12 var backbone = require('backbone')console.log(backbone.VERSION) 避免系统权限 默认情况下，Npm全局模块都安装在系统目录（比如/usr/local/lib/），普通用户没有写入权限，需要用到sudo命令。这不是很方便，我们可以在没有root权限的情况下，安装全局模块。 首先，在主目录下新建配置文件.npmrc，然后在该文件中将prefix变量定义到主目录下面。 1 prefix = /home/yourUsername/npm 然后在主目录下新建npm子目录。 1 $ mkdir ~/npm 此后，全局安装的模块都会安装在这个子目录中，npm也会到~/npm/bin目录去寻找命令。 最后，将这个路径在.bash_profile文件（或.bashrc文件）中加入PATH变量。 1 export PATH=~/npm/bin:$PATH npm update，npm uninstall npm update命令可以更新本地安装的模块。 12345 # 升级当前项目的指定模块$ npm update [package name]# 升级全局安装的模块$ npm update -global [package name] 它会先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本较新，就会安装。 使用-S或--save参数，可以在安装的时候更新package.json里面模块的版本号。 123456789 // 更新之前的package.jsondependencies: &#123; dep1: "^1.1.1"&#125;// 更新之后的package.jsondependencies: &#123; dep1: "^1.2.2"&#125; 注意，从npm v2.6.1 开始，npm update只更新顶层模块，而不更新依赖的依赖，以前版本是递归更新的。如果想取到老版本的效果，要使用下面的命令。 1 $ npm --depth 9999 update npm uninstall命令，卸载已安装的模块。 1234 $ npm uninstall [package name]# 卸载全局模块$ npm uninstall [package name] -global npm run npm不仅可以用于模块管理，还可以用于执行脚本。package.json文件有一个scripts字段，可以用于指定脚本命令，供npm直接调用。 123456789101112 &#123; "name": "myproject", "devDependencies": &#123; "jshint": "latest", "browserify": "latest", "mocha": "latest" &#125;, "scripts": &#123; "lint": "jshint **.js", "test": "mocha test/" &#125;&#125; 上面代码中，scripts字段指定了两项命令lint和test。命令行输入npm run-script lint或者npm run lint，就会执行jshint **.js，输入npm run-script test或者npm run test，就会执行mocha test/。npm run是npm run-script的缩写，一般都使用前者，但是后者可以更好地反应这个命令的本质。 npm run命令会自动在环境变量$PATH添加node_modules/.bin目录，所以scripts字段里面调用命令时不用加上路径，这就避免了全局安装NPM模块。 npm run如果不加任何参数，直接运行，会列出package.json里面所有可以执行的脚本命令。 npm内置了两个命令简写，npm test等同于执行npm run test，npm start等同于执行npm run start。 npm run会创建一个Shell，执行指定的命令，并临时将node_modules/.bin加入PATH变量，这意味着本地模块可以直接运行。 举例来说，你执行ESLint的安装命令。 1 $ npm i eslint --save-dev 运行上面的命令以后，会产生两个结果。首先，ESLint被安装到当前目录的node_modules子目录；其次，node_modules/.bin目录会生成一个符号链接node_modules/.bin/eslint，指向ESLint模块的可执行脚本。 然后，你就可以在package.json的script属性里面，不带路径的引用eslint这个脚本。 123456789 &#123; "name": "Test Project", "devDependencies": &#123; "eslint": "^1.10.3" &#125;, "scripts": &#123; "lint": "eslint ." &#125;&#125; 等到运行npm run lint的时候，它会自动执行./node_modules/.bin/eslint .。 如果直接运行npm run不给出任何参数，就会列出scripts属性下所有命令。 123456 $ npm runAvailable scripts in the user-service package: lint jshint **.js test mocha test/ 下面是另一个package.json文件的例子。 123456 "scripts": &#123; "watch": "watchify client/main.js -o public/app.js -v", "build": "browserify client/main.js -o public/app.js", "start": "npm run watch &amp; nodemon server.js", "test": "node test/all.js"&#125;, 上面代码在scripts项，定义了四个别名，每个别名都有对应的脚本命令。 1234 $ npm run watch$ npm run build$ npm run start$ npm run test 其中，start和test属于特殊命令，可以省略run。 12 $ npm start$ npm test 如果希望一个操作的输出，是另一个操作的输入，可以借用Linux系统的管道命令，将两个操作连在一起。 1 "build-js": "browserify browser/main.js | uglifyjs -mc &gt; static/bundle.js" 但是，更方便的写法是引用其他npm run命令。 1 "build": "npm run build-js &amp;&amp; npm run build-css" 上面的写法是先运行npm run build-js，然后再运行npm run build-css，两个命令中间用&amp;&amp;连接。如果希望两个命令同时平行执行，它们中间可以用&amp;连接。 下面是一个流操作的例子。 12345678 "devDependencies": &#123; "autoprefixer": "latest", "cssmin": "latest"&#125;,"scripts": &#123; "build:css": "autoprefixer -b 'last 2 versions' &lt; assets/styles/main.css | cssmin &gt; dist/main.css"&#125; 写在scripts属性中的命令，也可以在node_modules/.bin目录中直接写成bash脚本。下面是一个bash脚本。 1234 #!/bin/bashcd site/mainbrowserify browser/main.js | uglifyjs -mc &gt; static/bundle.js 假定上面的脚本文件名为build.sh，并且权限为可执行，就可以在scripts属性中引用该文件。 1 "build-js": "bin/build.sh" 参数 npm run命令还可以添加参数。 123 "scripts": &#123; "test": "mocha test/"&#125; 上面代码指定npm test，实际运行mocha test/。如果要通过npm test命令，将参数传到mocha，则参数之前要加上两个连词线。 123 $ npm run test -- anothertest.js# 等同于$ mocha test/ anothertest.js 上面命令表示，mocha要运行所有test子目录的测试脚本，以及另外一个测试脚本anothertest.js。 npm run本身有一个参数-s，表示关闭npm本身的输出，只输出脚本产生的结果。 12345 // 输出npm命令头$ npm run test// 不输出npm命令头$ npm run -s test scripts脚本命令最佳实践 scripts字段的脚本命令，有一些最佳实践，可以方便开发。首先，安装npm-run-all模块。 1 $ npm install npm-run-all --save-dev 这个模块用于运行多个scripts脚本命令。 123456789101112131415161718 # 继发执行$ npm-run-all build:html build:js# 等同于$ npm run build:html &amp;&amp; npm run build:js# 并行执行$ npm-run-all --parallel watch:html watch:js# 等同于$ npm run watch:html &amp; npm run watch:js# 混合执行$ npm-run-all clean lint --parallel watch:html watch:js# 等同于$ npm-run-all clean lint$ npm-run-all --parallel watch:html watch:js# 通配符$ npm-run-all --parallel watch:* ###（1）start脚本命令 start脚本命令，用于启动应用程序。 1 "start": "npm-run-all --parallel dev serve" 上面命令并行执行dev脚本命令和serve脚本命令，等同于下面的形式。 1 $ npm run dev &amp; npm run serve 如果start脚本没有配置，npm start命令默认执行下面的脚本，前提是模块的根目录存在一个server.js文件。 1 $ node server.js ###（2）dev脚本命令 dev脚本命令，规定开发阶段所要做的处理，比如构建网页资源。 1 "dev": "npm-run-all dev:*" 上面命令用于继发执行所有dev的子命令。 1 "predev:sass": "node-sass --source-map src/css/hoodie.css.map --output-style nested src/sass/base.scss src/css/hoodie.css" 上面命令将sass文件编译为css文件，并生成source map文件。 1 "dev:sass": "node-sass --source-map src/css/hoodie.css.map --watch --output-style nested src/sass/base.scss src/css/hoodie.css" 上面命令会监视sass文件的变动，只要有变动，就自动将其编译为css文件。 1 "dev:autoprefix": "postcss --use autoprefixer --autoprefixer.browsers \"&gt; 5%\" --output src/css/hoodie.css src/css/hoodie.css" 上面命令为css文件加上浏览器前缀，限制条件是只考虑市场份额大于5%的浏览器。 ###（3）serve脚本命令 serve脚本命令用于启动服务。 1 "serve": "live-server dist/ --port=9090" 上面命令启动服务，用的是live-server模块，将服务启动在9090端口，展示dist子目录。 live-server模块有三个功能。 启动一个HTTP服务器，展示指定目录的index.html文件，通过该文件加载各种网络资源，这是file://协议做不到的。添加自动刷新功能。只要指定目录之中，文件有任何变化，它就会刷新页面。npm run serve命令执行以后，自动打开浏览器。、 以前，上面三个功能需要三个模块来完成：http-server、live-reload和opener，现在只要live-server一个模块就够了。 ###（4）test脚本命令 test脚本命令用于执行测试。 12 "test": "npm-run-all test:*","test:lint": "sass-lint --verbose --config .sass-lint.yml src/sass/*" 上面命令规定，执行测试时，运行lint脚本，检查脚本之中的语法错误。 ###（5）prod脚本命令 prod脚本命令，规定进入生产环境时需要做的处理。 123 "prod": "npm-run-all prod:*","prod:sass": "node-sass --output-style compressed src/sass/base.scss src/css/prod/hoodie.min.css","prod:autoprefix": "postcss --use autoprefixer --autoprefixer.browsers "&gt; 5%" --output src/css/prod/hoodie.min.css src/css/prod/hoodie.min.css" 上面命令将sass文件转为css文件，并加上浏览器前缀。 ###（6）help脚本命令 help脚本命令用于展示帮助信息。 1 "help": "markdown-chalk --input DEVELOPMENT.md" 上面命令之中，markdown-chalk模块用于将指定的markdown文件，转为彩色文本显示在终端之中。 ###（7）docs脚本命令 docs脚本命令用于生成文档。 1 "docs": "kss-node --source src/sass --homepage ../../styleguide.md" 上面命令使用kss-node模块，提供源码的注释生成markdown格式的文档。 pre- 和 post- 脚本 npm run为每条命令提供了pre-和post-两个钩子（hook）。以npm run lint为例，执行这条命令之前，npm会先查看有没有定义prelint和postlint两个钩子，如果有的话，就会先执行npm run prelint，然后执行npm run lint，最后执行npm run postlint。 12345678910111213 &#123; "name": "myproject", "devDependencies": &#123; "eslint": "latest" "karma": "latest" &#125;, "scripts": &#123; "lint": "eslint --cache --ext .js --ext .jsx src", "test": "karma start --log-leve=error karma.config.js --single-run=true", "pretest": "npm run lint", "posttest": "echo 'Finished running tests'" &#125;&#125; 上面代码是一个package.json文件的例子。如果执行npm test，会按下面的顺序执行相应的命令。 pretest test posttest 如果执行过程出错，就不会执行排在后面的脚本，即如果prelint脚本执行出错，就不会接着执行lint和postlint脚本。 下面是一个例子。 12345 &#123; "test": "karma start", "test:lint": "eslint . --ext .js --ext .jsx", "pretest": "npm run test:lint"&#125; 上面代码中，在运行npm run test之前，会自动检查代码，即运行npm run test:lint命令。 下面是一些常见的pre-和post-脚本。 prepublish：发布一个模块前执行。postpublish：发布一个模块后执行。preinstall：用户执行npm install命令时，先执行该脚本。postinstall：用户执行npm install命令时，安装结束后执行该脚本，通常用于将下载的源码编译成用户需要的格式，比如有些模块需要在用户机器上跟本地的C++模块一起编译。preuninstall：卸载一个模块前执行。postuninstall：卸载一个模块后执行。preversion：更改模块版本前执行。postversion：更改模块版本后执行。pretest：运行npm test命令前执行。posttest：运行npm test命令后执行。prestop：运行npm stop命令前执行。poststop：运行npm stop命令后执行。prestart：运行npm start命令前执行。poststart：运行npm start命令后执行。prerestart：运行npm restart命令前执行。postrestart：运行npm restart命令后执行。 对于最后一个npm restart命令，如果没有设置restart脚本，prerestart和postrestart会依次执行stop和start脚本。 另外，不能在pre脚本之前再加pre，即prepretest脚本不起作用。 注意，即使Npm可以自动运行pre和post脚本，也可以手动执行它们。 1 $ npm run prepublish 下面是post install的例子。 123 &#123; "postinstall": "node lib/post_install.js"&#125; 上面的这个命令，主要用于处理从Git仓库拉下来的源码。比如，有些源码是用TypeScript写的，可能需要转换一下。 下面是publish钩子的一个例子。 1234567 &#123; "dist:modules": "babel ./src --out-dir ./dist-modules", "gh-pages": "webpack", "gh-pages:deploy": "gh-pages -d gh-pages", "prepublish": "npm run dist:modules", "postpublish": "npm run gh-pages &amp;&amp; npm run gh-pages:deploy"&#125; 上面命令在运行npm run publish时，会先执行Babel编译，然后调用Webpack构建，最后发到Github Pages上面。 以上都是npm相关操作的钩子，如果安装某些模块，还能支持Git相关的钩子。下面以husky模块为例。 1 $ npm install husky --save-dev 安装以后，就能在package.json添加precommit、prepush等钩子。 12345678 &#123; "scripts": &#123; "lint": "eslint yourJsFiles.js", "precommit": "npm run test &amp;&amp; npm run lint", "prepush": "npm run test &amp;&amp; npm run lint", "...": "..." &#125;&#125; 类似作用的模块还有pre-commit、precommit-hook等。 内部变量 scripts字段可以使用一些内部变量，主要是package.json的各种字段。 比如，package.json的内容是{&quot;name&quot;:&quot;foo&quot;, &quot;version&quot;:&quot;1.2.5&quot;}，那么变量npm_package_name的值是foo，变量npm_package_version的值是1.2.5。 12345 &#123; "scripts":&#123; "bundle": "mkdir -p build/$npm_package_version/" &#125;&#125; 运行npm run bundle以后，将会生成build/1.2.5/子目录。 config字段也可以用于设置内部字段。 1234567 "name": "fooproject","config": &#123; "reporter": "xunit"&#125;,"scripts": &#123; "test": "mocha test/ --reporter $npm_package_config_reporter"&#125; 上面代码中，变量npm_package_config_reporter对应的就是reporter。 通配符 npm的通配符的规则如下。 匹配0个或多个字符? 匹配1个字符[…] 匹配某个范围的字符。如果该范围的第一个字符是!或^，则匹配不在该范围的字符。!(pattern|pattern|pattern) 匹配任何不符合给定的模式?(pattern|pattern|pattern) 匹配0个或1个给定的模式+(pattern|pattern|pattern) 匹配1个或多个给定的模式(a|b|c) 匹配0个或多个给定的模式@(pattern|pat|pat?erN) 只匹配给定模式之一** 如果出现在路径部分，表示0个或多个子目录。 npm link 开发NPM模块的时候，有时我们会希望，边开发边试用，比如本地调试的时候，require(&#39;myModule&#39;)会自动加载本机开发中的模块。Node规定，使用一个模块时，需要将其安装到全局的或项目的node_modules目录之中。对于开发中的模块，解决方法就是在全局的node_modules目录之中，生成一个符号链接，指向模块的本地目录。 npm link就能起到这个作用，会自动建立这个符号链接。 请设想这样一个场景，你开发了一个模块myModule，目录为src/myModule，你自己的项目myProject要用到这个模块，项目目录为src/myProject。首先，在模块目录（src/myModule）下运行npm link命令。 1 src/myModule$ npm link 上面的命令会在NPM的全局模块目录内，生成一个符号链接文件，该文件的名字就是package.json文件中指定的模块名。 1 /path/to/global/node_modules/myModule -&gt; src/myModule 这个时候，已经可以全局调用myModule模块了。但是，如果我们要让这个模块安装在项目内，还要进行下面的步骤。 切换到项目目录，再次运行npm link命令，并指定模块名。 1 src/myProject$ npm link myModule 上面命令等同于生成了本地模块的符号链接。 1 src/myProject/node_modules/myModule -&gt; /path/to/global/node_modules/myModule 然后，就可以在你的项目中，加载该模块了。 1 var myModule = require('myModule'); 这样一来，myModule的任何变化，都可以直接反映在myProject项目之中。但是，这样也出现了风险，任何在myProject目录中对myModule的修改，都会反映到模块的源码中。 如果你的项目不再需要该模块，可以在项目目录内使用npm unlink命令，删除符号链接。 1 src/myProject$ npm unlink myModule npm bin npm bin命令显示相对于当前目录的，Node模块的可执行脚本所在的目录（即.bin目录）。 123 # 项目根目录下执行$ npm bin./node_modules/.bin npm adduser npm adduser用于在npmjs.com注册一个用户。 1234 $ npm adduserUsername: YOUR_USER_NAMEPassword: YOUR_PASSWORDEmail: YOUR_EMAIL@domain.com npm publish npm publish用于将当前模块发布到npmjs.com。执行之前，需要向npmjs.com申请用户名。 1 $ npm adduser 如果已经注册过，就使用下面的命令登录。 1 $ npm login 登录以后，就可以使用npm publish命令发布。 1 $ npm publish 如果当前模块是一个beta版，比如1.3.1-beta.3，那么发布的时候需要使用tag参数，将其发布到指定标签，默认的发布标签是latest。 1 $ npm publish --tag beta 如果发布私有模块，模块初始化的时候，需要加上scope参数。只有npm的付费用户才能发布私有模块。 1 $ npm init --scope=&lt;yourscope&gt; 如果你的模块是用ES6写的，那么发布的时候，最好转成ES5。首先，需要安装Babel。 1 $ npm install --save-dev babel-cli@6 babel-preset-es2015@6 然后，在package.json里面写入build脚本。 1234 "scripts": &#123; "build": "babel source --presets babel-preset-es2015 --out-dir distribution", "prepublish": "npm run build"&#125; 运行上面的脚本，会将source目录里面的ES6源码文件，转为distribution目录里面的ES5源码文件。然后，在项目根目录下面创建两个文件.npmignore和.gitignore，分别写入以下内容。 123456 // .npmignoresource// .gitignorenode_modulesdistribution npm deprecate 如果想废弃某个版本的模块，可以使用npm deprecate命令。 1 $ npm deprecate my-thing@"&lt; 0.2.3" "critical bug fixed in v0.2.3" 运行上面的命令以后，小于0.2.3版本的模块的package.json都会写入一行警告，用户安装这些版本时，这行警告就会在命令行显示。 1 npm owner 模块的维护者可以发布新版本。npm owner命令用于管理模块的维护者。 12345678 # 列出指定模块的维护者$ npm owner ls &lt;package name&gt;# 新增维护者$ npm owner add &lt;user&gt; &lt;package name&gt;# 删除维护者$ npm owner rm &lt;user&gt; &lt;package name&gt; 其他命令 npm home，npm repo npm home命令可以打开一个模块的主页，npm repo命令则是打开一个模块的代码仓库。 12 $ npm home $package$ npm repo $package 这两个命令不需要模块先安装。 npm outdated npm outdated命令检查当前项目所依赖的模块，是否已经有新版本。 1 $ npm outdated 它会输出当前版本（current version）、应当安装的版本（wanted version）和最新发布的版本（latest version）。 npm prune npm prune检查当前项目的node_modules目录中，是否有package.json里面没有提到的模块，然后将所有这些模块输出在命令行。 1 $ npm prune npm shrinkwrap npm shrinkwrap的作用是锁定当前项目的依赖模块的版本。 1 $ npm shrinkwrap 运行该命令后，会在当前项目的根目录下生成一个npm-shrinkwrap.json文件，内容是node_modules目录下所有已经安装的模块，以及它们的精确版本。 下次运行npm install命令时，npm发现当前目录下有npm-shrinkwrap.json文件，就会只安装里面提到的模块，且版本也会保持一致。 上文原文地址 上文原文地址：http://javascript.ruanyifeng.com/nodejs/npm.html#toc19 第三方npm cnpm 国产的npm管理，优点是速度快，缺点是定时更新导致更新有延迟 verdaccio github：https://github.com/verdaccio/verdaccio官网：https://www.verdaccio.org/ 相当于把npm内容下载到本地，同时也可以在本地发布]]></content>
      <categories>
        <category>Npm</category>
      </categories>
      <tags>
        <tag>Npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler抓包https]]></title>
    <url>%2Fblob%2F2017-08-24-fiddler-grab-pack-https%2F</url>
    <content type="text"><![CDATA[原文1原文2 原理 fiddler抓包原理 fiddler 调试器注册到操作系统因特网服务中，系统所有的网络请求都会走fiddler的代理，所以fiddler才能抓包。 Debug traffic from any client and browserFiddler helps you debug traffic from any browser: Internet Explorer, Chrome, Firefox, Safari, Opera, and more. Once you start Fiddler, the web debugger registers itself as the system proxy for Microsoft Windows Internet Services (WinINet), the HTTP layer used by Internet Explorer, Microsoft Office, and many other products. As the system proxy, all HTTP requests from WinINet flow through Fiddler before reaching the target web servers. Similarly, all HTTP responses flow through Fiddler before being returned to the client application.Additionally, most devices that support Wi-Fi or Ethernet can be configured to send their traffic to Fiddler; this includes iOS, Android, Windows Phone and Windows RT devices. fiddler解密https原理 其实fiddler就是中间人攻击，依次经过如下过程 fiddler接到客户端的https请求，fiddler将请求转发给服务器 服务器生成公钥证书，返回给fiddler；fiddler拦截下真的公钥证书，并生成伪造的公钥证书给客户端； 客户端使用伪造的公钥证书加密共享密钥发送给fiddler，fiddler使用伪造的私钥解密获取共享密钥 fiddler将解密后的共享密钥，使用真正的公钥加密发送给服务器端，服务器使用共享密钥与fiddler通信 fiddler使用共享密钥与客户端通信以上是fiddler抓包解密的原理，这个原理是建立在https建立连接的基础上的，请参考https建立连接过程 开始抓包 设置fiddler抓包 File—–&gt;capture traffic 设置抓https和解密https Tools—–&gt;fiddler options—–&gt;https—–&gt;capture https traffic—-&gt;decrypt https traffic—&gt;Ignore server certificate errors—-&gt;Actions—–&gt;Trust root certificate—-&gt;之后都是确定 安装根证书后，可以点击Actions—–&gt;open windows certificate manager查看安装到系统的根证书 根证书的作用：fiddler对每个域名都会生成公钥证书，浏览器会用根证书验证公钥证书的合法性，所以，根证书是https 抓包必不可少的部分效果我们那支付宝登陆界面做测试，支付宝登陆页面 常见问题 http tunnel、http connect 有一种情况，host都是tunnel to， url 后边都带着443，这是什么意思呢？ 查看，请求头会发现使用了Connect方法，Connect方法通常会建议代理(fiddler)与目标服务器建立http tunnel；尽管Connect也可以用于http，但是一般是用于SSL通信； CONNECT www.google.com:443 这句话表示，代理与服务器的443端口建立了http tunnel，在此之后，所有由客户端发送的内容，都会经由http 代理，转发给www.google.com:443端口；更多http tunnel&amp;http connect资料可以参考http tunnel&amp;connect 解密失败 有的时候，发现解密失败，这是可以查看connect的log。如图 通过查看响应，我们看到，是由于没有设置解密导致的，This is a CONNECT tunnel, through which encrypted HTTPS traffic flows.Fiddler’s HTTPS Decryption feature is enabled, but this specific tunnel was configured not to be decrypted. Settings can be found inside Tools &gt; Fiddler Options &gt; HTTPS.A SSLv3-compatible ServerHello handshake was found. Fiddler extracted the parameters below.Tools &gt; Fiddler Options &gt; HTTPS，选中解密https，选择正确的来源，解密成功。 当然，如果不想显示Connect，你也可以设置rules-----&gt;hide connects 隐藏connect；如果还是解密失败，可以查看Log标签页，错误信息都会在这里边显示。 抓不到手机微信 有网友跟我说，抓不到手机微信的数据，这是因为，微信走的http2协议，fiddler不支持http2协议，所以用wireshark抓，但http2也是加密的，所以抓到的数据看不懂。]]></content>
      <categories>
        <category>Fiddler</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler手机抓包]]></title>
    <url>%2Fblob%2F2017-08-24-fiddler-handset-grab-bag%2F</url>
    <content type="text"><![CDATA[启动Fiddler，打开菜单栏中的 Tools &gt; Fiddler Options，打开“Fiddler Options”对话框。 在Fiddler Options”对话框切换到“Connections”选项卡，然后勾选“Allow romote computers to connect”后面的复选框，然后点击“OK”按钮。 打开android设备的“设置”-&gt;“WLAN”，找到你要连接的网络，在上面长按，然后选择“修改网络”，弹出网络设置对话框，然后勾选“显示高级选项” 在“代理”后面的输入框选择“手动”，在“代理服务器主机名”后面的输入框输入电脑的ip地址，在“代理服务器端口”后面的输入框输入8888，然后点击“保存”按钮。]]></content>
      <categories>
        <category>Fiddler</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler断点]]></title>
    <url>%2Fblob%2F2017-05-24-fiddler-breakpoint%2F</url>
    <content type="text"><![CDATA[Fiddler中设置断点修改Request 第一种：打开Fiddler 点击Rules-&gt; Automatic Breakpoint -&gt;Before Requests(这种方法会中断所有的会话)如何消除命令呢？ 点击Rules-&gt; Automatic Breakpoint -&gt;Disabled 第二种: 在命令行中输入命令: bpu www.baidu.com (这种方法只会中断www.baidu.com)如何消除命令呢？ 在命令行中输入命令 bpu Fiddler 能中断这次会话，选择被中断的会话，点击Inspectors tab下的WebForms tab 修改用户名密码，然后点击Run to Completion 如下图所示。 Fiddler中设置断点修改Response 第一种：打开Fiddler 点击Rules-&gt; Automatic Breakpoint -&gt;After Response (这种方法会中断所有的会话)如何消除命令呢？ 点击Rules-&gt; Automatic Breakpoint -&gt;Disabled 第二种: 在命令行中输入命令: bpuafter www.baidu.com (这种方法只会中断www.baidu.com)如何消除命令呢？ 在命令行中输入命令 bpuafter,]]></content>
      <categories>
        <category>Fiddler</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler模拟POST或Get请求]]></title>
    <url>%2Fblob%2F2017-05-24-fiddler-simulates-post-or-get-requests%2F</url>
    <content type="text"><![CDATA[打开我们Fiddler2程序，开始咯(这个刚好英文版的，可以去下载汉化包) 这个要根据图片来，图中标记需要分别介绍下图标记1: 这个是请求状态和结果的显示区域图标记2: 请求的方法选择，常用的就是POST请求和GET请求方式图标记3: 请求的地址输入框图标记4: 我们提交的数据输入框图标记5: 这个是我们请求的数据头输入框图标记6: 点击这个Execute按钮，就可以提交我们的模拟请求 首先使用Fiddler2模拟GET请求1.在地址输入框里面模拟的GET请求地址(已被遮罩了，你们懂得)2.选择请求的方法，这里我们选择GET方法3.点击Execute按钮，就可以执行模拟请求4.在显示区域就可以看到我们刚刚提交的请求5.直接双击显示区域里面的请求记录，就可以看到我们的GET方法的数据 然后使用Fiddler2模拟POST请求1.在地址输入框里面模拟的POST请求地址(已被遮罩了，你们懂得)2.选择请求的方法，这里我们选择POST方法3.在提交的数据输入框里面输入我们提交的POST数据3.点击Execute按钮，就可以执行模拟请求4.在显示区域就可以看到我们刚刚提交的请求5.直接双击显示区域里面的请求记录，就可以看到我们的POST方法的数据]]></content>
      <categories>
        <category>Fiddler</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime lint-JSHint MSG]]></title>
    <url>%2Fblob%2F2017-03-15-ide-sublime-lint-jshint-msg%2F</url>
    <content type="text"><![CDATA[“Missing semicolon.” : “缺少分号.”,“Use the function form of \”use strict\”.” : “使用标准化定义function.”,“Unexpected space after ‘-’.” : “在’-‘后面不应出现空格.”,“Expected a JSON value.” : “请传入一个json的值.”,“Mixed spaces and tabs.”: “空格和TAB重复.”,“Unsafe character.” : “不安全的字符.”,“Line too long.”: “本行中的字符超过设定的最大长度.”,“Trailing whitespace.”: “本行末尾有过多无用空格.”,“Script URL.” : “脚本URL.”,“Unexpected {a} in ‘{b}’.” : “在 ‘{b}’ 中不该出现 {a}.”,“Unexpected ‘{a}’.” : “不该在此出现’{a}’.”,“Strings must use doublequote.” : “字符串需要用双引号”,“Unnecessary escapement.” : “不需要转义”,“Control character in string: {a}.” : “在字符串中出现了Control的字符”,“Avoid \’.” : “避免 \”,“Avoid \v.” : “避免 \v”,“Avoid \x-.” : “避免 \x-”,“Bad escapement.” : “错误的转义字符”,“Bad number ‘{a}’.” : “错误的数字 ‘{a}’”,“Missing space after ‘{a}’.” : “在’{a}’之后缺少空格”,“Don’t use extra leading zeros ‘{a}’.” : “不要再’{a}’的前面用多余的0″,“Avoid 0x-. ‘{a}’.” : “避免使用 0x-. ‘{a}’.”,“A trailing decimal point can be confused with a dot ‘{a}’.” : “在’{a}’中使用点尾随小数点”,“Unexpected comment.” : “不该在此处出现注释”,“Unescaped ‘{a}’.” : “没有转义 ‘{a}’”,“Unexpected control character in regular expression.” : “在正则表达式中出现了control字符”,“Unexpected escaped character ‘{a}’ in regular expression.” : “在正则表达式中出现了没有转义的字符 ‘{a}’”,“Expected ‘{a}’ and instead saw ‘{b}’.” : “应该用 ‘{a}’代替’{b}’”,“Spaces are hard to count. Use .” : “空格难以统计，请使用 ”,“Insecure ‘{a}’.” : “不安全的 ‘{a}’”,“Empty class.” : “空的class”,“Expected a number and instead saw ‘{a}’.”:“应该用数字代替’{a}’”,“‘{a}’ should not be greater than ‘{b}’.”:“‘{a}’不应该比’{b}’大”,“‘hasOwnProperty’ is a really bad name.”: “‘hasOwnProperty’是关键字”,“‘{a}’ was used before it was defined.”:“‘{a}’未定义就已经使用了.”,“‘{a}’ is already defined.”:“‘{a}’被重复定义”,“A dot following a number can be confused with a decimal point.”:“数字后面的一个点会被误认为是十进制的小数点”,“Confusing minusses” : “容易混淆的负数表达-”,“Confusing plusses.” : “容易混淆的正数表达+”,“Unmatched ‘{a}’.” : “无法匹配的’{a}’”,“Expected ‘{a}’ to match ‘{b}’ from line {c} and instead saw ‘{d}’.”:“在行{c}中需要用’{a}’和’{b}’匹配，用来代替’{d}’”,“Unexpected early end of program.”:“程序不可预期的提前终止”,“A leading decimal point can be confused with a dot: ‘.{a}’.”:“‘{a}’前的点容易混淆成小数点”,“Use the array literal notation [].”:“使用数组的符号 []“,“Expected an operator and instead saw ‘{a}’.”:“需要用一个符号来代替’{a}’”,“Unexpected space after ‘{a}’.”:“在’{a}’之后不能出现空格”,“Unexpected space before ‘{a}’.”:“在’{a}’之前不能出现空格”,“Bad line breaking before ‘{a}’.”:“在’{a}’之前错误的换行”,“Expected ‘{a}’ to have an indentation at {b} instead at {c}.”:“‘{a}’需要在{c}而不是{b}处缩进”,“Line breaking error ‘{a}’.”:“换行错误 ‘{a}’”,“Unexpected use of ‘{a}’.”:“此处不能用’{a}’”,“Bad operand.”:“错误的操作数”,“Use the isNaN function to compare with NaN.”:“使用isNaN来与NaN比较”,“Confusing use of ‘{a}’.”:“容易混淆的’{a}’的使用”,“Read only.”:“只读的属性”,“‘{a}’ is a function.”:“‘{a}’是一个函数”,‘Bad assignment.’:“错误的赋值”,“Do not assign to the exception parameter.”:“不要给额外的参数赋值”,“Expected an identifier in an assignment and instead saw a function invocation.”:“在赋值的语句中需要有一个标识符，而不是一个方法的调用”,“Expected an identifier and instead saw ‘{a}’ (a reserved word).”:“需要有一个标识符，而不是’{a}’(保留字符)”,“Missing name in function declaration.”:“在方法声明中缺少名称”,“Expected an identifier and instead saw ‘{a}’.”:“需要有一个标识符，而不是’{a}’”,“Inner functions should be listed at the top of the outer function.”:“内部函数的声明应该放在此函数的顶部。”,“Unreachable ‘{a}’ after ‘{b}’.”:“在’{b}’之后无法获取’{a}’”,“Unnecessary semicolon.”:“不必要的分号”,“Label ‘{a}’ on {b} statement.”:“将’{a}’放在{b}的声明中”,“Label ‘{a}’ looks like a javascript url.”:“‘{a}’看上去像一个js的链接”,“Expected an assignment or function call and instead saw an expression”:“需要一个赋值或者一个函数调用，而不是一个表达式.”,“Do not use ‘new’ for side effects.”:“不要用’new’语句.”,“Unnecessary \”use strict\”.”:“不必要的\”use strict\”.”,“Missing \”use strict\” statement.”:“缺少\”use strict\”的声明”,“Empty block.”:“空的模块”,“Unexpected /member ‘{a}’.”:“不应出现 /元素 ‘{a}’.”,“‘{a}’ is a statement label.”:“‘{a}’是一个声明”,“‘{a}’ used out of scope.”:“‘{a}’使用超出范围”,“‘{a}’ is not allowed.”:“不允许使用’{a}’”,“‘{a}’ is not defined.”:“‘{a}’没有被定义”,“Use ‘{a}’ to compare with ‘{b}’.”:“使用’{a}’与’{b}’相比”,“Variables should not be deleted.”:“变量需要被删除”,“Use the object literal notation {}.”:“使用对象的文字符号 {}”,“Do not use {a} as a constructor.”:“不要使用{a}作为一个构造对象”,“The Function constructor is eval.”:“The Function constructor is eval.”,“A constructor name should start with an uppercase letter.”:“一个构造对象的名称必须用大写字母开头.”,“Bad constructor.”:“错误的构造对象”,“Weird construction. Delete ‘new’.”:“构造对象有误，请删除’new’”,“Missing ‘()’ invoking a constructor.”:“缺少括号()”,“Avoid arguments.{a}.”:“避免参数.{a}.”,“document.write can be a form of eval.”:“document.write是eval的一种形式”,‘eval is evil.’:“尽量不要使用eval”,“Math is not a function.”:“Math不是一个函数”,“Missing ‘new’ prefix when invoking a constructor.”:“此处缺少了’new’”,“Missing radix parameter.”:“缺少参数”,“Implied eval is evil. Pass a function instead of a string.”:“传递一个函数，而不是一个字符串”,“Bad invocation.”:“错误的调用”,“[‘{a}’] is better written in dot notation.”:“[‘{a}’]最好用点.的方式”,“Extra comma.”:“多余的逗号”,“Don’t make functions within a loop.”:“不要用循环的方式创建函数”,“Unexpected parameter ‘{a}’ in get {b} function.”:“在{b}方法中不该用到参数’{a}’”,“Duplicate member ‘{a}’.”:“重复的’{a}’”,“Expected to see a statement and instead saw a block.”:“此处应该是语句声明.”,“Too many var statements.”:“过多var的声明”,“Redefinition of ‘{a}’.”:“‘{a}’被重复定义”,“It is not necessary to initialize ‘{a}’ to ‘undefined’.”:“无需将’{a}’初始化为’undefined’”,“Expected a conditional expression and instead saw an assignment.”:“此处需要一个表达式，而不是赋值语句”,“Expected a ‘break’ statement before ‘case’.”:“在’case’之前需要有’break’.”,“Expected a ‘break’ statement before ‘default’.”:“在’default’之前需要有’break’.”,“This ‘switch’ should be an ‘if’.”:“此处’switch’应该是’if’.”,“All ‘debugger’ statements should be removed.”:“请删除’debugger’的语句”,“‘{a}’ is not a statement label.”:“‘{a}’不是一个声明标签.”,“Function declarations should not be placed in blocks. Use a function expression or move the statement to the top of the outer function.”:“函数的声明不能放在类似if的块中，需要放在外部函数的顶部.”]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime lint-JSHint 配置选项]]></title>
    <url>%2Fblob%2F2017-03-13-ide-sublime-lint-jshint-configuration-options%2F</url>
    <content type="text"><![CDATA[JSHint选项此页面的内容源自JSHint项目存储库。如果您发现错误，请打开一个问题或（更好的）提出拉请求！ 来自官方文档 http://jshint.com/docs/options/#enforceall google翻译 强制执行选项 当设置为true时，这些选项将使JSHint产生更多关于您的代码的警告。 bitwise 此选项禁止使用按位运算符，例如^（XOR）， |（OR）和其他。位运算符在JavaScript程序中非常罕见，而且往往&amp;只是一个错误类型&amp;&amp;。 camelcase 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项允许强制所有变量名称使用camelCase样式或带下划线的UPPER_CASE。 curly 此选项要求您始终在循环和条件中的块周围放置花括号。当块仅包含一个语句时，JavaScript允许您省略花括号，例如：while (day) shuffle();然而，在某些情况下，它可能导致错误（你会认为这 sleep()是循环的一部分，而实际上它不是）：while (day) shuffle(); sleep(); enforceall 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 如果不自动选择让用户使用新功能，则无法维护该选项。这可能会导致在次要版本的JSHint之间升级时出现意外的警告/错误。此选项是JSHint版本2.6.3中提供的最严格的JSHint配置的简写。它启用所有强制执行选项并禁用在该版本中定义的所有轻松选项。 eqeqeq 此选项禁止使用==和!=支持===和 !==。前者在比较之前尝试强制值，这可能导致一些意想不到的结果。后者不做任何强制，所以他们一般更安全。如果你想更多地了解JavaScript中的类型强制，我们推荐 Angus Croll的真理，平等和JavaScript。 es3 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 请esversion: 3改用。这个选项告诉JSHint你的代码需要遵守ECMAScript 3规范。如果您需要您的程序在旧版浏览器（如Internet Explorer 6/7/8/9）和其他旧版JavaScript环境中可执行，请使用此选项。 es5 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 请esversion: 5改用。此选项启用首先在ECMAScript 5.1规范中定义的语法。这包括允许保留关键字作为对象属性。 esversion 此选项用于指定代码必须遵守的ECMAScript版本。它可以采用以下值之一：3 - 如果您需要您的程序在旧版浏览器（如Internet Explorer 6/7/8/9）和其他旧版JavaScript环境中可执行5- 启用首先在ECMAScript 5.1规范中定义的语法。这包括允许保留关键字作为对象属性。6- 告诉JSHint你的代码使用ECMAScript 6的特定语法。请注意，并非所有浏览器都实现它们。 forin 此选项需要所有for in循环过滤对象的项目。for语句允许循环遍历对象的所有属性的名称，包括通过原型链继承的那些属性的名称。此行为可能导致对象中的意外项目，因此通常更安全地筛选继承属性，如示例所示：for (key in obj) { if (obj.hasOwnProperty(key)) { // We are sure that obj[key] belongs to the object and was not inherited. }}要更深入地了解JavaScript中的for in循环，请 参阅 Angus Croll 探索JavaScript for-in循环。 freeze 这个选项禁止重写本地对象如原型 Array，Date等等。// jshint freeze:trueArray.prototype.count = function (value) { return 4; };// -&gt; Warning: Extending prototype of native object: ‘Array’. funcscope 此选项抑制关于在控制结构内声明变量的警告，同时从外部访问它们。即使JavaScript只有两个真实范围 - 全局和函数 - 这样的实践导致新的语言和难以调试的bug的人之间的混乱。这就是为什么，默认情况下，JSHint警告在预期范围之外使用的变量。function test() { if (true) { var x = 0; } x += 1; // Default: ‘x’ used out of scope. // No warning when funcscope:true} futurehostile 此选项启用有关使用在未来版本的JavaScript中定义的标识符的警告。虽然覆盖它们在没有实现的上下文中没有效果，但是当将代码库迁移到该语言的较新版本时，这种做法会引起问题。 globals 此选项可用于指定未在源代码中正式定义的全局变量的白名单。当与undef选项组合时，这是最有用的，以便抑制特定于项目的全局变量的警告。设置条目以true启用读取和写入该变量。将其设置为false将触发JSHint将该变量视为只读。另请参见“环境”选项：一组选项，用于启用在常见JavaScript环境中定义的全局变量。要globals在单个文件中配置，请参阅内联配置。 immed 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项禁止使用立即函数调用，而不将其包含在括号中。括号括号帮助您的代码的读者理解表达式是函数的结果，而不是函数本身。 indent 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项为代码设置特定的制表符宽度。 iterator 此选项禁止有关iterator属性的警告。此属性不受所有浏览器支持，因此请仔细使用它。 latedef 此选项禁止在定义变量之前使用变量。JavaScript只有函数范围，除此之外，所有的变量总是被移动或悬挂到函数的顶部。这种行为可以导致一些非常讨厌的错误，这就是为什么它是更安全的总是使用变量只有在它们被明确定义之后。将此选项设置为“nofunc”将允许忽略函数声明。为了更深入地了解JavaScript中的范围和提升，请阅读 Ben Cherry的JavaScript Scoping和Hoisting。 maxcomplexity 此选项允许您控制整个代码中的循环复杂性。环路复杂性测量通过程序源代码的线性独立路径的数量。阅读更多关于维基百科上的复杂性。 maxdepth 此选项允许您控制嵌套的嵌套方式：// jshint maxdepth:2function main(meaning) { var day = true; if (meaning === 42) { while (day) { shuffle(); if (tired) { // JSHint: Blocks are nested too deeply (3). sleep(); } } }} maxerr 此选项允许您设置JSHint将在放弃之前产生的最大警告量。默认值为50。 maxlen 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项允许您设置线的最大长度。 maxparams 此选项允许您设置每个函数允许的形式参数的最大数量：// jshint maxparams:3function login(request, onSuccess) { // …}// JSHint: Too many parameters per function (4).function logout(request, isManual, whereAmI, onSuccess) { // …} maxstatements 此选项允许您设置每个函数允许的最大语句数：// jshint maxstatements:4function main() { var i = 0; var j = 0; // Function declarations count as one statement. Their bodies // don’t get taken into account for the outer function. function inner() { var i2 = 1; var j2 = 1; return i2 + j2; } j = i + j; return j; // JSHint: Too many statements per function. (5)} newcap 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项需要大写构造函数的名称。与new操作符一起使用的大写函数只是一个约定，帮助程序员在视觉上区分构造函数和其他类型的函数，以帮助在使用时发现错误this。不这样做不会在任何浏览器或环境中破坏你的代码，但是通过阅读代码 - 如果函数应该使用或不使用新的，将更难一些。这很重要，因为当要使用的函数 new没有使用它时，this将指向全局对象而不是新对象。 noarg 此选项禁止使用arguments.caller和 arguments.callee。两者.caller并且.callee做了不少优化是不可能的，所以他们在JavaScript的未来版本中被弃用。事实上，ECMAScript 5禁止arguments.callee 在严格模式下使用。 nocomma 此选项禁止使用逗号运算符。当误用时，逗号运算符可能会掩盖语句的值，并促进错误的代码。 noempty 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项在代码中具有空块时发出警告。JSLint最初是对所有空块的警告，我们只是使其可选。没有研究报告，JavaScript中的空块以任何方式破坏您的代码。 nonbsp 此选项警告“不间断的空格”字符。这些字符可以在Mac计算机上与选项空间一起输入，并有可能中断非UTF8网页。 nonew 此选项禁止使用用于副作用的构造函数。有些人喜欢调用构造函数而不将其结果赋给任何变量：new MyConstructor();这种方法没有优势， MyConstructor因为操作符new创建的对象不在任何地方使用，所以你通常应该避免像这样的构造函数。 notypeof 此选项禁止有关无效typeof运算符值的警告。此运算符只有一组有限的可能返回值。默认情况下，JSHint警告，当您将其结果与一个无效值，通常可以是错字。// ‘fuction’ instead of ‘function’if (typeof a == “fuction”) { // Invalid typeof value ‘fuction’ // …}不要使用此选项，除非你绝对确定不需要这些检查。 predef 此选项允许您控制JSHint认为要在环境中隐式定义的变量。使用字符串值数组配置它。使用连字符（ - ）字符前缀变量名将从预定义变量的集合中删除该名称。JSHint将考虑以这种方式声明的变量是只读的。此选项不能在线指定; 它只能通过JavaScript API或外部配置文件使用。 quotmark 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项强制在您的代码中使用的引号的一致性。它接受三个值：true如果你不想强制一个特定的风格，但想要一些一致性，”single”如果你只想允许单引号，并且”double”如果你只想允许双引号。 shadow 此选项禁止关于变量阴影的警告，即声明已在外部作用域中某处声明的变量。“inner” - 检查在同一范围内定义的变量“outer” - 检查外部作用域中定义的变量false - 与inner相同true - 允许可变阴影 singleGroups 当不严格要求时，此选项禁止使用分组运算符。这种使用通常反映对一元操作符的误解，例如：// jshint singleGroups: truedelete(obj.attr); // Warning: Unnecessary grouping operator. strict 此选项要求代码在ECMAScript 5的strict模式下运行。 严格模式 是选择限制JavaScript版本的一种方式。严格模式消除了一些JavaScript错误，没有通过更改它们产生错误不会导致错误。它还修正了错误，使JavaScript引擎难以执行某些优化。“全球” - “use strict”;在全球层面必须有一个指令“隐含” - 将代码看作有”use strict”;指令false - 禁用关于严格模式的警告true - “use strict”;在函数级别必须有一个指令; this is preferable for scripts intended to be loaded in web browsers directly because enabling strict mode globally could adversely effect other scripts running on the same page undef 此选项禁止使用明确未声明的变量。此选项对于发现泄漏和错误的变量非常有用。// jshint undef:truefunction test() { var myVar = ‘Hello, World’; console.log(myvar); // Oops, typoed here. JSHint with undef will complain}如果你的变量在另一个文件中定义，你可以使用global 指令告诉JSHint它。 unused 此选项在定义和不使用变量时发出警告。这对于一般的代码清理非常有用，特别是在除了使用之外 undef。// jshint unused:truefunction test(a, b) { var c, d = 2; return a + d;}test(1, 2);// Line 3: ‘b’ was defined but never used.// Line 4: ‘c’ was defined but never used.除此之外，此选项将警告您通过该global伪指令声明的未使用的全局变量。这可以设置为vars仅检查变量，而不是函数参数，或strict检查所有变量和参数。默认（true）行为是允许未使用的参数，后跟一个使用的参数。 varstmt 当设置为true时，禁止使用VariableStatements。例如：// jshint varstmt: truevar a; // Warning: var declarations are forbidden. Use let or const instead. 放松的选择 当设置为true时，这些选项将使JSHint对您的代码产生较少的警告。 asi 此选项禁止有关缺少的分号的警告。有很多关于分号的FUD被社区中的很多人传播。常见的神话是，分号是一直需要的（他们不是），并且他们是不可靠的。JavaScript有关于分号的规则，所有浏览器都遵循这些规则，所以由您自己决定是否应该在代码中使用分号。有关JavaScript中的分号的更多信息，请参阅 Isaac Schlueter的分号和JavaScript分号插入对JavaScript领导人的公开信。 boss 此选项在预期进行比较的情况下禁止关于分配的使用的警告。通常情况下，代码if (a = 10) {}就是一个拼写错误。但是，它可以在这样的情况下有用：for (var i = 0, person; person = people[i]; i++) {}您可以通过使用括号包围该分配来按用途隐藏此错误，例如：for (var i = 0, person; (person = people[i]); i++) {} debug 此选项禁止对debugger代码中的语句的警告。elision 此选项告诉JSHint您的代码使用ES3数组elision元素，或空元素（例如，[1, , , 4, , , 7]）。 eqnull 此选项禁止有关== null比较的警告。当你想检查一个变量是null或是时，这种比较通常是有用的 undefined。 esnext 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 请esversion: 6改用。此选项告诉JSHint您的代码使用ECMAScript 6特定的语法。请注意，并非所有浏览器都实现这些功能。更多信息：ECMAScript 6规范 evil 此选项禁止有关使用的警告eval。使用是 eval不鼓励的，因为它可以使您的代码易受各种注入攻击，这使得JavaScript解释器很难做某些优化。 expr 此选项禁止有关使用通常希望看到赋值或函数调用的表达式的警告。大多数时候，这样的代码是拼写错误。但是，它不被规范禁止，这就是为什么这个警告是可选的。 globalstrict 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 使用strict: “global”。此选项禁止关于使用全局严格模式的警告。全局严格模式可以打破第三方小部件，因此不推荐使用。有关严格模式的详细信息，请参阅strict选项。 lastsemic 此选项禁止有关缺少的分号的警告，但仅在单行块中的最后一条语句省略分号时：var name = (function() { return ‘Anton’ }());这是一个非常小众的用例，只有当您使用自动JavaScript代码生成器时才有用。 laxbreak 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项抑制大多数有关代码中可能不安全的换行符的警告。它不抑制关于逗号优先编码风格的警告。要抑制那些你必须使用laxcomma（见下文）。 laxcomma 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项禁止关于逗号优先编码样式的警告：var obj = { name: ‘Anton’ , handle: ‘valueof’ , role: ‘SW Engineer’}; loopfunc 此选项禁止对循环中的函数的警告。定义循环中的函数可能会导致如下的错误：var nums = [];for (var i = 0; i &lt; 10; i++) { nums[i] = function (j) { return i + j; };}nums0; // Prints 12 instead of 2要修复上面的代码，你需要复制的值i：var nums = [];for (var i = 0; i &lt; 10; i++) { (function (i) { nums[i] = function (j) { return i + j; }; }(i));} moz 这个选项告诉JSHint你的代码使用Mozilla JavaScript扩展。除非您专门为Firefox Web浏览器开发，否则不需要此选项。更多信息：新的JavaScript 1.7 multistr 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项抑制有关多行字符串的警告。多行字符串在JavaScript中是很危险的，因为如果你不小心在转义字符（\）和一个新行之间放了一个空格，所有的地狱都会松动。请注意，即使此选项允许正确的多行字符串，它仍然警告多行字符串没有转义字符或转义字符和空格之间的任何东西。// jshint multistr:truevar text = “Hello\World”; // All good.text = “HelloWorld”; // Warning, no escape character.text = “Hello\World”; // Warning, there is a space after \ noyield 此选项抑制关于生成函数的警告，其中没有 yield语句。 plusplus 此选项禁止使用一元增量和减量运算符。有些人认为，++并–降低了他们的编码风格的质量，有编程语言，如Python，完全没有这些运算符。 proto 此选项禁止有关proto属性的警告。 scripturl 此选项会禁止关于使用以脚本为目标的网址的警告，例如javascript:…。 sub 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项将禁止使用有关的警告[]符号时，它可以在点符号来表示：person[‘name’]对person.name。 supernew 此选项抑制关于“怪异”结构的警告，如 new function () { … }和new Object;。这种结构有时用于在JavaScript中产生单例：var singleton = new function() { var privateVar; this.publicMethod = function () {} this.publicMethod2 = function () {}}; validthis 当代码以严格模式运行并this在非构造函数中使用时，此选项将禁止有关可能的严重违规的警告。你应该使用这个选项 - 在一个函数范围内 - 当你肯定你的使用this在严格模式是有效的（例如，如果你调用你的函数使用 Function.call）。注意：此选项只能在函数作用域内使用。如果您尝试全局设置此选项，JSHint将失败并显示错误。 withstmt 此选项禁止有关使用语句的警告with。语句的with语义可能导致开发人员之间的混乱和全局变量的意外定义。更多信息：与声明考虑有害 环境 这些选项让JSHint知道一些预定义的全局变量。 browser 此选项定义了现代浏览器暴露全局：从好老一路document和navigator对HTML5 FileReader在浏览器世界等新的发展。注意：此选项不会公开像alert或的 变量console。有关详细信息，请参阅选项devel。 browserify 此选项定义使用Browserify工具构建项目时可用的全局变量。 couch 此选项定义由CouchDB公开的全局变量 。CouchDB是一个面向文档的数据库，可以使用JavaScript以MapReduce方式查询和索引。 devel 此选项定义通常用于记录恶意调试的全局变量：console，alert等等。通常不建议在生产环境中运行它们，因为例如console.log在Internet Explorer的旧版本中断。 dojo 此选项定义由Dojo Toolkit公开的全局变量。 jasmine 此选项定义由Jasmine单元测试框架公开的全局变量。 j query （出现未知情况，加空格解决） 此选项定义由jQuery JavaScript库公开的全局变量。 mocha 此选项定义由摩卡单元测试框架的“BDD”和“TDD”UI公开的全局变量 。 module 此选项通知JSHint输入代码描述了ECMAScript 6模块。所有模块代码都被解释为严格模式代码。 mootools 此选项定义由MooTools JavaScript框架公开的全局变量 。 node 此选项定义当代码在Node运行时环境中运行时可用的全局变量。Node.js是一个使用异步事件驱动模型的服务器端JavaScript环境。此选项还会跳过在浏览器环境中有意义的一些警告，但在节点（如文件级use strict编译指示和console.log语句）中没有意义。 nonstandard 此选项定义非标准但广泛采用的全局变量，如 escape和unescape。 phantom 此选项定义当您的核心在PhantomJS运行时环境中运行时可用的全局变量。PhantomJS 是一个使用JavaScript API的无头WebKit脚本。它支持各种Web标准的快速和本地支持：DOM处理，CSS选择器，JSON，Canvas和SVG。 prototypejs 此选项定义由Prototype JavaScript框架公开的全局变量 。 qunit 此选项定义由QUnit单元测试框架公开的全局变量。 rhino 此选项定义当代码在Rhino运行时环境中运行时可用的全局变量。Rhino 是一个完全用Java编写的JavaScript的开源实现。 shelljs 此选项定义由ShellJS库公开的全局变量。 typed 此选项为类型化数组构造函数定义全局变量。更多信息：JavaScript类型数组 worker 此选项定义当代码在Web Worker中运行时可用的全局变量。Web Workers为Web内容在后台线程中运行脚本提供了一种简单的方法。 wsh 此选项定义当代码作为Windows脚本宿主的脚本运行时可用的全局变量。 yui 此选项定义由YUI JavaScript框架公开的全局变量。]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime lint 语法校验]]></title>
    <url>%2Fblob%2F2017-03-13-ide-sublime-lint-syntax-check%2F</url>
    <content type="text"><![CDATA[package control install package SublimeLinter https://packagecontrol.io/packages/SublimeLinter SublimeLinter-jshint https://packagecontrol.io/packages/SublimeLinter-jshint SublimeLinter-csslint https://packagecontrol.io/packages/SublimeLinter-csslint node install npm i -g jshint npm i -g csslint 配置 可校验js代码编写过程中不规范的地方，因为有缓存不会实时显示在项目根目录下创建.jshintrc文件，文件以json格式保存，可以有哪些设置，在下面这个网站 http://jshint.com/docs/options/ http://sublimelinter.readthedocs.org/en/latest/about.html 例如： { &quot;eqeqeq&quot;: true, // true: Require triple equals (===) for comparison } 使用同一个配置，配置如下。该方法优先于项目下的配置文件 文件：SublimeLinter.sublime-settings 123456789101112131415161718 &#123; &quot;user&quot;: &#123; &quot;debug&quot;: false, &quot;delay&quot;: 0.25, &quot;error_color&quot;: &quot;D02000&quot;, &quot;gutter_theme&quot;: &quot;Packages/SublimeLinter/gutter-themes/Default/Default.gutter-theme&quot;, &quot;gutter_theme_excludes&quot;: [], &quot;lint_mode&quot;: &quot;background&quot;, &quot;linters&quot;: &#123; &quot;jshint&quot;: &#123; &quot;@disable&quot;: false, &quot;args&quot;: [ &quot;--config&quot;, &quot;D:\\config\\.jshintrc&quot; ], &quot;excludes&quot;: [] &#125;, 他人详细教程 https://gaohaoyang.github.io/2015/03/26/sublimeLinter]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime 添加鼠标右键打开]]></title>
    <url>%2Fblob%2F2017-03-03-ide-sublime-add-mouse-right-click-open%2F</url>
    <content type="text"><![CDATA[原文：（http://www.cnblogs.com/1314-/p/6479590.html） 方法一（推荐） 把以下代码，复制到SublimeText3的安装目录，然后重命名为：sublime_addright.inf，然后右击安装就可以了。PS：重命名文件之前，需要先在工具–文件夹选项，查看中，把隐藏已知文件类型的扩展名前边的复选框不勾选。 12345678910 [Version]Signature=&quot;$Windows NT$&quot;[DefaultInstall]AddReg=SublimeText3[SublimeText3]hkcr,&quot;\shell\SublimeText3&quot;,,,&quot;用 SublimeText3 打开&quot;hkcr,&quot;\shell\SublimeText3\command&quot;,,,&quot;&quot;&quot;%1%\sublime_text.exe&quot;&quot; &quot;&quot;%%1&quot;&quot; %%&quot;hkcr,&quot;Directory\shell\SublimeText3&quot;,,,&quot;用 SublimeText3 打开&quot;hkcr,&quot;\shell\SublimeText3&quot;,&quot;Icon&quot;,0x20000,&quot;%1%\sublime_text.exe, 0&quot;hkcr,&quot;Directory\shell\SublimeText3\command&quot;,,,&quot;&quot;&quot;%1%\sublime_text.exe&quot;&quot; &quot;&quot;%%1&quot;&quot;&quot; 方法二 把以下代码，复制到SublimeText3的安装目录，然后重命名为：sublime_addright.reg，然后双击就可以了。PS:需要把里边的Sublime的安装目录，替换成实际的Sublime安装目录。 1234567891011 Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT*\shell\SublimeText3]@=&quot;用 SublimeText3 打开&quot;&quot;Icon&quot;=&quot;D:\Program Files\Sublime Text 3\sublime_text.exe,0&quot;[HKEY_CLASSES_ROOT*\shell\SublimeText3\command]@=&quot;D:\Program Files\Sublime Text 3\sublime_text.exe %1&quot;[HKEY_CLASSES_ROOT\Directory\shell\SublimeText3]@=&quot;用 SublimeText3 打开&quot;&quot;Icon&quot;=&quot;D:\Program Files\Sublime Text 3\sublime_text.exe,0&quot;[HKEY_CLASSES_ROOT\Directory\shell\SublimeText3\command]@=&quot;D:\Program Files\Sublime Text 3\sublime_text.exe %1&quot; 如果以上方法不可行，则手动设置（测试通过，win10）项目路径： 12345 [HKEY_CLASSES_ROOT*\shell\SublimeText3] 默认字符串值：用 SublimeText3 打开 Icon字符串值：D:\Program Files\Sublime Text 3\sublime_text.exe,0 [HKEY_CLASSES_ROOT*\shell\SublimeText3\command] 默认字符串值：D:\Program Files\Sublime Text 3\sublime_text.exe %1 如图一 项目路径： 12345 [HKEY_CLASSES_ROOT\Directory\shell\SublimeText3] 默认字符串值：用 SublimeText3 打开 Icon字符串值：D:\Program Files\Sublime Text 3\sublime_text.exe,0[HKEY_CLASSES_ROOT\Directory\shell\SublimeText3\command] 默认字符串值：D:\Program Files\Sublime Text 3\sublime_text.exe %1 如图2]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT-Flow]]></title>
    <url>%2Fblob%2F2016-08-17-git-flow%2F</url>
    <content type="text"><![CDATA[git-flow 备忘清单 git-flow 备忘清单源码 历史分支 功能分支 发布分支 维护分支 获取分支方式 合并分支方式 Master 主分支 被release、hotfix分支合并 Hotfix 线上修复分支 从master拉取分支 合并到master、develop分支 Release 上线分支 从develop拉取分支 合并到master、develop分支 Develop 开发分支 初始从master拉取分支 合并到master分支 Feature 功能分支 从develop拉取分支、合并分支 合并到develop分支]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Git Flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime Package Ctrl安装与卸载]]></title>
    <url>%2Fblob%2F2016-07-21-installation-and-unloading-of-ide-sublime-package-ctrl%2F</url>
    <content type="text"><![CDATA[http://www.sublimetext.com/3 卸载 打开sublime，选择Preferences &gt; Browse Packages 返回到文件夹上一级，进入Installed Packages 删除 Package Control.sublime-package 重新安装package control https://packagecontrol.io/installation 安装 The simplest method of installation is through the Sublime Text console. The console is accessed via the ctrl+` shortcut or the View &gt; Show Console menu. Once open, paste the appropriate Python code for your version of Sublime Text into the console. SUBLIME TEXT 3 1 import urllib.request,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT-合并最后的2个提交]]></title>
    <url>%2Fblob%2F2016-05-19-git---merge-the-last-two-submissions%2F</url>
    <content type="text"><![CDATA[假设要合并最后的2个提交，可以按如下命令进行： git rebase –i HEAD~2运行完该命令，会出现如下所示内容： 将第二个pick修改为squash或者s，然后输入”:wq”退出。 这时git会自动第二个提交合并到第一个中去。并提示输入新的message（就是我们常说的comments），如下： 编辑输入新的message，然后输入”:wq”退出 此时本地的（HEAD中）最后两次提交已经被合并为一个。git log可以查看。 如果需要提交到远端，运行git push –force origin master即可。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>rebase</tag>
        <tag>合并提交</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime 配置Node.js开发环境]]></title>
    <url>%2Fblob%2F2016-04-01-ide-sublime-configuration-node.js-development-environment%2F</url>
    <content type="text"><![CDATA[1、下载Nodejs插件，下载地址为：https://github.com/tanepiper/SublimeText-Nodejs下载zip压缩包后解压，文件名改为Nodejs 2、打开Sublime Text3，点击菜单“Perferences” =&gt;“Browse Packages”打开“Packages”文件夹，并将第1部的Nodejs文件夹剪切进来 3、打开文件“Nodejs.sublime-build”，将代码 “encoding”: “cp1252” 改为 “encoding”: “utf8” ，将代码 “cmd”: [“taskkill /F /IM node.exe &amp; node”, “$file”] 改为 “cmd”: [“node”, “$file”] ，保存文件 4、打开文件“Nodejs.sublime-settings”，将代码 “node_command”: false改为 “node_command”: “D:\Program Files\nodejs\node.exe” ，将代码 “npm_command”: false 改为 “npm_command”: “D:\Program Files\nodejs\npm.cmd” ，保存文件 5、编写一个测试文件test.js，按“ctrl+B”运行代码，运行结果如下图所示： 至此，环境配置成功！（注：本人的系统为Win10，Nodejs安装路径为E:\Program Files\nodejs）]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime Package Control]]></title>
    <url>%2Fblob%2F2016-03-17-ide-sublime-package-control%2F</url>
    <content type="text"><![CDATA[查看可使用的插件：https://packagecontrol.io/Ctrl + Shift + P、pcip、 代码快速生成器 emmet、emmet css snippets - - - 快速生成简单页面 !，Ctrl + E 该方法是emmet快捷键，分两步完成 ul&gt;.item$*10 &gt;：子元素选择符.item：子元素是item开头$：代表序号*10：输入10个带有class=”item123….10” 扩展，很酷 div#s.d&gt;div#e.s&gt;span.em5&gt;span.im$5 http://emmet.io/https://github.com/sergeche/emmet-sublimehttps://github.com/sergeche/emmet-sublime#tab-key-handler javascript 快速提示 javascript snippet/Completions jquery快速提示 jquery 快速生成回掉函数 `insert callback` https://packagecontrol.io/packages/Insert%20Callback Press Alt+C. If the function call’s trailing semicolon is missing, it will be filled in. A callback function snippet will then be inserted. 123 someAsyncFn(function(err, d) &#123;&#125;); 快速创建文件 advancedNewFile https://packagecontrol.io/packages/AdvancedNewFilehttps://github.com/skuroda/Sublime-AdvancedNewFilectrl+alt+n: General keymap to create new files.ctrl+shift+alt+n: In addition to creating the folders specified, new folders will also contain an init.py file. 测试请求 Http Requester https://packagecontrol.io/packages/Http%20RequesterAlt + Ctrl + R 快速访问选中文字的链接get 请求和 post请求方式不同POST http://posttestserver.com/post.phpContent-type: application/x-www-form-urlencodedPOST_BODY:variable1=avalue&amp;variable2=1234&amp;variable3=anothervalueGET http://www.google.com/search?q=test 每次编码需要公共组件，因此可以从一个公共配置中下载 Nettuts+ Fetch https://packagecontrol.io/packages/Nettuts%2B%20FetchCtrl + Shift + Pfetch: file 下载选择文件内容fetch: manage 管理配置文件类库fetch: package 添加sidebar右键功能 Side​Bar​Enhancements https://packagecontrol.io/packages/SideBarEnhancements 生成文件头部注释 FileHeaderhttps://packagecontrol.io/packages/FileHeader 添加注释代码 Doc​Blockr https://packagecontrol.io/packages/DocBlockr 语法校验 Sublime​Linter https://packagecontrol.io/packages/SublimeLinter SublimeLinter-jshint https://packagecontrol.io/packages/SublimeLinter-jshint npm i -g jshint SublimeLinter-csslint https://packagecontrol.io/packages/SublimeLinter-csslint npm i -g csslint 可校验js代码编写过程中不规范的地方，因为有缓存不会实时显示在项目根目录下创建.jshintrc文件，文件以json格式保存，可以有哪些设置，在下面这个网站http://jshint.com/docs/options/http://sublimelinter.readthedocs.org/en/latest/about.html例如： { “eqeqeq”: true, // true: Require triple equals (===) for comparison }使用同一个配置，配置如下文件：SublimeLinter.sublime-settings 123456789101112131415161718 &#123; &quot;user&quot;: &#123; &quot;debug&quot;: false, &quot;delay&quot;: 0.25, &quot;error_color&quot;: &quot;D02000&quot;, &quot;gutter_theme&quot;: &quot;Packages/SublimeLinter/gutter-themes/Default/Default.gutter-theme&quot;, &quot;gutter_theme_excludes&quot;: [], &quot;lint_mode&quot;: &quot;background&quot;, &quot;linters&quot;: &#123; &quot;jshint&quot;: &#123; &quot;@disable&quot;: false, &quot;args&quot;: [ &quot;--config&quot;, &quot;D:\\.jshintrc&quot; ], &quot;excludes&quot;: [] &#125;, 切换语言 ChineseLocalization 切换语言，帮助(H)/Language/简体中文，繁体中文，日本语，English。 HTML+CSS+JAVASCRIPT+JSON快速格式化 HTML-CSS-JS Prettify https://packagecontrol.io/packages/HTML-CSS-JS%20Prettify Tools -&gt; Command Palette (Cmd+Shift+P or Ctrl+Shift+P) and type htmlprettify.– or –Ctrl+Shift+H (or Cmd+Shift+H if you’re on a Mac).– or –Right click in the current buffer and select HTML/CSS/JS Prettify -&gt; Prettify Code.安装完运行需要从新设置node路径 CSS2REM 安装 下载本项目，比如：git clone https://github.com/flashlizi/cssrem 进入packages目录：Sublime Text -&gt; Preferences -&gt; Browse Packages… 复制下载的cssrem目录到刚才的packges目录里。 重启Sublime Text。 配置参数 参数配置文件：Sublime Text -&gt; Preferences -&gt; Package Settings -&gt; cssrem px_to_rem - px转rem的单位比例，默认为40。 max_rem_fraction_length - px转rem的小数部分的最大长度。默认为6。 available_file_types - 启用此插件的文件类型。默认为：[“.css”, “.less”, “.sass”] 打开CMD Terminal 打开文件的终端，终端默认是CMD。ctrl+shift+t 打开文件所在文件夹，ctrl+shift+alt+t 打开文件所在项目的根目录文件夹，可以自己重新配置快捷键。也可以右键open terminal here打开。 Less Less语法高亮： pci &gt; less &gt; 重启 &gt; less语法高亮 Less2Csshttps://packagecontrol.io/packages/Less2Cssnpm install less -gdnpm install -g less-plugin-clean-cssnpm install -g less-plugin-autoprefix]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime 快捷键]]></title>
    <url>%2Fblob%2F2016-03-16-ide-sublime-shortcut-key%2F</url>
    <content type="text"><![CDATA[官网：http://www.sublimetext.com/ - - - 快速创建文本编辑区 Ctrl + N - - - 查找文件 Ctrl + P 输入文件名、文件路径、支持模糊匹配 跳转到行 Ctrl + P，： 输入: + 文件中行号 查找方法 JS、CSS Ctrl + P，@xx 输入@ + 方法名/CSS选择器 方向键上下选择 综合查找 Ctrl + P，xx@xx 输入文件名/路径 + @ + 方法名/CSS选择器 方向键上下选择 查找HTML标签 Ctrl + P，#xx - - - 多行光标 Ctrl + D 选择文字，之后没按一次 Ctrl + D可选择一个相同的内容并在其后面出现一个光标，可完成共同编辑。 Ctrl + K/Ctrl + D 取消多行游标的选择，继续Ctrl + D可继续选择 Alt + F3 选中全部 Ctrl + Shift + L 在选中区域最右边添加光标当选中区域是多行时，在每行结尾设置光标 Shift + 鼠标右键拖动 在鼠标右键拖动的时候设置光标 - - - 命令模式 Ctrl + Shift + P 启动命令面板（以下只输入命名）支持模糊匹配 选择语法格式 set syntax CSS、Javascript等， 主题安装https://packagecontrol.io/labels &gt; theme &gt; 找需要查看的主题 Spacegray snippets以模板的方式编程Ctrl + Shift + P &gt; snippet:function 设置大小写转换按键Preferences &gt; Key Bindings { “keys”: [“ctrl+shift+x”], “command”: “upper_case” }, { “keys”: [“ctrl+shift+c”], “command”: “lower_case” }, 设置tab空格数量// The number of spaces a tab is considered equal to“tab_size”: 2,// Set to true to insert spaces when tab is pressed“translate_tabs_to_spaces”: true,]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT 异常]]></title>
    <url>%2Fblob%2F2016-01-20-git-anomaly%2F</url>
    <content type="text"><![CDATA[Couldn’t reserve space for cygwin’s heap, Win32 error 0 问题表现： 0 [main] us 0 init_cheap: VirtualAlloc pointer is null, Win32 error 487 AllocationBase 0x0, BaseAddress 0x68560000, RegionSize 0x390000, State 0x10000 C:\Program Files\Git\bin\sh.exe: *** Couldn’t reserve space for cygwin’s heap, Win32 error 0 解决办法： http://stackoverflow.com/questions/18502999/git-extensions-win32-error-487-couldnt-reserve-space-for-cygwins-heap-win32 在安装目录下X:\xxx\xxx\bin执行如下命令 rebase.exe -b 0x50000000 msys-1.0.dll]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT 常用记录]]></title>
    <url>%2Fblob%2F2015-09-17-common-records-of-git%2F</url>
    <content type="text"><![CDATA[命令 说明 git status 查看当前状态 git log 查看当前分支日志 git branch -a 查看所有分支情况(包括远程分支) git branch 查看所有分支情况 git branch XXXXX 创建分支XXXXX git checkout XXXXX 选择分支XXXXX git checkout -b XXXXX 创建并选择分支XXXXX git push origin myBranch:serverBranch 推送myBranch到serverBranch git push origin :serverBranch 删除服务器分支 git push origin –delete serverfix 删除服务器分支 git push –force 覆盖了服务器上的提交历史(慎用) .gitignore 忽略提交文件的记录文件 git commit -a -m “注释写到这里” -a：为缓存也可提交 -m：添加注释 git tag 标签 git tag -a v0.1 -m “” 含附注标签 git tag v0.2 轻量级标签 git push origin v0.1 推送标签 git rebase -i HEAD~3 合并当前分支前三个提交（未push）(慎用) git rebase -i origin/serverBranch 将未提交至远程服务器的提交合并 git rebase –abort 撤销合并 git rebase –continue 添加完继续执行 git rebase –skip 跳过 git checkout master git merge client 合并client到master git checkout master git rebase client 变基client到master git rebase client master 变基client到master git pull –rebase orgin serverBranch 处理冲突 git add * git rebase –continue 变基远程分支 git fetch git rebase orgin/serverBranch 处理冲突 git add * git rebase –continue 变基远程分支 git fetch origin myBranch:serverBranch 拉取远程分支（本地不存在） git fetch 更新你的远程仓库引用 git checkout -b myBranch origin/serverBranch 拉取远程分支（本地不存在） 第一次建立github项目，初始导入 123456 echo # test &gt;&gt; README.md LICENSE.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/holidaypenguin/test.gitgit push -u origin master Git global setup 12 git config --global user.name "宋施澎"git config --global user.email "songshipeng@rongyi.com" Create a new repository 12345678 mkdir pos_democd pos_demogit inittouch README.mdgit add README.mdgit commit -m "first commit"git remote add origin git@git.internal.rongyi.com:songshipeng/pos_demo.gitgit push -u origin master Push an existing Git repository 123 cd existing_git_repogit remote add origin git@git.internal.rongyi.com:songshipeng/pos_demo.gitgit push -u origin master]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT 提交忽略文件]]></title>
    <url>%2Fblob%2F2015-09-17-git-submits-ignored-files%2F</url>
    <content type="text"><![CDATA[一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。来看一个实际的例子： 123 $ cat .gitignore*.[oa]*~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。 文件 .gitignore 的格式规范如下： 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式最后跟反斜杠（/）说明要忽略的是目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。我们再看一个 .gitignore 文件的例子： 123456 # 此为注释 – 将被 Git 忽略*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改 .gitignore 文件的方法。这个文件每一行保存了一个匹配的规则例如： 123456 # 此为注释 – 将被 Git 忽略*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 这样设置了以后 所有的 .pyc 文件都不会添加到版本库中去。另外 git 提供了一个全局的 .gitignore，你可以在你的用户目录下创建 ~/.gitignoreglobal 文件，以同样的规则来划定哪些文件是不需要版本控制的。需要执行 git config --global core.excludesfile ~/.gitignoreglobal来使得它生效。 其他的一些过滤条件 123456 * ？：代表任意的一个字符* ＊：代表任意数目的字符* &#123;!ab&#125;：必须不是此类型* &#123;ab,bb,cx&#125;：代表ab,bb,cx中任一类型即可* [abc]：代表a,b,c中任一字符即可* [ ^abc]：代表必须不是a,b,c中任一字符 由于git不会加入空目录，所以下面做法会导致tmp不会存在 1 tmp/* //忽略tmp文件夹所有文件 改下方法，在tmp下也加一个.gitignore,内容为 12 *!.gitignore 还有一种情况，就是已经commit了，再加入gitignore是无效的，所以需要删除下缓存 1 git rm -r --cached ignore_file 注意： .gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。 正确的做法是在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。 1 git update-index --assume-unchanged PATH // 在PATH处输入要忽略的文件。 另外 git 还提供了另一种 exclude 的方式来做同样的事情，不同的是 .gitignore 这个文件本身会提交到版本库中去。用来保存的是公共的需要排除的文件。而 .git/info/exclude 这里设置的则是你自己本地需要排除的文件。 他不会影响到其他人。也不会提交到版本库中去。 .gitignore 还有个有意思的小功能， 一个空的 .gitignore 文件 可以当作是一个 placeholder 。当你需要为项目创建一个空的 log 目录时， 这就变的很有用。 你可以创建一个 log 目录 在里面放置一个空的 .gitignore 文件。这样当你 clone 这个 repo 的时候 git 会自动的创建好一个空的 log 目录了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>.gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello-world]]></title>
    <url>%2Fblob%2F1989-01-01-hello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1 $ hexo new "My New Post " More info: Writing Run server 1 $ hexo server More info: Server Generate static files 1 $ hexo generate More info: Generating Deploy to remote sites 1 $ hexo deploy More info: Deployment Tables Are Cool col 3 is right-aligned $1600 Front-matter Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说： 123 title: Hello Worlddate: 2013/7/13 20:46:25--- 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 &nbsp; 分类和标签 只有文章支持分类和标签，您可以在 Front-matter 中设置。 Markdown语法的简要规则 标题 标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。会生成右侧的目录树，同时以不同的字体大小并加粗显示。 12345 # 一级标题## 二级标题### 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 列表 列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。 无序列表 123 * 1* 2* 3 to： 1 2 3 有序列表 123 1. 12. 23. 3 to： 1 2 3 引用 如果你需要引用一小段别处的句子，那么就要用引用的格式。只需要在文本前加入 &gt; 这种尖括号（大于号）即可。 123 &gt; 这里是引用要注意符号和文本间的空格 to： 这里是引用 要注意符号和文本间的空格 图片和链接 插入链接与插入图片的语法很像，区别在一个 !号 1234567891011 图片为：![]()链接为：[]()![BURBERRY](/images/BURBERRY.png)[Baidu](https://www.baidu.com)[BURBERRY][1][1]: https://www.baidu.com to： Baidu BURBERRY 粗体与斜体 用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。 12 **这里是粗体***这里是斜体* to：这里是粗体这里是斜体 表格 12345 | Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 这种语法生成的表格如下： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码框 程序员需要在文章中引用代码框，需要使用`把中间代码包裹起来，或者一个在代码前面加一个tab。 1234567891011 ` ``代码片段，前后各加三个注意实际使用中没用空格，为了显示才加的空格` ```代码元素，前后只有一个` let a; let b; //在前面加tab to： 1 代码片段，前后各加三个 代码元素，前后只有一个 let a; let b; //在前面加tab 分割线 1 *** to：]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
</search>
